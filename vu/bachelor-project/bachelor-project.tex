\documentclass[a4paper,11pt,draft]{article}
\usepackage[english]{babel}
\usepackage{a4}


\usepackage[T1]{fontenc}
\usepackage{ae,aecompl}


\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}


% Fancy headers
\usepackage{fancyhdr}
\fancypagestyle{plain}{\fancyhf{}\renewcommand{\headrulewidth}{0pt}}
\pagestyle{fancy}
\fancyhf{}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0pt}
\renewcommand{\headheight}{14pt}
\lhead{Verifying a CPS Transformation}
\rhead{\thepage}


% Typesetting evaluation rules (http://cristal.inria.fr/~remy/latex/)
\usepackage{mathpartir}


% Don't add chapter to figure numbering
\renewcommand\thefigure{\arabic{figure}}


% Keywords like let,in,then,match,with
\newcommand{\kw}[1]{\mathtt{#1}}


% Theorems
\newtheorem{lemma}{\sffamily Lemma}
\newtheorem{theorem}{\sffamily Theorem}
\newtheorem*{mainlemma}{\sffamily Lemma 1}


% One other fancy thing is sansserif headings, we go through some trouble to
% get this in out document consistently...

% Use sansserif fonts in section headings
\usepackage{sectsty}
\allsectionsfont{\sffamily}

% Use a sansserif font in abstract heading
\usepackage{abstract}
\renewcommand{\abstractnamefont}{\normalfont\small\bfseries\sffamily}
\setlength{\abstitleskip}{-1.5em}

% Furthermore, we use \sffamily in theorem titles and description item titles


% Must be last in preamble
\usepackage[
  pdftex,
  colorlinks,
  citecolor=black,
  filecolor=black,
  linkcolor=black,
  urlcolor=black,
  pdfauthor={Martijn Vermaat},
  pdftitle={Verifying a CPS Transformation} (draft),
  pdfkeywords={lambda calculus, continuation-passing style, verification,
    functional programming},
  draft=false
]{hyperref}
\usepackage[figure]{hypcap}


% TODO
% Don't use eqnarray
% Give appropriate references to Dargaye and Leroy
% State original work (full proof of Lemma 1)
% TODO: check all reductions and add relevant properties (k-closedness
% of certain terms)
% TODO: make distinction clear between evaluation in source and target
% languages?
% TODO: do proper lifting of variables
% TODO: investigate error in theorem one (see example.txt)


\title{\sffamily Verifying a CPS Transformation (draft)}

\author{
  Martijn Vermaat\\[0.3em]
  \href{mailto:mvermaat@cs.vu.nl}{\texttt{mvermaat@cs.vu.nl}}
}
\date{\today}


\begin{document}

\maketitle


\begin{abstract}
  Explanation of continuation-passing style and some examples of CPS-transformed
  terms. Definition of two languages and a transformation to CPS. Proving
  semantics preservation of the transformation. Discussion about mechanized
  verification of CPS transformations.
\end{abstract}


\section{Introduction}\label{sec:introduction}

Continuation-passing style is a \ldots. Dargaye and Leroy
\cite{Dargaye-Leroy-07} have \ldots. We do a case study on their setting, but
simplified.


\section{Languages}\label{sec:languages}

We will be considering two languages, refering to them as `source language' and
`target language'. In this section the syntax and semantics for both languages
are defined.

\subsection{Source Language}

Terms $M$ in the source language are defined by the following grammar:
\begin{align*}
M ::=             &\; x_{n}
                  && \text{variable} \\
\llap{\textbar\:} &\; \lambda^{n}.M
                  && \text{abstraction of arity $n+1$} \\
\llap{\textbar\:} &\; M(M, \ldots, M)
                  && \text{function application} \\
\llap{\textbar\:} &\; \kw{let} \: M \: \kw{in} \: M
                  && \text{binding}
\end{align*}
where $n$ ranges over the natural numbers.

Variables $x_{i}$ are identified by their de Bruijn indices $i$.
An abstraction $\lambda^{n}.M$ binds variables $x_{n}, \ldots, x_{0}$ in $M$.
Simultaneous substitution of terms $N_{0}, \ldots, N_{n}$ for
$x_{0}, \ldots, x_{n}$ in $M$ is written $M\{N_{0}, \ldots, N_{n}\}$.

The big-step operational semantics of the source language is given in
Figure~\ref{fig:sourcesemantics}. The three rules define the evaluation relation
$M \Rightarrow v$ on terms $M$ and values $v$, reading ``$M$ evaluates to $v$''.
A value is any term of the form $\lambda^{n}.M$.

\begin{figure}
\begin{mathpar}
\infer*[left=Values]
       {\:}
       {\lambda^{n}.M \Rightarrow \lambda^{n}.M}
\and
\infer*[left=$\kw{let}$]
       {M \Rightarrow v_{1}
         \\ N\{v_{1}\} \Rightarrow v}
       {(\kw{let} \: M \: \kw{in} \: N) \Rightarrow v}
\and
\infer*[left=Function Application]
       {M \Rightarrow \lambda^{n}.P
         \\ N_{i} \Rightarrow v_{i}
         \\ P\{v_{n}, \ldots, v_{0}\} \Rightarrow v}
       {M(N_{0}, \ldots, N_{n}) \Rightarrow v}
\end{mathpar}
\caption{Source language semantics}
\label{fig:sourcesemantics}
\end{figure}

\subsection{Target Language}

The target language is an adaptation of the source language, adding
continuation variables $\kappa_{i}$ (we will refer to variables $x_{i}$
as source-level variables). The two types of variables are numbered
independently by their de Bruijn indices.

Terms $M'$ in the target language are defined by the following grammar:
\begin{align*}
M' ::=            &\; x_{n}
                  && \text{source-level variable} \\
\llap{\textbar\:} &\; \kappa_{n}
                  && \text{continuation variable} \\
\llap{\textbar\:} &\; \lambda^{n}.M'
                  && \text{abstraction of arity $n+1$} \\
\llap{\textbar\:} &\; M'(M', \ldots, M')
                  && \text{function application} \\
\llap{\textbar\:} &\; \kw{let} \: M' \: \kw{in} \: M'
                  && \text{binding}
\end{align*}
where $n$ ranges over the natural numbers.

An abstraction $\lambda^{n}.M'$ binds its first argument, the continuation,
to $\kappa_{0}$, and its remaining arguments to $x_{n-1}, \ldots, x_{0}$ in
$M'$.
We write $M'\{N'_{0}, \ldots, N'_{n}\}\{P'_{0}, \ldots, P'_{m}\}$ for the
double simultaneous substitution of $N'_{i}$ for $\kappa_{i}$
($i = 0 \ldots n$) and $P'_{i}$ for $x_{i}$ ($i = 0 \ldots m$) in $M'$.

The big-step operational semantics for the target language is given in
Figure~\ref{fig:targetsemantics}.

\begin{figure}
\begin{mathpar}
\infer*[left=Values]
       {\:}
       {\lambda^{n}.M' \Rightarrow \lambda^{n}.M'}
\and
\infer*[left=$\kw{let}$]
       {M' \Rightarrow v_{1}
         \\ N'\{\}\{v_{1}\} \Rightarrow v}
       {(\kw{let} \: M' \: \kw{in} \: N') \Rightarrow v}
\and
\infer*[left=Function Application]
       {M' \Rightarrow \lambda^{n}.P'
         \\ N'_{i} \Rightarrow v_{i}
         \\ P'\{v_{0}\}\{v_{n}, \ldots, v_{1}\} \Rightarrow v}
       {M'(N'_{0}, \ldots, N'_{n}) \Rightarrow v}
\end{mathpar}
\caption{Target language semantics}
\label{fig:targetsemantics}
\end{figure}


\section{Transformation}\label{sec:transformation}

\begin{align*}
\Psi(x_{n}) &=
  x_{n} \\
\Psi(\lambda^{n}.M) &=
  \lambda^{n+1}.[\![M]\!](\kappa_{0}) \\[1em]
[\![A]\!] &=
  \lambda^{0}.\kappa_{0} (\Psi(A)) \\
[\![M(N_{1}, \ldots, N_{n})]\!] &=
  \lambda^{0}.[\![M . N_{1} \ldots N_{n} \: \kw{then} \:
  \kappa_{n}(\kappa_{n+1}, \kappa_{n-1}, \ldots, \kappa_{0})]\!] \\
[\![\kw{let} \: M \: \kw{in} \: N]\!] &=
  \lambda^{0}.[\![M]\!] (\lambda^{0}.\kw{let} \:
  \kappa_{0} \: \kw{in} \: [\![N]\!] (\kappa_{1})) \\
[\![M_{1} \ldots M_{n} \: \kw{then} \: N']\!] &=
  [\![M_{1}]\!] (\lambda^{0} \ldots [\![M_{n}]\!] (\lambda^{0}.N') \ldots )
\end{align*}


\section{Semantics Preservation}\label{sec:semanticpreservation}

We will now show that the transformation $[\![\cdot]\!]$ from source language
terms to target language terms preserves semantics. That is, if a term $M$ in
the source language evaluates to a value $v$, the translation $[\![M]\!]$ of $M$
applied to the initial continuation $\lambda^{0}.\kappa_{0}$, should evaluate to
the target language representation $\Psi(v)$ of $v$. This property is stated in
Theorem~\ref{thm:maintheorem}.

\begin{theorem}\label{thm:maintheorem}
If $M \Rightarrow v$ in the source language, then
$[\![M]\!] (\lambda^{0}.\kappa_{0}) \Rightarrow \Psi(v)$ in the target language.
\end{theorem}

For a proof by induction to go through we need to generalize this result. The
result we will prove is given as Lemma~\ref{lem:mainlemma} and generalizes the
use of the initial continuation to any $\kappa$-closed, one-argument
abstraction.

\begin{lemma}\label{lem:mainlemma}
  Let $K = \lambda^{0}.P$ be a $\kappa$-closed, one-argument
  abstraction of the target language. If $M \Rightarrow v$ in the
  source language, and $P\{\Psi(v)\}\{\} \Rightarrow v'$ in the target
  language, then $[\![M]\!](K) \Rightarrow v'$ in the target language.
\end{lemma}

\begin{proof}
We will sketch the outline of a proof, a more elaborate version can be found in
appendix~\ref{sec:proof}. The proof is by induction on the evaluation derivation
of $M \Rightarrow v$ and case analysis over the term $M$.
\begin{description}
\item[\sffamily Case $\boldsymbol{M = \lambda^{n}.M_{1}}$]\quad
  We need to show
  $(\lambda^{0}.\kappa_{0}(\Psi(\lambda^{n}.M_{1}))) (K) \Rightarrow v'$.
  This is trivial.
\item[\sffamily Case $\boldsymbol{M = M_{1}(N_{0}, \ldots, N_{n})}$]\quad
  Premises are $M_{1} \Rightarrow \lambda^{n}.Q$, $N_{i} \Rightarrow v_{i}$,
  and $Q\{v_{n}, \ldots, v_{0}\} \Rightarrow v$. Our goal is to show
  \begin{equation*}
    [\![M_{1}]\!]
    (\lambda^{0}.[\![N_{0}]\!](\lambda^{0}. \cdots
    [\![N_{n}]\!](\lambda^{0}.\kappa_{n+1}((\lambda^{0}.P), \kappa_{n},
    \ldots, \kappa_{0})) \cdots ))
    \Rightarrow v' \text{ .}
  \end{equation*}
  We apply the induction hypothesis to the first premise and our new goal is
  \begin{equation*}
    [\![N_{0}]\!]
    (\lambda^{0}. \cdots [\![N_{n}]\!](\lambda^{0}.\Psi(\lambda^{n}.Q)
    ((\lambda^{0}.P), \kappa_{n}, \ldots, \kappa_{0})) \cdots )
    \Rightarrow v' \text{ .}
  \end{equation*}
  Repeatedly applying the induction hypothesis to premises
  $N_{i} \Rightarrow v_{i}$ (starting with $i=0$) leaves us to show
  \begin{equation*}
    [\![Q\{v_{n}, \ldots, v_{0}\}]\!] (\lambda^{0}.P) \Rightarrow v'
  \end{equation*}
  which follows from the induction hypothesis applied to the last premise and
  the assumption $P\{\Psi(v)\}\{\} \Rightarrow v'$.
\item[\sffamily Case $\boldsymbol{M = \kw{let} \: M_{1} \: \kw{in} \: M_{2}}$]\quad
  Premises are $M_{1} \Rightarrow v_{1}$ and $M_{2}\{v_{1}\} \Rightarrow v$.
  We show
  \begin{equation*}
    [\![M_{1}]\!]
    (\lambda^{0}. \: \kw{let} \: \kappa_{0} \: \kw{in} \: [\![M_{2}]\!]
    (\Uparrow_{x}^{1} \lambda^{0}.P)) \Rightarrow v'
  \end{equation*}
  by applying the induction hypothesis to the first premise. Via the
  $\kw{let}$-evaluation rule, our result follows from
  \begin{equation*}
    [\![M_{2}\{v_{1}\}]\!] (\Uparrow_{x}^{1} \lambda^{0}.P)
    \Rightarrow v' \text{ .}
  \end{equation*}
  The assumption $P\{\Psi(v)\}\{\} \Rightarrow v'$ and the induction hypothesis
  applied to the second premise complete the proof.\qedhere
\end{description}
\end{proof}

\paragraph{}

Theorem~\ref{thm:maintheorem} is an instantiation of
Lemma~\ref{lem:mainlemma}, so we can now prove it easily.

\begin{proof}[Proof of Theorem~\ref{thm:maintheorem}]
We take for $K$ in Lemma~\ref{lem:mainlemma} the initial continuation
$\lambda^{0}.\kappa_{0}$, yielding
$[\![M]\!] (\lambda^{0}.\kappa_{0}) \Rightarrow \Psi(v)$.
\end{proof}


\section{Automated Verification of CPS Transformations}\label{sec:automated}

Discussie over het correct bewijzen van dergelijke transformaties met een
computer. Wat zijn de verschillende manieren om alles te representeren en te
bewijzen? Hoe verhouden die zich tot elkaar?


\appendix


\section{Semantics Preservation Proof}\label{sec:proof}

\subsection*{Lemma 1}

{\em
  Let $K = \lambda^{0}.P$ be a $\kappa$-closed, one-argument
  abstraction of the target language. If $M \Rightarrow v$ in the
  source language, and $P\{\Psi(v)\}\{\} \Rightarrow v'$ in the target
  language, then $[\![M]\!](K) \Rightarrow v'$ in the target language.
}

\subsection*{Proof}

We assume $M \Rightarrow v$ and proceed by induction on its derivation, also
assuming $P\{\Psi(v)\}\{\} \Rightarrow v'$.

\begin{description}
\item[\sffamily Case $\boldsymbol{M = \lambda^{n}.M_{1}}$]\hfill

  This is the base case, where $v = \lambda^{n}.M_{1}$.

  We need to show $[\![\lambda^{n}.M_{1}]\!] (K) \Rightarrow v'$. That is, after
  working out $[\![\cdot]\!]$,
  $(\lambda^{0}.\kappa_{0}(\Psi(\lambda^{n}.M_{1}))) (K) \Rightarrow v'$.

  This is trivial, because according to the evaluation rule for
  function application we have
  \begin{eqnarray*}
   &             & (\lambda^{0}.\kappa_{0}(\Psi(\lambda^{n}.M_{1}))) (K) \\
   & \Rightarrow & K (\Psi(\lambda^{n}.M_{1})) \\
   & \Rightarrow & P\{\Psi(\lambda^{n}.M_{1})\}\{\}
  \end{eqnarray*}

\item[\sffamily Case $\boldsymbol{M = M_{1}(N_{0}, \ldots, N_{n})}$]\hfill

Premises of the evaluation rule for function application are
$M_{1} \Rightarrow \lambda^{n}.Q$, $N_{i} \Rightarrow v_{i}$,
and $Q\{v_{n}, \ldots, v_{0}\} \Rightarrow v$.

We need to show $[\![M_{1}(N_{0}, \ldots, N_{n})]\!](\lambda^{0}.P) \Rightarrow v'$.

Working out the transformation $[\![\cdot]\!]$ and function application,
we get
\begin{eqnarray*}
&   & [\![M_{1}(N_{0}, \ldots, N_{n})]\!] (\lambda^{0}.P) \\
& = & (\lambda^{0}.[\![M_{1}.N_{0} \ldots N_{n} \: \kw{then} \: \kappa_{n+1}(\kappa_{n+2}, \kappa_{n}, \ldots, \kappa_{0})]\!]) (\lambda^{0}.P) \\
& = & (\lambda^{0}.[\![M_{1}]\!](\lambda^{0}.[\![N_{0}]\!](\lambda^{0}. \cdots [\![N_{n}]\!](\lambda^{0}.\kappa_{n+1}(\kappa_{n+2}, \kappa_{n}, \ldots, \kappa_{0})) \cdots ))) (\lambda^{0}.P) \\
& \Rightarrow & [\![M_{1}]\!](\lambda^{0}.[\![N_{0}]\!](\lambda^{0}. \cdots [\![N_{n}]\!](\lambda^{0}.\kappa_{n+1}((\lambda^{0}.P), \kappa_{n}, \ldots, \kappa_{0})) \cdots ))
\end{eqnarray*}

Let $P_{1} = [\![N_{0}]\!](\lambda^{0}. \cdots [\![N_{n}]\!](\lambda^{0}.\kappa_{n+1}((\lambda^{0}.P), \kappa_{n}, \ldots, \kappa_{0})) \cdots )$ and $K_{1} = \lambda^{0}.P_{1}$ which is $\kappa$-closed ($[\![N_{i}]\!]$ is $\kappa$-closed by lemma 3).

Applying the induction hypothesis to our first premise, we know that $[\![M_{1}]\!](K_{1}) \Rightarrow v'$ if $P_{1}\{\Psi(\lambda^{n}.Q)\}\{\} \Rightarrow v'$.

We have
\begin{eqnarray*}
&   & P_{1}\{\Psi(\lambda^{n}.Q)\}\{\} \\
& = & [\![N_{0}]\!](\lambda^{0}. \cdots [\![N_{n}]\!](\lambda^{0}.\Psi(\lambda^{n}.Q)((\lambda^{0}.P), \kappa_{n}, \ldots, \kappa_{0})) \cdots )
\end{eqnarray*}
and repeatedly applying the induction hypothesis to the premises $N_{i} \Rightarrow v_{i}$ leaves us to show
\begin{displaymath}
[\![Q\{v_{n}, \ldots, v_{0}\}]\!] (\lambda^{0}.P) \Rightarrow v'
\end{displaymath}

This follows from the induction hypothesis applied to the last premise
$Q\{v_{n}, \ldots, v_{0}\} \Rightarrow v$ and the assumption $P\{\Psi(v)\}\{\}
\Rightarrow v'$.

\item[\sffamily Case $\boldsymbol{M = \kw{let} \: M_{1} \: \kw{in} \: M_{2}}$]\hfill

The evaluation rule for $\kw{let}$ gives us premises $M_{1} \Rightarrow v_{1}$ and $M_{2}\{v_{1}\} \Rightarrow v$.

We need to show
$[\![\kw{let} \: M_{1} \: \kw{in} \: M_{2}]\!](\lambda^{0}.P) \Rightarrow v'$.

We have
\begin{eqnarray*}
 &   & [\![\kw{let} \: M_{1} \: \kw{in} \: M_{2}]\!](\lambda^{0}.P) \\
 & = & (\lambda^{0}.[\![M_{1}]\!](\lambda^{0}. \: \kw{let} \: \kappa_{0} \: \kw{in} \: [\![M_{2}]\!](\kappa_{1})))(\lambda^{0}.P)
\end{eqnarray*}

By the evaluation rule for function application, this term evaluates to the same value as
\begin{displaymath}
[\![M_{1}]\!](\lambda^{0}. \: \kw{let} \: \kappa_{0} \: \kw{in} \: [\![M_{2}]\!](\Uparrow_{x}^{1} \lambda^{0}.P))
\end{displaymath}

We apply the induction hypothesis to the first premise (knowing that $\lambda^{0}. \: \kw{let} \: \kappa_{0} \: \kw{in} \: [\![M_{2}]\!](\Uparrow_{x}^{1} \lambda^{0}.P)$
is $\kappa$-closed) and the term evaluates to the same value as
\begin{eqnarray*}
 &   & (\kw{let} \: \kappa_{0} \: \kw{in} \: [\![M_{2}]\!](\Uparrow_{x}^{1} \lambda^{0}.P))\{\Psi(v_{1})\}\{\} \\
 & = & \kw{let} \: \Psi(v_{1}) \: \kw{in} \: [\![M_{2}]\!](\Uparrow_{x}^{1} \lambda^{0}.P)
\end{eqnarray*}

By the $\kw{let}$-evaluation rule, this term evaluates as
\begin{eqnarray*}
                 &   & ([\![M_{2}]\!](\Uparrow_{x}^{1} \lambda^{0}.P))\{\}\{\Psi(v_{1})\} \\
                 & = & [\![M_{2}]\!]\{\}\{\Psi(v_{1})\}(\Uparrow_{x}^{1} \lambda^{0}.P) \\
\mbox{(lemma 4)} & = & [\![M_{2}\{v_{1}\}]\!](\Uparrow_{x}^{1} \lambda^{0}.P)
\end{eqnarray*}

Applying the induction hypothesis to the second premise (again, $\Uparrow_{x}^{1} \lambda^{0}.P$ is $\kappa$-closed)
completes our argument:
\begin{eqnarray*}
                               &             & (\Uparrow_{x}^{1}P)\{\Psi(v)\}\{\} \\
\mbox{(assumption and \ldots)} & \Rightarrow & v'
\end{eqnarray*}

% TODO: M => v if P => v might not imply M => P, but we write it this way in our developments (when using IH and let-evaluation rule)
% TODO: according to leroy, the lifting of x-variables disappears after a while. it is still there after IH on the first premise, but
%       no longer before applying lemma 4...
%       i think our proof still stands, except for the dots in the last step (there we need some substitution and lifting properties)


\end{description}


\bibliographystyle{plain}
\bibliography{bachelor-project}


\end{document}
