\documentclass[a4paper,11pt]{article}
\usepackage[english]{babel}
\usepackage{a4}
\usepackage{amssymb}


\newtheorem{lemma}{Lemma}


\title{Verifying a CPS Transformation (draft)}

\author{Martijn Vermaat\footnote{E-mail: \texttt{mvermaat@cs.vu.nl},
    homepage: \texttt{http://www.cs.vu.nl/\~{}mvermaat/}}}
\date{\today}


\begin{document}

\maketitle


\begin{abstract}
  Abstract.
\end{abstract}


\section{Introduction}\label{sec:introduction}


\section{Related Work}\label{sec:related}


\section{Languages}\label{sec:languages}

Terms $M$ in the source language are defined by the BNF grammar
\begin{eqnarray*}
M & ::= & x_{n} \\
  &   | & \lambda^{n}.M \\
  &   | & M(M, \ldots, M) \\
  &   | & \texttt{let} \: M \: \texttt{in} \: M
\end{eqnarray*}
where $n$ ranges over the natural numbers.
We will use $M, M_{n}, N, N_{n}, Q$ for terms in the source language.


Terms $M'$ in the target language are defined by the BNF grammar
\begin{eqnarray*}
M' & ::= & x_{n} \\
   &   | & \kappa_{n} \\
   &   | & \lambda^{n}.M' \\
   &   | & M'(M', \ldots, M') \\
   &   | & \texttt{let} \: M' \: \texttt{in} \: M'
\end{eqnarray*}
where $n$ ranges over the natural numbers.
We will use $K, K_{n}, P, P_{n}$ for terms in the target language.


\section{Proof}\label{sec:proof}

\begin{lemma}
  Let $K = \lambda^{0}.P$ be a $\kappa$-closed, one-argument
  abstraction of the target language. If $M \Rightarrow v$ in the
  source language, and $P\{\Psi(v)\}\{\} \Rightarrow v'$ in the target
  language, then $[\![M]\!](K) \Rightarrow v'$ in the target language.
\end{lemma}

\paragraph{Proof}

We assume $M \Rightarrow v$ and proceed by induction on its derivation, also
assuming $P\{\Psi(v)\}\{\} \Rightarrow v'$.

% TODO: check all reductions and add relevant properties (k-closedness
% of certain terms)
% TODO: make distinction clear between evaluation in source and target
% languages
% TODO: do lifting of x variables

\begin{itemize}
\item{Case $M = \lambda^{n}.M_{1}$}

  This is the base case, where $v = \lambda^{n}.M_{1}$.

  We need to show $(\lambda^{0}.\kappa_{0}(\Psi(\lambda^{n}.M_{1}))) (K)
  \Rightarrow v'$.

  This is trivial, because according to the evaluation rule for
  function application we have
  \begin{eqnarray*}
   &             & (\lambda^{0}.\kappa_{0}(\Psi(\lambda^{n}.M_{1}))) (K) \\
   & \Rightarrow & K (\Psi(\lambda^{n}.M_{1})) \\
   & \Rightarrow & P\{\Psi(\lambda^{n}.M_{1})\}\{\}
  \end{eqnarray*}

\item{Case $M = M_{1}(N_{0}, \ldots, N_{n})$}

Premises of the evaluation rule for function application are
$M_{1} \Rightarrow \lambda^{n}.Q$, $N_{i} \Rightarrow v_{i}$,
and $Q\{v_{n}, \ldots, v_{0}\} \Rightarrow v$.

We need to show $[\![M_{1}(N_{0}, \ldots, N_{n})]\!](\lambda^{0}.P) \Rightarrow v'$.

Working out the transformation $[\![\cdot]\!]$ and function application,
we get
\begin{eqnarray*}
&   & [\![M_{1}(N_{0}, \ldots, N_{n})]\!] (\lambda^{0}.P) \\
& = & (\lambda^{0}.[\![M_{1}.N_{0} \ldots N_{n} \: \texttt{then} \: \kappa_{n+1}(\kappa_{n+2}, \kappa_{n}, \ldots, \kappa_{0})]\!]) (\lambda^{0}.P) \\
& = & (\lambda^{0}.[\![M_{1}]\!](\lambda^{0}.[\![N_{0}]\!](\lambda^{0}. \cdots [\![N_{n}]\!](\lambda^{0}.\kappa_{n+1}(\kappa_{n+2}, \kappa_{n}, \ldots, \kappa_{0})) \cdots ))) (\lambda^{0}.P) \\
& \Rightarrow & [\![M_{1}]\!](\lambda^{0}.[\![N_{0}]\!](\lambda^{0}. \cdots [\![N_{n}]\!](\lambda^{0}.\kappa_{n+1}((\lambda^{0}.P), \kappa_{n}, \ldots, \kappa_{0})) \cdots ))
\end{eqnarray*}

Let $P_{1} = [\![N_{0}]\!](\lambda^{0}. \cdots [\![N_{n}]\!](\lambda^{0}.\kappa_{n+1}((\lambda^{0}.P), \kappa_{n}, \ldots, \kappa_{0})) \cdots )$ and $K_{1} = \lambda^{0}.P_{1}$ which is $\kappa$-closed ($[\![N_{i}]\!]$ is $\kappa$-closed by lemma 3).

Applying the induction hypothesis to our first premise, we know that $[\![M_{1}]\!](K_{1}) \Rightarrow v'$ if $P_{1}\{\Psi(\lambda^{n}.Q)\}\{\} \Rightarrow v'$.

We have
\begin{eqnarray*}
&   & P_{1}\{\Psi(\lambda^{n}.Q)\}\{\} \\
& = & [\![N_{0}]\!](\lambda^{0}. \cdots [\![N_{n}]\!](\lambda^{0}.\Psi(\lambda^{n}.Q)((\lambda^{0}.P), \kappa_{n}, \ldots, \kappa_{0})) \cdots )
\end{eqnarray*}
and repeatedly applying the induction hypothesis to the premises $N_{i} \Rightarrow v_{i}$ leaves us to show
\begin{displaymath}
[\![Q\{v_{n}, \ldots, v_{0}\}]\!] (\lambda^{0}.P) \Rightarrow v'
\end{displaymath}

This follows from the induction hypothesis applied to the last premise
$Q\{v_{n}, \ldots, v_{0}\} \Rightarrow v$ and the assumption $P\{\Psi(v)\}\{\}
\Rightarrow v'$.

\item{Case $M = \texttt{let} \: M_{1} \: \texttt{in} \: M_{2}$}

The evaluation rule for $\texttt{let}$ gives us premises $M_{1} \Rightarrow v_{1}$ and $M_{2}\{v_{1}\} \Rightarrow v$.

We need to show
$[\![\texttt{let} \: M_{1} \: \texttt{in} \: M_{2}]\!](\lambda^{0}.P) \Rightarrow v'$.

We have
\begin{eqnarray*}
 &   & [\![\texttt{let} \: M_{1} \: \texttt{in} \: M_{2}]\!](\lambda^{0}.P) \\
 & = & (\lambda^{0}.[\![M_{1}]\!](\lambda^{0}. \: \texttt{let} \: \kappa_{0} \: \texttt{in} \: [\![M_{2}]\!](\kappa_{1})))(\lambda^{0}.P)
\end{eqnarray*}

By the evaluation rule for function application, this term evaluates to the same value as
\begin{displaymath}
[\![M_{1}]\!](\lambda^{0}. \: \texttt{let} \: \kappa_{0} \: \texttt{in} \: [\![M_{2}]\!](\Uparrow_{x}^{1} \lambda^{0}.P))
\end{displaymath}

We apply the induction hypothesis to the first premise (knowing that $\lambda^{0}. \: \texttt{let} \: \kappa_{0} \: \texttt{in} \: [\![M_{2}]\!](\Uparrow_{x}^{1} \lambda^{0}.P)$
is $\kappa$-closed) and the term evaluates to the same value as
\begin{eqnarray*}
 &   & (\texttt{let} \: \kappa_{0} \: \texttt{in} \: [\![M_{2}]\!](\Uparrow_{x}^{1} \lambda^{0}.P))\{\Psi(v_{1})\}\{\} \\
 & = & \texttt{let} \: \Psi(v_{1}) \: \texttt{in} \: [\![M_{2}]\!](\Uparrow_{x}^{1} \lambda^{0}.P)
\end{eqnarray*}

By the $\texttt{let}$-evaluation rule, this term evaluates as
\begin{eqnarray*}
                 &   & ([\![M_{2}]\!](\Uparrow_{x}^{1} \lambda^{0}.P))\{\}\{\Psi(v_{1})\} \\
                 & = & [\![M_{2}]\!]\{\}\{\Psi(v_{1})\}(\Uparrow_{x}^{1} \lambda^{0}.P) \\
\mbox{(lemma 4)} & = & [\![M_{2}\{v_{1}\}]\!](\Uparrow_{x}^{1} \lambda^{0}.P)
\end{eqnarray*}

Applying the induction hypothesis to the second premise (again, $\Uparrow_{x}^{1} \lambda^{0}.P$ is $\kappa$-closed)
completes our argument:
\begin{eqnarray*}
                               &             & (\Uparrow_{x}^{1}P)\{\Psi(v)\}\{\} \\
\mbox{(assumption and \ldots)} & \Rightarrow & v'
\end{eqnarray*}

% TODO: M => v if P => v might not imply M => P, but we write it this way in our developments (when using IH and let-evaluation rule)
% TODO: according to leroy, the lifting of x-variables disappears after a while. it is still there after IH on the first premise, but
%       no longer before applying lemma 4...
%       i think our proof still stands, except for the dots in the last step (there we need some substitution and lifting properties)


\end{itemize}


\section{Discussion}\label{sec:discussion}


\begin{thebibliography}{99}

\bibitem{Berg89}J. A. Bergstra, J. Heering, and P. Klint, editors. \emph{Algebraic
Specification}. ACM Press Frontier Series. The ACM Press in co-operation with Addison-Wesley,
1989.

\bibitem{Brab02}C. Brabrand and M. I. Schwartzbach. Growing languages with metamorphix
syntax macros. In \emph{PEPM'02}, 2002.

\bibitem{Brand00}M. G. J. van den Brand, H. de Jong, P. Klint, and P. Olivier. Efficient
annotated terms. \emph{Software, Practice \& Experience}, 30(3):259-291, 2000.

\bibitem{Brand02}M. G. J. van den Brand, J. Scheerder, J. Vinju, and E. Visser.
Disambiguation filters for scannerless generalized LR parsers. In N. Horspool, editor,
\emph{Compiler Construction (CC'02)}, volume 2304 of \emph{Lecture Notes in Computer
Science}, pages 143-158, Grenoble, France, April 2002. Springer-Verlag.

\bibitem{Brav04}M. Bravenboer, E. Visser. Concrete Syntax for Objects.
Domain-Specific Language Embedding and Assimilation without Restrictions. In Douglas
C. Schmidt (ed.) \emph{Proceedings of the 19th ACM SIGPLAN conference on
Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA'04).}
Vancouver, Canada. October 2004.

\bibitem{Card94}L. Cardelli, F. Matthes, and M. Abadi. Extensible syntax with lexical
scoping. SRC Research Report 121, Digital Systems Research Center, Palo Alto,
California, Februari 1994.

\bibitem{Deur96}A. van Deursen, J. Heering, and P. Klint, editors. \emph{Language Prototyping.
An Algebraic Specification Approach}, volume 5 of \emph{AMAST Series in Computing} World
Scientific, Singapore, September 1996.

\bibitem{Leav66}B. M. Leavenworth. Syntax macros and extended translation. \emph{Communications
of the ACM}, 9(11):790-793, November 1966.

\bibitem{Sha96}A. Shalit. \emph{The Dylan reference manual: the definitive guide
to the new object-oriented dynamic language}. Addison Wesley Longman Publishing
Co., Inc., 1996.

\bibitem{Visser97}E. Visser. Scannerless generalized-LR parsing.
Technical Report P9707, Programming Research Group, University of Amsterdam, July 1997.

\bibitem{Visser97b}E. Visser. \emph{Syntax Definition for Language Prototyping.} PhD
thesis, University of Amsterdam, September 1997.

\bibitem{Vis02}E. Visser. Meta-programming with concrete object syntax. In D. Batory,
C. Consel, and W. Taha, editors, \emph{Generative Programming and Component Engineering
(GPCE'02)}, volume 2487 of \emph{Lecture Notes in Computer Science}, pages 299-315, Pittsburgh,
PA, USA, October 2002. Springer-Verlag.

\bibitem{Weis93}D. Weise and R. F. Crew. Programmable syntax macros. In \emph{Proceedings
of the ACM SIGPLAN '93 Conference on Programming Language Design and Implementation
(PLDI'93)}, Albuquerque, New Mexico, June 1993.

\end{thebibliography}


\end{document}
