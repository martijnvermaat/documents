\documentclass[a4paper,11pt]{article}
\usepackage[english]{babel}
\usepackage{a4}
%\usepackage{a4,fullpage}
%\usepackage{amsmath,amsfonts,amssymb}
%\usepackage{fancyhdr}
\usepackage{listings}


% Use sans serif font for body text
%\renewcommand{\familydefault}{\sfdefault}

\pagestyle{headings}


%\title{Concrete Syntax for Object Languages}
\title{Concrete Syntax for Meta-Programming}

\author{Martijn Vermaat\\
\texttt{mvermaat@cs.vu.nl}}
\date{\today}

\makeindex


\begin{document}

\maketitle


\lstset{
  numbers=none,
  basicstyle=\footnotesize\ttfamily,
  frame=tb,
  language=Pascal,
  captionpos=b,
  xleftmargin=1em,
  xrightmargin=1em,
  aboveskip=1em,
  belowskip=1em
}


\begin{abstract}
Discussed is a general method for embedding concrete object syntax in
meta-programming (and library interfacing).

Todo: discuss concrete syntax in meta-programming only, or the more
general case of concrete syntax for objects? (the former)
\end{abstract}


\section{Introduction}\label{sec:introduction}

Meta-programming is concerned with analysis, generation, and transformation
of object programs. In this setting, the meta-language provides constructs
to manipulate code fragments of the object language. Meta-languages employ
standard data structures for the representation of object programs. Typically,
these data structures are used to represent abstract syntax trees rather
than textual (concrete) syntax.

The use of abstract syntax enables meta-programming environments to make
guaranties about well-formedness and type-correctness of generated programs.
Furthermore, abstract syntax representations allow for high-level techniques
to be employed in analysis and composition of code fragments.

However, there are many domains of meta-programming where the conceptual gap
between the concrete syntax representation of object programs and the constructs
to manipulate the abstract syntax representation of these programs is greater
than one should desire.

The techniques we present allow meta-programming systems to use abstract
syntax representations of object code, while giving the meta-programmer the
possibility of specifying the same object code using the concrete syntax of
the object language. This entails a more natural way of meta-programming with
higher readability of meta-programs, while still having all the bennefits of
abstract syntax representations of object programs.

\paragraph{}

We proceed as follows. In section \ref{sec:motivation} we introduce and explain
the problem domain. In section \ref{sec:related} we give a brief overview of
previous and related work. We conclude in section x.


\section{Motivation}\label{sec:motivation}

Verhaaltje over meta-programming zelf. analyse, generating and transformation.

\paragraph{}

Systems for meta-programming use data structures for the representation of
object code fragments. One possible approach is to use the string type of the
meta-language for storing fragments of the object program in concrete syntax.
Composition of fragments is simply done by string concatenation, whereas
analysis and deconstruction of fragments is much harder.

A short characterization of the approach is the following. Specifying object
fragments is done in a natural way, using concrete syntax. Reading
meta-programs is easy because of this concrete syntax. Manipulating object
code can be much harder, because no structure is preserved. No guarantees
whatsoever can be made about the correctness of the generated code (i.e.
well-formedness, type-correctness).

\paragraph{}

Another approach is to use a datatype to store an abstract syntax representation
of the object program. The use of abstract syntax allows high-level data
manipulation techniques to be employed in the meta-language in order to
manipulate the object program. For example, object-oriented languages such
as Java provide methods to store abstract syntax trees as object hierarchies
and techniques to compose and decompose these hierarchies, while functional
programming languages support algebraic data types in combination with pattern
matching (e.g. Haskell, and the ML family of languages).

Compared to using strings of object code fragments, abstract syntax
representations allow the meta-programming system to make guaranties about the
well-formedness of generated object programs in addition to providing much more
powerfull techniques for further manipulation of these programs.

A negative aspect of this approach is that the meta-programmer has no natural
way of specifying object code. This has a negative effect on both the
construction and the readability of meta-programs. As an example, consider the
following arithmetic expression in an imaginary object language.
\begin{lstlisting}[title=Example expression in concrete syntax]
(1 + 7) * i - 1
\end{lstlisting}
A typical abstract syntax representation of this fragment in a meta-language
with algebraic data types can look like the following.
\begin{lstlisting}[title=Example expression in abstract syntax]
Sub(Mul(Add(IConst(1), IConst(7)), Id('i')), IConst(1))
\end{lstlisting}
It is clear that in this example the concrete syntax representation of the
object code is much easier to read than the abstract syntax representation in
the meta-language. Although it should be noted that in some cases the abstract
syntax representation can be more concise, in general it tends to become more
painful to manage abstract syntax as the size of object code fragments grows.

\paragraph{}

In this paper we present a method for the embedding of concrete syntax of
object languages in the syntax of meta-languages (thus thereby extending the
meta-language) and the assimilation of this embedded concrete syntax into the
meta-language. The embedding of an object language in a meta-language is done
by combining their syntax definitions. Assimilation of the embedded concrete
object code fragments is done by program transformation. Concrete object
syntax is transformed to the standard meta-language constructs for
constructing and manipulating abstract object syntax resulting in a pure
meta-program that can be compiled in the normal way.


\section{Related Work}\label{sec:related}

\subsection{User-definable Syntax}

User-definable syntax provides a way for the programmer to define certain
syntactical constructs in the language. A simple example of this are
user-definable infix operators as present in languages like Prolog and
Haskell. However, although sometimes very useful, this extending of syntax
is limited in its applications. More powerfull is the definition of syntax
in the algebraic specification formalism ASF+SDF in which the programmer
defines all syntactical constructs itself.

Experiments have been done with dynamically extending the syntax of a
language at parse-time by including declarations of syntax extensions in
the program itself. It is our opinion the this complicates the parsing
process too much while the bennefits of dynamic syntax extending within
a program file are not clear in meta-programming.


User-definable infix operators is sometimes seen as an example of this, but




\section{Realizing Concrete Syntax}

Combining syntax definitions, assimilation to the host language.
All the technical details.
Todo.


\section{Discussion}


\subsection{Background}

Modularity, Scannerless parsing.
SDF, ASF+SDF, StrategoXT.
Todo.


\subsection{Related Work}

Extensible syntax, syntax macros, embedding XML applications.
Todo.


\subsection{Future Work}

Todo.


\subsection{Conclusions}

Todo.


\begin{thebibliography}{99}

\bibitem{Visser97}E. Visser. Scannerless generalized-LR parsing.
Technical Report P9707, Programming Research Group, University of Amsterdam, July 1997.

\end{thebibliography}


\end{document}





% Meta-Programming with Concrete Object Syntax
%
% 1 Introduction
% 2 Abstract Syntax vs Concrete Syntax
%   2.1 Syntax Definition
%   2.2 Example: Instrumenting Programs
%   2.3 Concrete vs Abstract
% 3 Implementation
%   3.1 Extending the Meta-Language
%   3.2 Meta-Variables
%   3.3 Meta-Explode
% 4 Generalization
% 5 Discussion
%   5.1 Syntax Definition and Parsing
%   5.2 Desugaring Patterns
%   5.3 User-definable Syntax
%   5.4 Syntax Macros
% 6 Conclusions

% Concrete Syntax for Objects
%
% 1 Introduction
% 2 Concrete Syntax for Objects
%   2.1 Code Generation
%   2.2 XML Document Generation
%   2.3 Graphical User-Interface Construction
%   2.4 Other Applications
% 3 Realizing Concrete Syntax
%   3.1 Embedding and Assimilation
%   3.2 Java with Swul
%   3.3 Java with XML
%   3.4 Java with Java
% 4 Syntax Definition
%   4.1 SDF Overview
%   4.2 The Importance of Modularity
%   4.3 The Importance of Scannerless Parsing
% 5 Discussion
%   5.1 Previous Work
%   5.2 Related Work
%   5.3 Future Work
% 6 Conclusions
