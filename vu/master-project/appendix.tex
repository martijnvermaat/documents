\chapter{Two Syntactical Criteria in \Coq}\label{chap:appendix}

We include a short discussion of two \Coq technicalities.


\section{Guardedness}\label{sub:guardedness}

% TODO: cite coquand, gimenez

Objects in a coinductive type may be infinite (i.e.\ contain an infinite
amount of constructors). However, in order to guarantee productivity,
definitions of such objects are required by \Coq to be in \emph{guarded}
form \citep{gimenez-94}. A corecursive definition in guarded form
satisfies two (syntactical) conditions. First, every corecursive call
must occur inside at least one constructor (of the same coinductive
type). Second, every corecursive call may only occur inside
abstractions or constructors (of the same coinductive
type).\footnote{To be more precise, the corecursive call is also
  allowed to occur inside \coqdockw{match} constructs and other
  corecursive definitions.}

In the \coqref{Term.term}{\coqdocinductive{term}} definition, we use a vector
type, parameterised by the type of its element and its size. Naturally, one
would implement a vector type in \Coq inductively, as for example has been
done in the standard library.
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Inductive} \coqdef{Bvector.vector}{vector}{\coqdocinductive{vector}}
(\coqdocvar{A} : \coqdockw{Type}) :
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}}
\ensuremath{\rightarrow} \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{Bvector.Vnil}{Vnil}{\coqdocconstructor{Vnil}}  :
\coqref{Bvector.vector}{\coqdocinductive{vector}} \coqdocvariable{A} 0\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{Bvector.Vcons}{Vcons}{\coqdocconstructor{Vcons}} :
\coqdocvariable{A} \ensuremath{\rightarrow} \ensuremath{\forall} \coqdocvar{n},
\coqref{Bvector.vector}{\coqdocinductive{vector}} \coqdocvariable{A}
\coqdocvariable{n} \ensuremath{\rightarrow}
\coqref{Bvector.vector}{\coqdocinductive{vector}} \coqdocvariable{A}
(\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{S}{\coqdocconstructor{S}}
\coqdocvariable{n}).\coqdoceol
\end{coqdoccode}
\end{singlespace}

Now consider the following trivial example of a basic operation on terms by
corecursive traversal.
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{CoFixpoint} \coqdef{Term.id}{id}{\coqdocdefinition{id}}
(\coqdocvar{t} : \coqref{Term.term}{\coqdocinductive{term}}) :
\coqref{Term.term}{\coqdocinductive{term}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{t} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{Term.Var}{\coqdocconstructor{Var}} \coqdocvar{x}
\ensuremath{\Rightarrow} \coqref{Term.Var}{\coqdocconstructor{Var}}
\coqdocvariable{x}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{Term.Fun}{\coqdocconstructor{Fun}} \coqdocvar{f}
\coqdocvar{args} \ensuremath{\Rightarrow}
\coqref{Term.Fun}{\coqdocconstructor{Fun}} \coqdocvariable{f}
(\coqdocdefinition{vmap} \coqref{Term.id}{\coqdocdefinition{id}}
\coqdocvariable{args})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\end{coqdoccode}
\end{singlespace}
This definition is ill-formed, since the corecursive call to
\coqref{Term.id}{\coqdocdefinition{id}} is not guarded.\footnote{The call to
  \coqref{Term.id}{\coqdocdefinition{id}} is hidden inside
  \coqdocdefinition{vmap}, which is defined by recursion on the vector
  \coqdocvariable{args}.}
We define a recursive type of vectors as an alternative to the inductive type:
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Inductive} \coqdef{Vector.Fin}{Fin}{\coqdocinductive{Fin}} :
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}}
\ensuremath{\rightarrow} \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{Vector.First}{First}{\coqdocconstructor{First}} :
\ensuremath{\forall} \coqdocvar{n}, \coqref{Vector.Fin}{\coqdocinductive{Fin}}
(\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{S}{\coqdocconstructor{S}}
\coqdocvariable{n})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{Vector.Next}{Next}{\coqdocconstructor{Next}}  :
\ensuremath{\forall} \coqdocvar{n}, \coqref{Vector.Fin}{\coqdocinductive{Fin}}
\coqdocvariable{n} \ensuremath{\rightarrow}
\coqref{Vector.Fin}{\coqdocinductive{Fin}}
(\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{S}{\coqdocconstructor{S}}
\coqdocvariable{n}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition}
\coqdef{Vector.vector}{vector}{\coqdocdefinition{vector}} (\coqdocvar{A} :
\coqdockw{Type}) (\coqdocvar{n} :
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}})
:= \coqref{Vector.Fin}{\coqdocinductive{Fin}} \coqdocvariable{n}
\ensuremath{\rightarrow} \coqdocvariable{A}.\coqdoceol
\end{coqdoccode}
\end{singlespace}
% TODO: explain this vector type
This makes for a definition of \coqref{Vector.vmap}{\coqdocdefinition{vmap}}
that is just an abstraction, and therefore solves the guardedness problem in
\coqref{Term.id}{\coqdocdefinition{id}}.
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Definition} \coqdef{Vector.vmap}{vmap}{\coqdocdefinition{vmap}}
\coqdocvar{A} \coqdocvar{B} (\coqdocvar{f} :
\coqdocvariable{A} \ensuremath{\rightarrow} \coqdocvariable{B}) \coqdocvar{n}
: \coqref{Vector.vector}{\coqdocdefinition{vector}} \coqdocvariable{A}
\coqdocvariable{n} \ensuremath{\rightarrow}
\coqref{Vector.vector}{\coqdocdefinition{vector}} \coqdocvariable{B}
\coqdocvariable{n} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{fun} \coqdocvar{v} \coqdocvar{i} \ensuremath{\Rightarrow}
\coqdocvariable{f} (\coqdocvariable{v} \coqdocvariable{i}).\coqdoceol
\end{coqdoccode}
\end{singlespace}


\section{The Positivity Condition}\label{sub:positivity}

\Coq restricts inductive definitions to those that satisfy the
\emph{positivity condition}. The reason for this is that definitions
that fail this (syntactic) criterion may lead to an inconsistent
  system. For a precise definition of positivity, consult
  \citetalias[Section 4.5.3]{coq-refman-09}.

Consider again the definition of rewrite sequences from
Section~\ref{sec:seq}. A more natural way to define the type of the
\coqref{Rewriting.Lim}{\coqdocconstructor{Lim}} constructor might be
by using a $\Sigma$-type instead of a separate function for the target
terms of the branches.
\begin{singlespace}
\begin{coqdoccode}
\coqdocindent{1.00em}
\ensuremath{|} \coqdocconstructor{Lim} :
\ensuremath{\forall} \coqdocvar{s} \coqdocvar{t}
(\coqdocvar{f} :
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}}
\ensuremath{\rightarrow} \{ \coqdocvar{t'} : \coqref{Term.term}{\coqdocinductive{term}}
\& \coqdocvar{s}
\coqref{Rewriting.sequence}{$\rewrites_\mathcal{R}$}
\coqdocvariable{t'} \}),\coqdoceol
\coqdocindent{5.00em}
\coqref{Rewriting.converges}{\coqdocdefinition{converges}}
(\coqdockw{fun} \coqdocvar{n} \ensuremath{\Rightarrow}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Specif}{projT1}{\coqdocdefinition{projT1}}
(\coqdocvariable{f} \coqdocvariable{n})) \coqdocvariable{t}
$\rightarrow$ (\coqdocvariable{s}
\coqref{Rewriting.sequence}{$\rewrites_\mathcal{R}$}
\coqdocvariable{t})\coqdoceol
\end{coqdoccode}
\end{singlespace}
However, this type definition does not satisfy the positivity
condition and therefore we cannot use it. We feel that the definition
from Section~\ref{sec:seq}, which does satisfy the condition, models
our intentions adequately.
