\chapter{A Mechanic Formalisation}\label{chap:implementation}

TODO: introduction.


\section{The \Coq Proof Assistant}

\Coq \citep{coq-refman-09} is based on the formal
language \emph{Calculus of Inductive Constructions}
\citep{coquand-huet-88,mohring-93}, which is essentially a typed
$\lambda$-calculus with inductive types. In this language, logical
propositions are represented as types and proofs of such propositions
are $\lambda$-terms, motivated by the Curry-Howard-de Bruijn
correspondence. The core of the \Coq system is its type checking
algorithm.

% TODO: also cite cpdt
We present a very short introduction to \Coq and refer to
\citet{bertot-casteran-04} and \citet{chlipala-09} for further
reading.


\subsection{Types and Propositions}

Every term in \Coq has a type and every type is also a
term. The type of a type is called a \emph{sort} and the sorts
in \Coq are
\begin{compactitem}
\item \coqdockw{Prop}, the sort of logical propositions,
\item \coqdockw{Set}, the sort of program specifications and datatypes,
\item \coqdockw{Type}$_0$, the sort of \coqdockw{Prop} and
  \coqdockw{Set}, and
\item \coqdockw{Type}$_{i+1}$, the sort of
  \coqdockw{Type}$_i$.\footnote{The subscripts $i$ of the sorts
    \coqdockw{Type}$_i$ are invisible to the user and only used
    internally.}
\end{compactitem}
For example,
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}}
is the datatype of the natural numbers. It lives in \coqdockw{Set} and
is defined by induction.
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Inductive} \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}}
:
\coqdockw{Set} :=\coqdoceol
\coqdocindent{1.0em}
\ensuremath{|} \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{O}{\coqdocconstructor{O}}
:
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}}\coqdoceol
\coqdocindent{1.0em}
\ensuremath{|} \coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{S}{\coqdocconstructor{S}}
:
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}} $\rightarrow$
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}}.\coqdoceol
\end{coqdoccode}
\end{singlespace}
The logical proposition that for every natural number $n$, there
exists a natural number $m$ larger than $n$, can be stated as a term
with sort \coqdockw{Prop}.
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
(\ensuremath{\forall} \coqdocvar{n} :
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}},
\ensuremath{\exists} \coqdocvar{m} :
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}},
\coqdocvariable{n} < \coqdocvariable{m}) : \coqdockw{Prop}\coqdoceol
\end{coqdoccode}
\end{singlespace}
Using the vocabulary of types and terms, the universal quantifier
$\forall$ is called the product type constructor. A product
type \begin{coqdoccode}$\forall$ \coqdocvar{x} : $T$,
  $U$\end{coqdoccode} is called dependent if \coqdocvar{x} occurs free
in $U$, otherwise it is written $T \rightarrow U$. The type of the
constructor symbol \coqdocconstructor{S} defined above, for example,
is that of functions from
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}}
to
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}}
and is not dependent.


\subsection{Terms and Proofs}

Proofs of logical propositions can be defined in two ways. First, we
can type a proof term directly. The only requirement is that this term
has as type the logical proposition that we want to prove. Second, we
can use \emph{tactics} to construct a proof term interactively.

As an example of the use of tactics, we prove the proposition from the
previous section. This is done by stating the proposition, after which
the system enters a goal-directed proof mode. In this mode, we are
presented with a goal, consisting of
\begin{inparaenum}[(i)]
\item a context of bound variables that are available
\item a proposition denoting what remains to be proven.
\end{inparaenum}
Tactics can now be applied to progressively transform the goal into a
simpler goal. When the goal is simple enough to be solved directly by
applying a tactic, we are done proving the proposition.
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma}
\coqdef{CoqIntro.ltserial}{lt\_serial}{\coqdoclemma{lt\_serial}} :
\ensuremath{\forall} \coqdocvar{n} :
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}},
\ensuremath{\exists} \coqdocvar{m} :
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}},
\coqdocvariable{n} < \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.0em}
\coqdoctac{intro} \coqdocvar{n}.\coqdoceol
\coqdocindent{1.0em}
\coqdoctac{exists}
(\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{S}{\coqdocconstructor{S}}
\coqdocvar{n}).\coqdoceol
\coqdocindent{1.0em}
\coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\end{coqdoccode}
\end{singlespace}
In this example, we use the tactic \coqdoctac{intro} to introduce the
variable \coqdocvariable{n} to the context. With \coqdoctac{exists},
we supply a witness for the existential quantification. At this point,
the goal is simple enough to be solved directly by the
\coqdoctac{auto} tactic.

Recursive functions are defined using the \coqdockw{Fixpoint}
keyword. The recursive call must have a structurally decreasing
argument of an inductive type. Consider the definition of the
factorial function for example, which also shows how a case analysis
on values of inductive types can be done with the \coqdockw{match}
keyword.
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Fixpoint}
\coqdef{CoqIntro.factorial}{factorial}{\coqdocdefinition{factorial}}
(\coqdocvar{n} :
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}})
:
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}}
:=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{n} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{O}{\coqdocconstructor{O}}
\ensuremath{\Rightarrow} 1\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{S}{\coqdocconstructor{S}}
\coqdocvar{n} \ensuremath{\Rightarrow}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{S}{\coqdocconstructor{S}}
\coqdocvariable{n} \ensuremath{\times}
(\coqref{CoqIntro.factorial}{\coqdocdefinition{factorial}}
\coqdocvariable{n})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\end{coqdoccode}
\end{singlespace}


\subsection{Reading the Code Fragments}

In the \Coq code fragments, we take some notational liberties in favor
of readability. Sometimes we omit (part of) the type information. We
also freely use infix notations without declaration. Furthermore,
variable and definition names are typeset liberaly.

Some definitions have implicit arguments, meaning those arguments can
be inferred by the system from the context. As an example, consider
the inductive type
\coqref{CoqIntro.natpos}{\coqdocinductive{nat$^+$}} whose constructor
takes as arguments a natural number \coqdocvar{n} and a proof that
\coqdocvar{n} is greater than $0$.
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Inductive}
\coqdef{CoqIntro.natpos}{nat\_pos}{\coqdocinductive{nat$^+$}} :
\coqdockw{Set} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{CoqIntro.Pos}{Pos}{\coqdocconstructor{Pos}} :
\ensuremath{\forall} \coqdocvar{n} :
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}},
0 < \coqdocvariable{n} \ensuremath{\rightarrow}
\coqref{CoqIntro.natpos}{\coqdocinductive{nat$^+$}}.\coqdoceol
\end{coqdoccode}
\end{singlespace}
The argument \coqdocvar{n} of
\coqref{CoqIntro.Pos}{\coqdocconstructor{Pos}} can be implicit,
since it can be inferred from (the type of) the other argument. If
\coqdocvar{H} has type \begin{coqdoccode}0 < 3\end{coqdoccode}, we can
write \begin{coqdoccode}\coqref{CoqIntro.Pos}{\coqdocconstructor{Pos}}
  \coqdocvariable{H}\end{coqdoccode} instead
of \begin{coqdoccode}\coqref{CoqIntro.Pos}{\coqdocconstructor{Pos}} 3
  \coqdocvariable{H}\end{coqdoccode}.

% TODO: more?


\section{Ordinal Numbers}

In the theory of infinitary rewriting, the lengths of rewrite sequences play
a central role. Therefore, any reasonable formalisation of infinitary
rewriting ought to have some notion of ordinal numbers.

We define the ordinal numbers using the representation of Brouwer
ordinals (cf.~Definition~\ref{def:ordinals}) in \Coq by
\coqref{Ordinal.ord}{\coqdocinductive{ord}}.
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Inductive} \coqdef{Ordinal.ord}{ord}{\coqdocinductive{ord}} :
\coqdockw{Set} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{Ordinal.Zero}{Zero}{\coqdocconstructor{Zero}}  :
\coqref{Ordinal.ord}{\coqdocinductive{ord}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{Ordinal.Succ}{Succ}{\coqdocconstructor{Succ}}  :
\coqref{Ordinal.ord}{\coqdocinductive{ord}} \ensuremath{\rightarrow}
\coqref{Ordinal.ord}{\coqdocinductive{ord}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{Ordinal.Limit}{Limit}{\coqdocconstructor{Limit}} :
(\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}}
\ensuremath{\rightarrow} \coqref{Ordinal.ord}{\coqdocinductive{ord}})
\ensuremath{\rightarrow}
\coqref{Ordinal.ord}{\coqdocinductive{ord}}.\coqdoceol
\end{coqdoccode}
\end{singlespace}
Arithmetic operations on ordinals, such as addition, are easily
defined.
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{Ordinal.add}{add}{$+$}
(\coqdocvar{$\alpha$} \coqdocvar{$\beta$} :
\coqref{Ordinal.ord}{\coqdocinductive{ord}}) :
\coqref{Ordinal.ord}{\coqdocinductive{ord}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{$\beta$} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{Ordinal.Zero}{\coqdocconstructor{Zero}}
\ensuremath{\Rightarrow} \coqdocvariable{$\alpha$}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{Ordinal.Succ}{\coqdocconstructor{Succ}}
\coqdocvar{$\beta$} \ensuremath{\Rightarrow}
\coqref{Ordinal.Succ}{\coqdocconstructor{Succ}}
(\coqdocvariable{$\alpha$} \coqref{Ordinal.add}{$+$}
\coqdocvariable{$\beta$})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{Ordinal.Limit}{\coqdocconstructor{Limit}}
\coqdocvar{f}   \ensuremath{\Rightarrow}
\coqref{Ordinal.Limit}{\coqdocconstructor{Limit}} (\coqdockw{fun}
\coqdocvar{n} \ensuremath{\Rightarrow}
\coqdocvariable{$\alpha$} \coqref{Ordinal.add}{$+$}
(\coqdocvariable{f} \coqdocvariable{n}))\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\end{coqdoccode}
\end{singlespace}
In fact, all definitions from Section~\ref{sub:brouwer} translate directly to
\Coq code. We can now prove basic properties of $\preceq$, for example
that it is transitive.
% TODO: maybe add another example
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma}
\coqdef{Ordinal.ordletrans}{ord\_le\_trans}{\coqdoclemma{\ensuremath{\preceq_{\text{trans}}}}}
:
\ensuremath{\forall} \coqdocvar{\ensuremath{\alpha}}
\coqdocvar{\ensuremath{\beta}}
\coqdocvar{\ensuremath{\gamma}}, \coqdocvariable{\ensuremath{\alpha}}
\ensuremath{\preceq} \coqdocvariable{\ensuremath{\beta}}
\ensuremath{\rightarrow}
\coqdocvariable{\ensuremath{\beta}} \ensuremath{\preceq}
\coqdocvariable{\ensuremath{\gamma}}
\ensuremath{\rightarrow} \coqdocvariable{\ensuremath{\alpha}}
\ensuremath{\preceq}
\coqdocvariable{\ensuremath{\gamma}}.\coqdoceol
\end{coqdoccode}
\end{singlespace}

Recalling our discussion in Section~\ref{sub:brouwer} of limit ordinals whose
sequences do not actually approximate to a limit ordinal, we consider the
lemma
\coqref{Ordinal.ordlezeroright}{\coqdoclemma{\ensuremath{\preceq_{\text{zero\_right}}}}}
as an example of this issue.
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma}
\coqdef{Ordinal.ordlezeroright}{ord\_le\_zero\_right}{\coqdoclemma{\ensuremath{\preceq_{\text{zero\_right}}}}}
:
\ensuremath{\forall} \coqdocvar{\ensuremath{\alpha}} \coqdocvar{\ensuremath{\beta}},
\coqdocvariable{\ensuremath{\alpha}} \ensuremath{\preceq}
\coqref{Ordinal.Zero}{\coqdocconstructor{Zero}}
\ensuremath{\rightarrow}
\coqdocvariable{\ensuremath{\alpha}} \ensuremath{\preceq}
\coqdocvariable{\ensuremath{\beta}}.\coqdoceol
\end{coqdoccode}
\end{singlespace}
We would like to strengthen this, but cannot, since nothing denies
\coqdocvariable{$\alpha$} from being the Brouwer ordinal $\sqcup \{ 0, 0, 0,
\ldots \}$ (which has the same rank as $0$). We therefore turn to a subset of
the Brouwer ordinals where we restrict limit sequences to be strictly
monotonic. This restriction is encoded in the
\coqref{WfOrdinal.wf}{\coqdocdefinition{wf}} (well-formedness)
property. The $\Sigma$-type
\coqref{WfOrdinal.wford}{\coqdocdefinition{ord$^\text{wf}$}} defines
the resulting subset.
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{WfOrdinal.wf}{wf}{\coqdocdefinition{wf}}
\coqdocvar{\ensuremath{\alpha}} : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{\ensuremath{\alpha}} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{Ordinal.Zero}{\coqdocconstructor{Zero}}
\ensuremath{\Rightarrow}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Logic}{True}{\coqdocinductive{True}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{Ordinal.Succ}{\coqdocconstructor{Succ}}
\coqdocvar{\ensuremath{\beta}} \ensuremath{\Rightarrow}
\coqref{WfOrdinal.wf}{\coqdocdefinition{wf}} \coqdocvariable{\ensuremath{\beta}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{Ordinal.Limit}{\coqdocconstructor{Limit}} \coqdocvar{f}
\ensuremath{\Rightarrow} \ensuremath{\forall} \coqdocvar{n},
\coqref{WfOrdinal.wf}{\coqdocdefinition{wf}} (\coqdocvariable{f}
\coqdocvariable{n}) \ensuremath{\land} \ensuremath{\forall} \coqdocvar{m},
\coqdocvariable{n} < \coqdocvariable{m} \ensuremath{\rightarrow}
\coqdocvariable{f} \coqdocvariable{n} \ensuremath{\prec}
\coqdocvariable{f} \coqdocvariable{m}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition}
\coqdef{WfOrdinal.wford}{wf\_ord}{\coqdocdefinition{ord$^\text{wf}$}} : \coqdockw{Set}
:=
%\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Specif}{sig}{\coqdocinductive{sig}}
%\coqref{WfOrdinal.wf}{\coqdocdefinition{wf}}.\coqdoceol
\{ \coqdocvariable{$\alpha$} :
\coqref{Ordinal.ord}{\coqdocinductive{ord}} \ensuremath{|}
\coqref{WfOrdinal.wf}{\coqdocdefinition{wf}} \coqdocvariable{$\alpha$}
\}.\coqdoceol
\end{coqdoccode}
\end{singlespace}
Now we can prove the stronger result we were looking for.\footnote{Although
  \coqdocvariable{\ensuremath{\alpha}} has type
  \coqref{WfOrdinal.wford}{\coqdocdefinition{ord$^\text{wf}$}} and $\preceq$
  has type \coqref{Ordinal.ord}{\coqdocinductive{ord}} $\rightarrow$
  \coqref{Ordinal.ord}{\coqdocinductive{ord}} $\rightarrow$ \coqdockw{Prop},
  we can state the lemma in this concise way by defining a simple coercion
  from \coqref{WfOrdinal.wford}{\coqdocdefinition{ord$^\text{wf}$}} to
  \coqref{Ordinal.ord}{\coqdocinductive{ord}} (first $\Sigma$-type
  projection).}
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma}
\coqdef{WfOrdinal.wfordlezeroright}{wf\_ord\_le\_zero\_right}{\coqdoclemma{\ensuremath{\preceq^{\text{wf}}_{\text{zero\_right}}}}}
:
\ensuremath{\forall} \coqdocvar{\ensuremath{\alpha}} :
\coqref{WfOrdinal.wford}{\coqdocdefinition{ord$^\text{wf}$}},
\coqdocvariable{\ensuremath{\alpha}} \ensuremath{\preceq}
\coqref{Ordinal.Zero}{\coqdocconstructor{Zero}}
\ensuremath{\rightarrow}
\coqdocvariable{\ensuremath{\alpha}} =
\coqref{Ordinal.Zero}{\coqdocconstructor{Zero}}.\coqdoceol
\end{coqdoccode}
\end{singlespace}


\section{Coinductive Terms}

In \Coq, coinductive types can be defined using the
\coqdockw{CoInductive} keyword \citep{gimenez-casteran-07}. No
induction principles are defined for these types, because they are not
well-founded.\footnote{\Coq automatically derives induction principles
  for inductive definitions.}
The objects of a coinductive type may contain an infinite number of
constructors, but can only be built in some restricted way to ensure
productivity of the construction.
% TODO: productivity or effectiveness?
We defer discussion of this restriction to
Section~\ref{sub:guardedness}, and define the type
\coqref{Term.term}{\coqdocinductive{term}} of infinite terms with
function symbols in \coqdocvar{F} and variables in \coqdocvar{X}.
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{CoInductive} \coqdef{Term.term}{term}{\coqdocinductive{term}} :
\coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{Term.Var}{Var}{\coqdocconstructor{Var}} : \coqdocvar{X}
\ensuremath{\rightarrow} \coqref{Term.term}{\coqdocinductive{term}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{Term.Fun}{Fun}{\coqdocconstructor{Fun}} :
\ensuremath{\forall} \coqdocvar{f} : \coqdocvar{F},
\coqref{Vector.vector}{\coqdocdefinition{vector}}
\coqref{Term.term}{\coqdocinductive{term}}
(\coqdocprojection{arity} \coqdocvariable{f})
\ensuremath{\rightarrow} \coqref{Term.term}{\coqdocinductive{term}}.\coqdoceol
\end{coqdoccode}
\end{singlespace}
Here, \coqref{Vector.vector}{\coqdocdefinition{vector}} is assumed to
implement dependently typed lists (the type depending on their length).

The standard Leibniz equality defined in \Coq, written $=$, does not suffice
for establishing that two terms are equal, given that the only way to build
infinite objects is by corecursion. Because the amount of memory available is
finite, we can only unfold the corecursive definition finitely many times, and
then still be left with a corecursive definition. Simply comparing such
definitions will not do, since the corecursive construction of any given
infinite object is not unique. To this end, we define two extensional
equalities on \coqref{Term.term}{\coqdocinductive{term}}, following
Definitions~\ref{def:bisimilarity} and \ref{def:equiv}. The coinductive
predicate \coqref{TermEquality.termbis}{$\bis$} defines bisimilarity and
pointwise equality is defined by \coqref{TermEquality.termeq}{$\equiv$}
inductively.
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{CoInductive}
\coqdef{TermEquality.termbis}{term\_bis}{$\bis$} :
\coqref{Term.term}{\coqdocinductive{term}} \ensuremath{\rightarrow}
\coqref{Term.term}{\coqdocinductive{term}} \ensuremath{\rightarrow}
\coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|}
\coqdef{TermEquality.Varbis}{Var\_bis}{\coqdocconstructor{$\biss{\text{Var}}$}} :
\ensuremath{\forall} \coqdocvar{x},
\coqref{Term.Var}{\coqdocconstructor{Var}} \coqdocvariable{x}
\coqref{TermEquality.termbis}{$\bis$}
\coqref{Term.Var}{\coqdocconstructor{Var}} \coqdocvariable{x}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|}
\coqdef{TermEquality.Funbis}{Fun\_bis}{\coqdocconstructor{$\biss{\text{Fun}}$}} :
\ensuremath{\forall} \coqdocvar{f} \coqdocvar{v} \coqdocvar{w},
(\ensuremath{\forall} \coqdocvar{i},
\coqdocvariable{v} \coqdocvariable{i}
\coqref{TermEquality.termbis}{$\bis$}
\coqdocvariable{w} \coqdocvariable{i})
\ensuremath{\rightarrow}
\coqref{Term.Fun}{\coqdocconstructor{Fun}} \coqdocvariable{f}
\coqdocvariable{v}
\coqref{TermEquality.termbis}{$\bis$}
\coqref{Term.Fun}{\coqdocconstructor{Fun}} \coqdocvariable{f}
\coqdocvariable{w}.\coqdoceol
\end{coqdoccode}
\end{singlespace}
Any proof of two infinite terms being bisimilar is an infinite proof, in the
sense that the proof term is built by corecursion.
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Inductive}
\coqdef{TermEquality.termequpto}{term\_eq\_up\_to}{\equpto{}}
:
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}}
\ensuremath{\rightarrow} \coqref{Term.term}{\coqdocinductive{term}}
\ensuremath{\rightarrow} \coqref{Term.term}{\coqdocinductive{term}}
\ensuremath{\rightarrow} \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|}
\coqdef{TermEquality.teut0}{teut\_0}{\coqdocconstructor{teut$_0$}}   :
\ensuremath{\forall} \coqdocvar{s} \coqdocvar{t},
\coqdocvariable{s} \coqref{TermEquality.termequpto}{\equpto{0}}
\coqdocvariable{t}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|}
\coqdef{TermEquality.teutvar}{teut\_var}{\coqdocconstructor{teut$_\text{Var}$}} :
\ensuremath{\forall} \coqdocvar{d} \coqdocvar{x},
\coqref{Term.Var}{\coqdocconstructor{Var}} \coqdocvariable{x}
\coqref{TermEquality.termequpto}{\equpto{\coqdocvariable{d}}}
\coqref{Term.Var}{\coqdocconstructor{Var}} \coqdocvariable{x}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|}
\coqdef{TermEquality.teutfun}{teut\_fun}{\coqdocconstructor{teut$_\text{Fun}$}} :
\ensuremath{\forall} \coqdocvar{d} \coqdocvar{f} \coqdocvar{v}
\coqdocvar{w},
(\ensuremath{\forall} \coqdocvar{i},
\coqdocvariable{v} \coqdocvariable{i}
\coqref{TermEquality.termequpto}{\equpto{\coqdocvariable{d}}}
\coqdocvariable{w} \coqdocvariable{i}) \ensuremath{\rightarrow}
\coqref{Term.Fun}{\coqdocconstructor{Fun}}
\coqdocvariable{f} \coqdocvariable{v}
\coqref{TermEquality.termequpto}{\equpto{\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{S}{\coqdocconstructor{S}}
    \, \coqdocvariable{d}}}
\coqref{Term.Fun}{\coqdocconstructor{Fun}} \coqdocvariable{f}
\coqdocvariable{w}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition}
\coqdocvar{s}
\coqdef{TermEquality.termeq}{term\_eq}{$\equiv$}
\coqdocvar{t} :=
\ensuremath{\forall} \coqdocvar{d},
\coqdocvariable{s}
\coqref{TermEquality.termequpto}{\equpto{\coqdocvariable{d}}}
\coqdocvariable{t}.\coqdoceol
\end{coqdoccode}
\end{singlespace}

We can prove that \coqref{TermEquality.termbis}{$\bis$} and
\coqref{TermEquality.termeq}{$\equiv$} are the same
relation, and that indeed it is an equivalence.
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma}
\coqdef{TermEquality.termbistermeq}{term\_bis\_term\_eq}{\coqdoclemma{term\_bis\_term\_eq}}
: \ensuremath{\forall} \coqdocvar{s} \coqdocvar{t},
\coqdocvariable{s}
\coqref{TermEquality.termbis}{$\bis$}
\coqdocvariable{t} \ensuremath{\leftrightarrow}
\coqdocvariable{s}
\coqref{TermEquality.termeq}{$\equiv$}
\coqdocvariable{t}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma}
\coqdef{TermEquality.termbisrefl}{term\_bis\_refl}{\coqdoclemma{$\biss{\text{refl}}$}}
: \ensuremath{\forall} \coqdocvar{t},
\coqdocvariable{t}
\coqref{TermEquality.termbis}{$\bis$}
\coqdocvariable{t}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma}
\coqdef{TermEquality.termbissymm}{term\_bis\_symm}{\coqdoclemma{$\biss{\text{symm}}$}}
: \ensuremath{\forall} \coqdocvar{s} \coqdocvar{t},
\coqdocvariable{s}
\coqref{TermEquality.termbis}{$\bis$}
\coqdocvariable{t} $\rightarrow$
\coqdocvariable{t}
\coqref{TermEquality.termbis}{$\bis$}
\coqdocvariable{s}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma}
\coqdef{TermEquality.termbistrans}{term\_bis\_trans}{\coqdoclemma{$\biss{\text{trans}}$}}
: \ensuremath{\forall} \coqdocvar{s} \coqdocvar{t} \coqdocvar{u},
\coqdocvariable{s}
\coqref{TermEquality.termbis}{$\bis$}
\coqdocvariable{t} $\rightarrow$
\coqdocvariable{t}
\coqref{TermEquality.termbis}{$\bis$}
\coqdocvariable{u} $\rightarrow$
\coqdocvariable{s}
\coqref{TermEquality.termbis}{$\bis$}
\coqdocvariable{u}.\coqdoceol
\end{coqdoccode}
\end{singlespace}

In Section~\ref{sec:seq} we need some notion of convergence for functions of
type
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}}
$\rightarrow$
\coqref{Term.term}{\coqdocinductive{term}}. We implement
Definition~\ref{def:cauchy} in \Coq for sequences of length $\omega$.
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Definition}
\coqdef{Rewriting.converges}{converges}{\coqdocdefinition{converges}}
(\coqdocvar{f} :
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}}
\ensuremath{\rightarrow} \coqref{Term.term}{\coqdocinductive{term}})
(\coqdocvar{t} : \coqref{Term.term}{\coqdocinductive{term}}) :
\coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{\forall} \coqdocvar{d}, \ensuremath{\exists} \coqdocvar{n},
\ensuremath{\forall} \coqdocvar{m},
\coqdocvariable{n} \ensuremath{\le} \coqdocvariable{m}
\ensuremath{\rightarrow}
\coqdocvariable{f} \coqdocvariable{m}
\coqref{TermEquality.termequpto}{\equpto{\coqdocvariable{d}}}
\coqdocvariable{t}.\coqdoceol
\end{coqdoccode}
\end{singlespace}
The definitions of finite term, rewrite rule, TRS and left-linearity
from Section~\ref{sub:trs} translate to \Coq directly. We define
\coqdef{Rewriting.lhs}{lhs}{\coqdocprojection{lhs}} and
\coqdef{Rewriting.rhs}{rhs}{\coqdocprojection{rhs}} to be first and
second projection on rewrite rules.

The type of contexts is inductively defined, where the hole always
occurs at a finite depth.
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Inductive}
\coqdef{Context.context}{context}{\coqdocinductive{context}} :
\coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} $\Box$ :
\coqref{Context.context}{\coqdocinductive{context}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{Context.CFun}{CFun}{\coqdocconstructor{CFun}} :
\ensuremath{\forall} (\coqdocvar{f} : \coqdocvar{F}) (\coqdocvar{i}
\coqdocvar{j} :
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}}),
\coqdocvariable{i} +
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{S}{\coqdocconstructor{S}}
\coqdocvariable{j} =
\coqdocprojection{arity} \coqdocvariable{f}
\ensuremath{\rightarrow}\coqdoceol
\coqdocindent{5.50em}
\coqref{Vector.vector}{\coqdocdefinition{vector}}
\coqref{Term.term}{\coqdocinductive{term}} \coqdocvariable{i}
\ensuremath{\rightarrow}
\coqref{Context.context}{\coqdocinductive{context}}
\ensuremath{\rightarrow}
\coqref{Vector.vector}{\coqdocdefinition{vector}}
\coqref{Term.term}{\coqdocinductive{term}} \coqdocvariable{j}
\ensuremath{\rightarrow}
\coqref{Context.context}{\coqdocinductive{context}}.\coqdoceol
\end{coqdoccode}
\end{singlespace}
Applying a substitution \coqdocvariable{$\sigma$} to a term
\coqdocvariable{t} is defined by corecursion over
\coqdocvariable{t}. We also use the
notation \begin{coqdoccode}\coqdocvariable{t}$^\coqdocvariable{$\sigma$}$\end{coqdoccode}
for \begin{coqdoccode}\coqref{Substitution.substitute}{\coqdocdefinition{substitute}}
  \coqdocvariable{$\sigma$} \coqdocvariable{t}\end{coqdoccode}.
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Definition}
\coqdef{Substitution.substitution}{substitution}{\coqdocdefinition{substitution}}
:= \coqdocvar{X} \ensuremath{\rightarrow}
\coqref{Term.term}{\coqdocinductive{term}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{CoFixpoint}
\coqdef{Substitution.substitute}{substitute}{\coqdocdefinition{substitute}}
(\coqdocvar{$\sigma$} :
\coqref{Substitution.substitution}{\coqdocdefinition{substitution}})
(\coqdocvar{t} :
\coqref{Term.term}{\coqdocinductive{term}}) :
\coqref{Term.term}{\coqdocinductive{term}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{t} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{Term.Var}{\coqdocconstructor{Var}}
\coqdocvar{x}      \ensuremath{\Rightarrow} \coqdocvariable{$\sigma$}
\coqdocvariable{x}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{Term.Fun}{\coqdocconstructor{Fun}}
\coqdocvar{f} \coqdocvar{args} \ensuremath{\Rightarrow}
\coqref{Term.Fun}{\coqdocconstructor{Fun}} \coqdocvariable{f}
(\coqref{Vector.vmap}{\coqdocdefinition{vmap}}
(\coqref{Substitution.substitute}{\coqdocdefinition{substitute}}
\coqdocvariable{$\sigma$}) \coqdocvariable{args})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\end{coqdoccode}
\end{singlespace}
We apply the recursive function
\coqdef{Context.fill}{fill}{\coqdocdefinition{fill}} (not shown here)
to a context \coqdocvariable{C} and a term \coqdocvariable{t}
(written \begin{coqdoccode}\coqdocvariable{C}[\coqdocvariable{t}]\end{coqdoccode})
to replace the hole in \coqdocvariable{C} with \coqdocvariable{t}.

Positions are represented by simple lists of natural numbers. This
means the subterm at some position in some term may not actually
exist. For this reason we employ
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{option}{\coqdocinductive{option}}
types in functions that do a lookup by position (functions in \Coq are
always \emph{total}).
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Fixpoint}
\coqdef{Term.subterm}{subterm}{\coqdocdefinition{subterm}}
(\coqdocvar{t} : \coqref{Term.term}{\coqdocinductive{term}})
(\coqdocvar{p} :
\coqdocabbreviation{position})
\{\coqdockw{struct} \coqdocvar{p}\} :
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{option}{\coqdocinductive{option}}
\coqref{Term.term}{\coqdocinductive{term}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{p} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nil}{\coqdocconstructor{nil}}
\ensuremath{\Rightarrow}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{Some}{\coqdocconstructor{Some}}
\coqdocvariable{t}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{n} :: \coqdocvar{p} \ensuremath{\Rightarrow}
\coqdockw{match} \coqdocvariable{t} \coqdockw{with}\coqdoceol
\coqdocindent{7.00em}
\ensuremath{|} \coqref{Term.Var}{\coqdocconstructor{Var}}
\coqdocvar{\_}      \ensuremath{\Rightarrow}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{None}{\coqdocconstructor{None}}\coqdoceol
\coqdocindent{7.00em}
\ensuremath{|} \coqref{Term.Fun}{\coqdocconstructor{Fun}}
\coqdocvar{f} \coqdocvar{args} \ensuremath{\Rightarrow}
\coqdockw{match}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Arith.Bool\_nat}{ltgedec}{\coqdocdefinition{lt\_ge\_dec}}
\coqdocvariable{n} (\coqdocprojection{arity}
\coqdocvariable{f}) \coqdockw{with}\coqdoceol
\coqdocindent{15.00em}
\ensuremath{|}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Specif}{left}{\coqdocconstructor{left}}
\coqdocvar{h}  \ensuremath{\Rightarrow}
\coqref{Term.subterm}{\coqdocdefinition{subterm}}
(\coqdocdefinition{vnth} \coqdocvariable{h}
\coqdocvariable{args}) \coqdocvariable{p}\coqdoceol
\coqdocindent{15.00em}
\ensuremath{|}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Specif}{right}{\coqdocconstructor{right}}
\coqdocvar{\_} \ensuremath{\Rightarrow}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{None}{\coqdocconstructor{None}}\coqdoceol
\coqdocindent{15.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{7.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{Context.dig}{dig}{\coqdocdefinition{dig}}
(\coqdocvar{t} : \coqref{Term.term}{\coqdocinductive{term}})
(\coqdocvar{p} :
\coqdocabbreviation{position})
\{\coqdockw{struct} \coqdocvar{p}\} :
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{option}{\coqdocinductive{option}}
\coqref{Context.context}{\coqdocinductive{context}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{p} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nil}{\coqdocconstructor{nil}}
\ensuremath{\Rightarrow}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{Some}{\coqdocconstructor{Some}}
$\Box$\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{n} :: \coqdocvar{p} \ensuremath{\Rightarrow}
\coqdockw{match} \coqdocvariable{t} \coqdockw{with}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{|} \coqref{Term.Var}{\coqdocconstructor{Var}}
\coqdocvar{\_}      \ensuremath{\Rightarrow}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{None}{\coqdocconstructor{None}}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{|} \coqref{Term.Fun}{\coqdocconstructor{Fun}}
\coqdocvar{f} \coqdocvar{args} \ensuremath{\Rightarrow}
\coqdockw{match}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Arith.Bool\_nat}{ltgedec}{\coqdocdefinition{lt\_ge\_dec}}
\coqdocvariable{n} (\coqdocprojection{arity}
\coqdocvariable{f}) \coqdockw{with}\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Specif}{left}{\coqdocconstructor{left}}
\coqdocvar{h}  \ensuremath{\Rightarrow} \coqdockw{match}
\coqref{Context.dig}{\coqdocdefinition{dig}}
(\coqdocdefinition{vnth} \coqdocvariable{h}
\coqdocvariable{args}) \coqdocvariable{p} \coqdockw{with}\coqdoceol
\coqdocindent{7.00em}
\ensuremath{|}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{None}{\coqdocconstructor{None}}
\ensuremath{\Rightarrow}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{None}{\coqdocconstructor{None}}\coqdoceol
\coqdocindent{7.00em}
\ensuremath{|}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{Some}{\coqdocconstructor{Some}}
\coqdocvar{C} \ensuremath{\Rightarrow}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{Some}{\coqdocconstructor{Some}}
(\coqref{Context.CFun}{\coqdocconstructor{CFun}} \coqdocvariable{f}
(\coqdoclemma{lt\_plus\_minus\_r}
\coqdocvariable{h})\coqdoceol
\coqdocindent{14.00em}
(\coqdocdefinition{vtake}
(\coqexternalref{http://coq.inria.fr/stdlib/Coq.Arith.Lt}{ltleweak}{\coqdoclemma{lt\_le\_weak}}
\coqdocvariable{n} (\coqdocprojection{arity}
\coqdocvariable{f}) \coqdocvariable{h})
\coqdocvariable{args})\coqdoceol
\coqdocindent{14.00em}
\coqdocvariable{C}\coqdoceol
\coqdocindent{14.00em}
(\coqdocdefinition{vdrop} \coqdocvariable{h}
\coqdocvariable{args}))\coqdoceol
\coqdocindent{7.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Specif}{right}{\coqdocconstructor{right}}
\coqdocvar{\_} \ensuremath{\Rightarrow}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{None}{\coqdocconstructor{None}}\coqdoceol
\coqdocindent{5.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\end{coqdoccode}
\end{singlespace}
Now \begin{coqdoccode}\coqref{Term.subterm}{\coqdocdefinition{subterm}}
  \coqdocvariable{t} \coqdocvariable{p}\end{coqdoccode} gives the
subterm of \coqdocvariable{t} (if it exists)
and \begin{coqdoccode}\coqref{Context.dig}{\coqdocdefinition{dig}}
  \coqdocvariable{t} \coqdocvariable{p}\end{coqdoccode} gives the
context \coqdocvariable{C} (if it exists) that is \coqdocvariable{t}
with \begin{coqdoccode}\coqref{Term.subterm}{\coqdocdefinition{subterm}}
  \coqdocvariable{t} \coqdocvariable{p}\end{coqdoccode} replaced by
$\Box$ at position \coqdocvariable{p}.


\section{Transfinite Rewrite Sequences}\label{sec:seq}

TODO: this section is the crux of our development and is original work.

Throughout this section, we let $\mathcal{R}$ be a fixed TRS. We
define the type of steps using rewrite rules in $\mathcal{R}$,
parameterised by their source and target terms.
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Inductive} \coqdef{Rewriting.step}{step}{$\rightarrow_\mathcal{R}$} :
\coqref{Term.term}{\coqdocinductive{term}} \ensuremath{\rightarrow}
\coqref{Term.term}{\coqdocinductive{term}} \ensuremath{\rightarrow}
\coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{Rewriting.Step}{Step}{\coqdocconstructor{Step}} :
\ensuremath{\forall} (\coqdocvar{s} \coqdocvar{t} :
\coqref{Term.term}{\coqdocinductive{term}}) (\coqdocvar{$\rho$} :
\coqdocrecord{rule}) (\coqdocvar{C} :
\coqref{Context.context}{\coqdocinductive{context}}) (\coqdocvar{$\sigma$} :
\coqref{Substitution.substitution}{\coqdocdefinition{substitution}}),\coqdoceol
\coqdocindent{6.50em} \coqdocvariable{$\rho$}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Lists.List}{In}{\coqdocdefinition{$\in$}}
\coqdocvar{$\mathcal{R}$} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{6.50em}
\coqdocvariable{C}[(\coqref{Rewriting.lhs}{\coqdocprojection{lhs}}
\coqdocvariable{$\rho$})\coqdocvariable{$^\sigma$}] \coqref{TermEquality.termbis}{$\bis$} \coqdocvariable{s}
\ensuremath{\rightarrow}\coqdoceol
\coqdocindent{6.50em}
\coqdocvariable{C}[(\coqref{Rewriting.rhs}{\coqdocprojection{rhs}}
\coqdocvariable{$\rho$})\coqdocvariable{$^\sigma$}] \coqref{TermEquality.termbis}{$\bis$} \coqdocvariable{t}
\ensuremath{\rightarrow}\coqdoceol
\coqdocindent{6.50em}
\coqdocvariable{s} \coqref{Rewriting.step}{$\rightarrow_\mathcal{R}$}
\coqdocvariable{t}.\coqdoceol
\end{coqdoccode}
\end{singlespace}
For the translation of Definition~\ref{def:stepeq} (equality of steps)
to \Coq, we assume the lifting of bisimilarity to contexts and that
\coqdef{Substitution.substitutioneq}{substitution\_eq}{\coqdocdefinition{substitution\_eq}}
defines agreement of substitutions on a given list of variables.
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Definition}
\coqdef{Rewriting.stepeq}{step\_eq}{$\approx$}
(\coqdocvar{s} \coqdocvar{t} :
\coqref{Term.term}{\coqdocinductive{term}}) (\coqdocvar{$\pi$} :
\coqdocvar{s} \coqref{Rewriting.step}{$\rightarrow_\mathcal{R}$} \coqdocvar{t}) (\coqdocvar{u} \coqdocvar{v} :
\coqref{Term.term}{\coqdocinductive{term}}) (\coqdocvar{$o$} :
\coqdocvar{u} \coqref{Rewriting.step}{$\rightarrow_\mathcal{R}$}
\coqdocvar{v}) : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{$\pi$}, \coqdocvariable{$o$}
\coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{Rewriting.Step}{\coqdocconstructor{Step}}
\coqdocvar{\_} \coqdocvar{\_} \coqdocvar{$\rho$} \coqdocvar{C}
\coqdocvar{$\sigma$} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_},
\coqref{Rewriting.Step}{\coqdocconstructor{Step}} \coqdocvar{\_}
\coqdocvar{\_} \coqdocvar{$\rho'$} \coqdocvar{C$'$} \coqdocvar{$\sigma'$}
\coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_}
\ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{C} $\bis$ \coqdocvariable{C$'$} \ensuremath{\land}
\coqdocvariable{$\rho$} = \coqdocvariable{$\rho'$} \ensuremath{\land}
\coqref{Substitution.substitutioneq}{\coqdocdefinition{substitution\_eq}}
(\coqdocdefinition{vars}
(\coqref{Rewriting.lhs}{\coqdocprojection{lhs}} \coqdocvariable{$\rho$}))
\coqdocvariable{$\sigma$} \coqdocvariable{$\sigma'$}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\end{coqdoccode}
\end{singlespace}
% TODO: naming of variables is not so nice here

We describe a way to define rewrite sequences as an inductive type. A rewrite
sequence of length $\alpha$ can be represented by the Brouwer ordinal $\alpha$
where we label every occurrence of the $^+$ constructor with a rewrite
step. To ensure that successive steps have the same target and source terms,
respectively, we include the source and target terms of the rewrite sequence
in its type and label accordingly.

At this point, it is not immediately clear what the type of the limit
constructor should be. Following the Brouwer ordinals, we think of a rewrite
sequence as a countably branching tree with every branching node representing
the least upper bound of its branches.
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Inductive}
\coqdef{Rewriting.sequence}{sequence}{$\rewrites_\mathcal{R}$} :
\coqref{Term.term}{\coqdocinductive{term}} \ensuremath{\rightarrow}
\coqref{Term.term}{\coqdocinductive{term}} \ensuremath{\rightarrow}
\coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{Rewriting.Nil}{Nil}{\coqdocconstructor{Nil}} :
\ensuremath{\forall} \coqdocvar{t}, \coqdocvariable{t}
\coqref{Rewriting.sequence}{$\rewrites_\mathcal{R}$}
\coqdocvariable{t}\coqdoceol \coqdocindent{1.00em}
\ensuremath{|} \coqdef{Rewriting.Cons}{Cons}{\coqdocconstructor{Cons}} :
\ensuremath{\forall} \coqdocvar{s} \coqdocvar{t} \coqdocvar{u}, \coqdocvar{s}
\coqref{Rewriting.sequence}{$\rewrites_\mathcal{R}$} \coqdocvar{t}
$\rightarrow$
\coqdocvariable{t} \coqref{Rewriting.step}{$\rightarrow_\mathcal{R}$}
\coqdocvar{u} $\rightarrow$ \coqdocvariable{s}
\coqref{Rewriting.sequence}{$\rewrites_\mathcal{R}$}
\coqdocvariable{u}\coqdoceol \coqdocindent{1.00em}
\ensuremath{|} \coqdocconstructor{Lim}   :
\ensuremath{\forall} \coqdocvar{s} \coqdocvar{t},
(\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}}
\ensuremath{\rightarrow} \coqdocvariable{s}
\coqref{Rewriting.sequence}{$\rewrites_\mathcal{R}$}
\coqdef{Rewriting.LimPlaceholder}{LimPlaceholder}{\textbf{?}}) $\rightarrow$
\coqdocvariable{s}
\coqref{Rewriting.sequence}{$\rewrites_\mathcal{R}$}
\coqdocvariable{t}.\coqdoceol
\end{coqdoccode}
\end{singlespace}

TODO: (in prelims) $\rewrites_\mathcal{R}$ binds stronger than
$\rightarrow$

This is not yet a satisfying definition, because we cannot fix a value for
\coqref{Rewriting.LimPlaceholder}{\textbf{?}}. We complete the type for
\coqref{Rewriting.Lim}{\coqdocconstructor{Lim}} as follows. First, we
parameterise it with the target terms of the branches. Second, we add the
condition that these terms must converge to the target term
\coqdocvariable{t}.
\begin{singlespace}
\begin{coqdoccode}
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{Rewriting.Lim}{Lim}{\coqdocconstructor{Lim}} :
\ensuremath{\forall} \coqdocvar{s} \coqdocvar{t}
(\coqdocvar{ts} :
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}}
\ensuremath{\rightarrow} \coqref{Term.term}{\coqdocinductive{term}}),
(\ensuremath{\forall} \coqdocvar{n}, \coqdocvar{s}
\coqref{Rewriting.sequence}{$\rewrites_\mathcal{R}$}
\coqdocvar{ts} \coqdocvariable{n}) $\rightarrow$
\coqref{Rewriting.converges}{\coqdocdefinition{converges}} \coqdocvariable{ts}
\coqdocvariable{t} $\rightarrow$
\coqdocvariable{s}
\coqref{Rewriting.sequence}{$\rewrites_\mathcal{R}$}
\coqdocvariable{t}\coqdoceol
\end{coqdoccode}
\end{singlespace}
% TODO: maybe first convergence, then branches

Of course, the branches of a \coqref{Rewriting.Lim}{\coqdocconstructor{Lim}}
constructor may still not actually approximate to a rewrite sequence (of
length a limit ordinal). The intuition is that each branch should extend on
its preceeding ones. This would correspond to the
\coqref{WfOrdinal.wf}{\coqdocdefinition{wf}} property we defined on
\coqref{Ordinal.ord}{\coqdocinductive{ord}}, where we lift $\prec$ to a
strict prefix relation on
\coqref{Rewriting.sequence}{$\rewrites_\mathcal{R}$}.
We return to this issue in Section~\ref{sub:wf}, but
first consider the definition of an embedding relation on
\coqref{Rewriting.sequence}{$\rewrites_\mathcal{R}$}.


\subsection{Embeddings of Rewrite Sequences}

We lift the notions of predecessor and predecessor indices to the domain of
rewrite sequences. The set of predecessor indices is easily defined as
\coqref{Rewriting.predtype}{\coqdocdefinition{pred\_type}}.
%\footnote{We employ some notational overloading by reusing $I(\_)$ and
%  $[\_]\_$ for the corresponding definitions on rewrite sequences.}
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Fixpoint}
\coqdef{Rewriting.predtype}{pred\_type}{\coqdocdefinition{pred\_type}}
\coqdocvar{s} \coqdocvar{t}
(\coqdocvar{$\varphi$} : \coqdocvar{s}
\coqref{Rewriting.sequence}{$\rewrites_\mathcal{R}$} \coqdocvar{t}) :
\coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{$\varphi$} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{Rewriting.Nil}{\coqdocconstructor{Nil}} \coqdocvar{\_}
\ensuremath{\Rightarrow}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Logic}{False}{\coqdocinductive{False}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{Rewriting.Cons}{\coqdocconstructor{Cons}}
\coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{$\psi$} \coqdocvar{\_}
\ensuremath{\Rightarrow}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{unit}{\coqdocinductive{unit}}
+ \coqref{Rewriting.predtype}{\coqdocdefinition{pred\_type}}
\coqdocvariable{$\psi$}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{Rewriting.Lim}{\coqdocconstructor{Lim}} \coqdocvar{\_}
\coqdocvar{\_} \coqdocvar{\_} \coqdocvar{f} \coqdocvar{\_}
\ensuremath{\Rightarrow} \{ \coqdocvar{n} :
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}}
\& \coqref{Rewriting.predtype}{\coqdocdefinition{pred\_type}}
(\coqdocvariable{f} \coqdocvariable{n}) \}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\end{coqdoccode}
\end{singlespace}

The predecessor indices defined by
\coqref{Rewriting.predtype}{\coqdocdefinition{pred\_type}} point to a specific
occurrence of the \coqref{Rewriting.Cons}{\coqdocconstructor{Cons}}
constructor in a rewrite sequence. This constructor does not only contain a
rewrite sequence (analoguous to an ordinal in the
\coqref{Ordinal.ord}{\coqdocinductive{ord}} case), but also a rewrite
step. The \coqref{Rewriting.pred}{\coqdocdefinition{pred}} function gives us
both the rewrite sequence and the step. For the type checker to accept the
definition, we use a $\Sigma$-type that contains this pair, parameterised by
the source and target terms of the rewrite step.
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{Rewriting.pred}{pred}{\coqdocdefinition{pred}}
\coqdocvar{s} \coqdocvar{t} (\coqdocvar{$\varphi$} : \coqdocvar{s}
\coqref{Rewriting.sequence}{$\rewrites_\mathcal{R}$} \coqdocvar{t})
(\coqdocvar{$\iota$} : \coqref{Rewriting.predtype}{\coqdocdefinition{pred\_type}}
\coqdocvariable{$\varphi$})
:\coqdoceol \coqdocindent{2.00em}
\{ \coqdocvar{ts} :
\coqref{Term.term}{\coqdocinductive{term}} \ensuremath{\times}
\coqref{Term.term}{\coqdocinductive{term}} \&
(\coqdocvariable{s} \coqref{Rewriting.sequence}{$\rewrites_\mathcal{R}$}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{fst}{\coqdocdefinition{fst}}
\coqdocvariable{ts}) \ensuremath{\times}
(\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{fst}{\coqdocdefinition{fst}}
\coqdocvariable{ts} \coqref{Rewriting.step}{$\rightarrow_\mathcal{R}$}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{snd}{\coqdocdefinition{snd}}
\coqdocvariable{ts}) \} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{$\varphi$} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{Rewriting.Nil}{\coqdocconstructor{Nil}} \coqdocvar{\_}
\ensuremath{\Rightarrow}
(\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Logic}{Falserect}{\coqdocdefinition{False\_rect}}
\coqdocvar{\_}) \coqdocvariable{$\iota$} \coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{Rewriting.Cons}{\coqdocconstructor{Cons}} \coqdocvar{\_}
\coqdocvar{u} \coqdocvar{t} \coqdocvar{$\psi$} \coqdocvar{$\pi$}
\ensuremath{\Rightarrow}
\coqdockw{match} \coqdocvariable{$\iota$} \coqdockw{with}\coqdoceol
\coqdocindent{10.00em}
\ensuremath{|}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{inl}{\coqdocconstructor{inl}}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{tt}{\coqdocconstructor{tt}}
\ensuremath{\Rightarrow}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Specif}{existT}{\coqdocconstructor{existT}}
\coqdocvar{\_} (\coqdocvariable{u}, \coqdocvariable{t})
(\coqdocvariable{$\psi$}, \coqdocvariable{$\pi$})\coqdoceol
\coqdocindent{10.00em}
\ensuremath{|}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{inr}{\coqdocconstructor{inr}}
\coqdocvar{$\kappa$}  \ensuremath{\Rightarrow}
\coqref{Rewriting.pred}{\coqdocdefinition{pred}} \coqdocvariable{$\psi$}
\coqdocvariable{$\kappa$}\coqdoceol
\coqdocindent{10.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{Rewriting.Lim}{\coqdocconstructor{Lim}} \coqdocvar{\_}
\coqdocvar{\_} \coqdocvar{\_} \coqdocvar{f} \coqdocvar{\_}
\ensuremath{\Rightarrow}
\coqdockw{match} \coqdocvariable{$\iota$} \coqdockw{with}\coqdoceol
\coqdocindent{10.00em}
\ensuremath{|}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Specif}{existT}{\coqdocconstructor{existT}}
\coqdocvar{n} \coqdocvar{$\kappa$} \ensuremath{\Rightarrow}
\coqref{Rewriting.pred}{\coqdocdefinition{pred}} (\coqdocvariable{f}
\coqdocvariable{n}) \coqdocvariable{$\kappa$}\coqdoceol
\coqdocindent{10.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\end{coqdoccode}
\end{singlespace}
% TODO: we simplified this (mainly type inference helpers)

In an effort to prevent getting lost in a syntactical labyrinth, we define
the following notational shortcuts:

% TODO: keep an eye on placement of the table
% TODO: maybe add real Coq code in a third column
{\renewcommand{\arraystretch}{1.1}
\renewcommand{\tabcolsep}{10pt}
\begin{tabular}{ll}
$\varphi[\iota]$ & location of $\varphi$ indexed by $\iota$\\
$\varphi[\iota]^\textsc{seq}$ & predecessor rewrite sequence of $\varphi$ indexed by $\iota$\\
$\varphi[\iota]^\textsc{stp}$ & step of $\varphi$ indexed by $\iota$\\
$\varphi[\iota]^\textsc{l}$ & source term of $\varphi[\iota]^\textsc{stp}$ (also target term
  of $\varphi[\iota]^\textsc{seq}$)\\
$\varphi[\iota]^\textsc{r}$ & target term of $\varphi[\iota]^\textsc{stp}$
\end{tabular}}

As an example of predecessor indexing, consider the graphical
representation of a rewrite sequence $\varphi$ of length $\omega + 2$
and its predecessor index $\iota = \coqdocconstructor{inr} \;
(\coqdocconstructor{inr} \; \langle 4,
\coqdocconstructor{inl}\rangle)$ in Figure~\ref{fig:pred}. The initial
part of length $\omega$ is represented by a series of finite rewrite
sequences, each one extending on the previous one by one step. The
sequence of terms $\{ t_1,t_2, t_3, \ldots \}$ converges to the term
$t_\omega$. Here, $\varphi[\iota]^\textsc{seq}$ is a rewrite sequence
from $t_1$ to $t_3$ and $\varphi[\iota]^\textsc{stp}$ is a step from
$t_3$ to $t_4$.

\begin{figure}
\begin{center}
\begin{tikzpicture}
\input{figures/predecessor.tikz}
\end{tikzpicture}
\end{center}
\caption{Example of a rewrite sequence and predecessor
  index.}\label{fig:pred}
\end{figure}

% TODO: better wording for 'canceled out'?
% TODO: picture of this embedding behaviour?
Having a closer look at the order $\preceq$ on the Brouwer ordinals, we can
see that it really defines embeddings of their tree structures. This is due to
clause (\ref{def:order:succ}) of Definition~\ref{def:order}. In this clause,
two occurrences of the $^+$ constructor (one in both ordinals) are cancelled
out against each other, but the positions of these occurences in their
respective ordinals do not necessarily correspond. Since occurrences
of $^+$ carry no additional information, this has no effect on the resulting
relation.

% TODO: should we use the word 'iff'?
What this means for a translation of $\preceq$ to the domain of our
inductively defined rewrite sequences is that, indeed, we get an embedding
relation. We only have to make sure that in the
\coqref{Rewriting.Cons}{\coqdocconstructor{Cons}} case, we cancel out two
equal steps against each other.
We say that $\varphi$ is embedded in $\psi$ (written $\varphi
\sqsubseteq \psi$) if $\psi$ can be obtained from $\varphi$ by inserting
any number of steps in $\varphi$. We distinguish between inserting a step
\begin{inparaenum}[(i)]
  \item before the first step,
  \item after the last step and
  \item in between steps
\end{inparaenum}
in a rewrite sequence. Note that any steps inserted consecutively in between
steps necessarily form a cycle, because of the typing constraints in
the definition of rewrite sequence.
% TODO: is the wording good here (the three cases)?
% TODO: define cycle
% TODO: explaining image
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Inductive} \coqdef{Rewriting.embed}{embed}{$\sqsubseteq$}
: \ensuremath{\forall} \coqdocvar{s} \coqdocvar{t} \coqdocvar{u}
\coqdocvar{v}, \coqdocvariable{s}
\coqref{Rewriting.sequence}{$\rewrites_\mathcal{R}$} \coqdocvariable{t}
$\rightarrow$ \coqdocvariable{u}
\coqref{Rewriting.sequence}{$\rewrites_\mathcal{R}$} \coqdocvariable{v}
$\rightarrow$ \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|}
\coqdef{Rewriting.EmbedNil}{Embed\_Nil}{\coqdocconstructor{$\sqsubseteq_\text{Nil}$}}  :
\ensuremath{\forall} \coqdocvar{s} \coqdocvar{u} \coqdocvar{v} (\coqdocvar{$\psi$}
: \coqdocvariable{u} \coqref{Rewriting.sequence}{$\rewrites_\mathcal{R}$}
\coqdocvariable{v}),\coqdoceol
\coqdocindent{9.50em}
\coqref{Rewriting.Nil}{\coqdocconstructor{Nil}} \coqdocvariable{s}
\coqref{Rewriting.embed}{$\sqsubseteq$} \coqdocvariable{$\psi$}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|}
\coqdef{Rewriting.EmbedCons}{Embed\_Cons}{\coqdocconstructor{$\sqsubseteq_\text{Cons}$}} :
\ensuremath{\forall} \coqdocvar{s} \coqdocvar{t} \coqdocvar{u} \coqdocvar{v}
(\coqdocvar{$\psi$}
: \coqdocvariable{u} \coqref{Rewriting.sequence}{$\rewrites_\mathcal{R}$}
\coqdocvariable{v}) (\coqdocvar{$\iota$} :
\coqref{Rewriting.predtype}{\coqdocdefinition{pred\_type}}
\coqdocvariable{$\psi$})
(\coqdocvar{$\varphi$} : \coqdocvariable{s}
\coqref{Rewriting.sequence}{$\rewrites_\mathcal{R}$}
\coqdocvariable{$\psi$}[\coqdocvariable{$\iota$}]$^\textsc{l}$)\coqdoceol
\coqdocindent{5.00em}
(\coqdocvar{$\pi$} :
\coqdocvariable{$\psi$}[\coqdocvariable{$\iota$}]$^\textsc{l}$
\coqref{Rewriting.step}{$\rightarrow_\mathcal{R}$}
\coqdocvariable{t}),\coqdoceol
\coqdocindent{9.50em}
\coqdocvariable{$\varphi$} \coqref{Rewriting.embed}{$\sqsubseteq$}
\coqdocvariable{$\psi$}[\coqdocvariable{$\iota$}]$^\textsc{seq}$
\ensuremath{\rightarrow}\coqdoceol
\coqdocindent{9.50em}
\coqdocvariable{$\pi$} \coqref{Rewriting.stepeq}{$\approx$}
\coqdocvariable{$\psi$}[\coqdocvariable{$\iota$}]$^\textsc{stp}$
\ensuremath{\rightarrow}\coqdoceol
\coqdocindent{9.50em}
\coqref{Rewriting.Cons}{\coqdocconstructor{Cons}}
\coqdocvariable{$\varphi$} \coqdocvariable{$\pi$}
\coqref{Rewriting.embed}{$\sqsubseteq$}
\coqdocvariable{$\psi$}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|}
\coqdef{Rewriting.EmbedLim}{Embed\_Lim}{\coqdocconstructor{$\sqsubseteq_\text{Lim}$}}  :
\ensuremath{\forall} \coqdocvar{s} \coqdocvar{t} \coqdocvar{u} \coqdocvar{v}
(\coqdocvar{ts} :
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}}
\ensuremath{\rightarrow} \coqref{Term.term}{\coqdocinductive{term}})
(\coqdocvar{f} : \ensuremath{\forall} \coqdocvar{n},
\coqdocvariable{s}
\coqref{Rewriting.sequence}{$\rewrites_\mathcal{R}$}
\coqdocvariable{ts} \coqdocvariable{n})\coqdoceol
\coqdocindent{5.00em}
(\coqdocvar{c} :
\coqref{Rewriting.converges}{\coqdocdefinition{converges}} \coqdocvariable{ts}
\coqdocvar{t}) (\coqdocvar{$\psi$} : \coqdocvar{u}
\coqref{Rewriting.sequence}{$\rewrites_\mathcal{R}$}
\coqdocvar{v}),\coqdoceol
\coqdocindent{9.50em}
(\ensuremath{\forall} \coqdocvar{n}, (\coqdocvariable{f} \coqdocvariable{n})
\coqref{Rewriting.embed}{$\sqsubseteq$} \coqdocvariable{$\psi$})
\ensuremath{\rightarrow}\coqdoceol
\coqdocindent{9.50em}
\coqref{Rewriting.Lim}{\coqdocconstructor{Lim}} \coqdocvariable{f}
\coqdocvariable{c} \coqref{Rewriting.embed}{$\sqsubseteq$}
\coqdocvariable{$\psi$}.\coqdoceol
\end{coqdoccode}
\end{singlespace}
% TODO: (f n) without ()
% TODO: say what implicit/explicit arguments for cons and lim are

TODO: Strict embedding relation. It really expands after the last step!
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Definition}
\coqdef{Rewriting.embedstrict}{embed\_strict}{$\sqsubset$}
\coqdocvar{s} \coqdocvar{t} \coqdocvar{u} \coqdocvar{v}
(\coqdocvar{$\varphi$} : \coqdocvariable{s}
\coqref{Rewriting.sequence}{$\rewrites_\mathcal{R}$}
\coqdocvariable{t},
\coqdocvar{$\psi$} :
\coqdocvariable{u}
\coqref{Rewriting.sequence}{$\rewrites_\mathcal{R}$}
\coqdocvariable{v}) := \ensuremath{\exists} \coqdocvar{$\iota$},
\coqdocvariable{$\varphi$} $\sqsubseteq$
\coqdocvariable{$\psi$}[\coqdocvariable{$\iota$}]$^\textsc{seq}$.\coqdoceol
\end{coqdoccode}
\end{singlespace}


\subsection{Well-formed Rewrite Sequences and Convergence}\label{sub:wf}

On \coqref{Ordinal.ord}{\coqdocinductive{ord}} we defined the
\coqref{WfOrdinal.wf}{\coqdocdefinition{wf}} property to rule out a certain
class of ordinal representations. This issue translates directly to our
inductive representation of rewrite sequences.

$\sqsubset$ turns out to be satisfying for our present purposes.

TODO: think harder about what it means to have an embedding relation instead
of a prefix relation. Vincent said this about it:
\begin{quote}
Overigens bedachten dat het in principe niet heel erg is $\sqsubseteq$ te
definieren voor reducties zoals voor ordinalen. alleen zie je dan het meer een
notie van embedding/deelreductie ipv een notie van prefix geeft, maar ook daar
kun je denkelijk goed mee werken.

\ldots

als je een stuk invoegt in het midden in sigma moet dat noodzakelijkerwijs,
vanwege de constraints op begin-en eindpunten, een reductie cykel zijn. ik zou
verwachten dat dat uiteindelijk een goede notie van ordening (goede reducties)
oplevert (``de cykels doen er niet toe voor convergente rijen, en kun je
weglaten bij compressie''), die natuurlijk niet overeenkomt, ook niet in het
eindige geval met de prefix notie; het is deelwoord, of (op reductie rijtjes
als bomen) deelboom (en niet boom-factor).
\end{quote}

\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{Rewriting.wf}{wf}{\coqdocdefinition{wf}}
\coqdocvar{s} \coqdocvar{t}
(\coqdocvar{$\varphi$} : \coqdocvariable{s}
\coqref{Rewriting.sequence}{$\rewrites_\mathcal{R}$}
\coqdocvariable{t}) : \coqdockw{Prop}
:=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{$\varphi$} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{Rewriting.Nil}{\coqdocconstructor{Nil}}
\coqdocvar{\_}          \ensuremath{\Rightarrow}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Logic}{True}{\coqdocinductive{True}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{Rewriting.Cons}{\coqdocconstructor{Cons}}
\coqdocvar{\_} \coqdocvar{\_} \coqdocvar{$\psi$} \coqdocvar{\_}
\coqdocvar{\_} \ensuremath{\Rightarrow}
\coqref{Rewriting.wf}{\coqdocdefinition{wf}}
\coqdocvariable{\coqdocvariable{$\psi$}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{Rewriting.Lim}{\coqdocconstructor{Lim}}
\coqdocvar{\_} \coqdocvar{\_} \coqdocvar{f} \coqdocvar{\_}
\coqdocvar{\_}  \ensuremath{\Rightarrow}
(\ensuremath{\forall} \coqdocvar{n},
\coqref{Rewriting.wf}{\coqdocdefinition{wf}} (\coqdocvariable{f}
\coqdocvariable{n})) \ensuremath{\land}
\ensuremath{\forall} \coqdocvar{n} \coqdocvar{m}, \coqdocvariable{n}
< \coqdocvariable{m} \ensuremath{\rightarrow} \coqdocvariable{f}
\coqdocvariable{n}
\coqref{Rewriting.embedstrict}{$\sqsubset$}
\coqdocvariable{f} \coqdocvariable{m}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\end{coqdoccode}
\end{singlespace}


\subsection{Combining Rewrite Sequences}\label{sub:combining}

% TODO: maybe this should be before the previous subsection

With the \coqref{Rewriting.Cons}{\coqdocconstructor{Cons}}
constructor, we can extend a rewrite sequence with one step at the
end. Dually, \coqref{Rewriting.snoc}{\coqdocdefinition{snoc}} extends
a rewrite sequence with one step at the start. It is the analogue of
$1 \coqref{Ordinal.add}{+} \alpha$ on ordinals.

\coqref{Rewriting.snoc}{\coqdocdefinition{snoc}} is recursive in its
right argument, but for the \Coq type checker to accept our
definition, we must write it such that it consumes this argument
first.\footnote{The reason for this is rather technical, but the main
  point is that the match function can be used such that the type of
  unconsumed arguments change with it. We also give hints to match not
  shown here. TODO: this formulation (maybe cpdt explains it nicely)}
Hence, we use an auxiliary function
\coqref{Rewriting.snocrec}{\coqdocdefinition{snoc\_rec}}.
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Fixpoint}
\coqdef{Rewriting.snocrec}{snoc\_rec}{\coqdocdefinition{snoc\_rec}}
(\coqdocvar{s} \coqdocvar{t} \coqdocvar{u} :
\coqref{Term.term}{\coqdocinductive{term}}) (\coqdocvar{$\varphi$} :
\coqdocvariable{t}
\coqref{Rewriting.sequence}{$\rewrites_\mathcal{R}$}
\coqdocvariable{u}) : \coqdocvariable{s}
\coqref{Rewriting.step}{$\rightarrow_\mathcal{R}$}
\coqdocvariable{t} \ensuremath{\rightarrow} \coqdocvariable{s}
\coqref{Rewriting.sequence}{$\rewrites_\mathcal{R}$}
\coqdocvariable{u} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{$\varphi$} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{Rewriting.Nil}{\coqdocconstructor{Nil}}
\coqdocvar{\_}          \ensuremath{\Rightarrow} \coqdockw{fun}
\coqdocvar{$\pi$} \ensuremath{\Rightarrow}
\coqref{Rewriting.Cons}{\coqdocconstructor{Cons}}
(\coqref{Rewriting.Nil}{\coqdocconstructor{Nil}} \coqdocvariable{s})
\coqdocvariable{$\pi$}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{Rewriting.Cons}{\coqdocconstructor{Cons}}
\coqdocvar{\_} \coqdocvar{\_} \coqdocvar{$\psi$} \coqdocvar{\_}
\coqdocvar{$o$} \ensuremath{\Rightarrow} \coqdockw{fun} \coqdocvar{$\pi$}
\ensuremath{\Rightarrow}
\coqref{Rewriting.Cons}{\coqdocconstructor{Cons}}
(\coqref{Rewriting.snocrec}{\coqdocdefinition{snoc\_rec}}
\coqdocvariable{$\psi$} \coqdocvariable{$\pi$}) \coqdocvariable{$o$}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{Rewriting.Lim}{\coqdocconstructor{Lim}}
\coqdocvar{\_} \coqdocvar{\_} \coqdocvar{f} \coqdocvar{u}
\coqdocvar{c}  \ensuremath{\Rightarrow} \coqdockw{fun} \coqdocvar{$\pi$}
\ensuremath{\Rightarrow}
\coqref{Rewriting.Lim}{\coqdocconstructor{Lim}} (\coqdockw{fun}
\coqdocvar{$o$} \ensuremath{\Rightarrow}
\coqref{Rewriting.snocrec}{\coqdocdefinition{snoc\_rec}}
(\coqdocvariable{f} \coqdocvariable{$o$}) \coqdocvariable{$\pi$})
\coqdocvariable{c}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition}
\coqdef{Rewriting.snoc}{snoc}{\coqdocdefinition{snoc}} (\coqdocvar{s}
\coqdocvar{t} \coqdocvar{u} :
\coqref{Term.term}{\coqdocinductive{term}}) (\coqdocvar{$\pi$}
: \coqdocvar{s} \coqref{Rewriting.step}{$\rightarrow_\mathcal{R}$}
\coqdocvar{t}) (\coqdocvar{$\varphi$} : \coqdocvariable{t}
\coqref{Rewriting.sequence}{$\rewrites_\mathcal{R}$} \coqdocvar{u}) :
\coqdocvariable{s}
\coqref{Rewriting.sequence}{$\rewrites_\mathcal{R}$}
\coqdocvariable{u} :=
\coqref{Rewriting.snocrec}{\coqdocdefinition{snoc\_rec}}
\coqdocvariable{$\varphi$} \coqdocvariable{$\pi$}.\coqdoceol
\end{coqdoccode}
\end{singlespace}
A related operation is concatenation of rewrite sequences, the
analogue of addition on ordinals. It is defined in the same way as
\coqref{Rewriting.snoc}{\coqdocdefinition{snoc}}.
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Fixpoint}
\coqdef{Rewriting.appendrec}{append\_rec}{\coqdocdefinition{concat\_rec}}
(\coqdocvar{s} \coqdocvar{t} \coqdocvar{u} :
\coqref{Term.term}{\coqdocinductive{term}}) (\coqdocvar{$\psi$} :
\coqdocvariable{t}
\coqref{Rewriting.sequence}{$\rewrites_\mathcal{R}$}
\coqdocvariable{u}) : \coqdocvariable{s}
\coqref{Rewriting.sequence}{$\rewrites_\mathcal{R}$}
\coqdocvariable{t} \ensuremath{\rightarrow} \coqdocvariable{s}
\coqref{Rewriting.sequence}{$\rewrites_\mathcal{R}$}
\coqdocvariable{u} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{$\psi$} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{Rewriting.Nil}{\coqdocconstructor{Nil}}
\coqdocvar{\_}         \ensuremath{\Rightarrow} \coqdockw{fun}
\coqdocvar{$\varphi$} \ensuremath{\Rightarrow} \coqdocvariable{$\varphi$}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{Rewriting.Cons}{\coqdocconstructor{Cons}}
\coqdocvar{\_} \coqdocvar{\_} \coqdocvar{$\psi$} \coqdocvar{\_}
\coqdocvar{$\pi$} \ensuremath{\Rightarrow} \coqdockw{fun} \coqdocvar{$\varphi$}
\ensuremath{\Rightarrow}
\coqref{Rewriting.Cons}{\coqdocconstructor{Cons}}
(\coqref{Rewriting.appendrec}{\coqdocdefinition{concat\_rec}}
\coqdocvariable{$\psi$} \coqdocvariable{$\varphi$}) \coqdocvariable{$\pi$}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{Rewriting.Lim}{\coqdocconstructor{Lim}}
\coqdocvar{\_} \coqdocvar{\_} \coqdocvar{f} \coqdocvar{u}
\coqdocvar{c}  \ensuremath{\Rightarrow} \coqdockw{fun} \coqdocvar{$\varphi$}
\ensuremath{\Rightarrow}
\coqref{Rewriting.Lim}{\coqdocconstructor{Lim}} (\coqdockw{fun}
\coqdocvar{$o$} \ensuremath{\Rightarrow}
\coqref{Rewriting.appendrec}{\coqdocdefinition{concat\_rec}}
(\coqdocvariable{f} \coqdocvariable{$o$}) \coqdocvariable{$\varphi$})
\coqdocvariable{c}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition}
\coqdef{Rewriting.append}{append}{\coqdocdefinition{concat}}
(\coqdocvar{s} \coqdocvar{t} \coqdocvar{u} :
\coqref{Term.term}{\coqdocinductive{term}}) (\coqdocvar{$\varphi$} :
\coqdocvar{s}
\coqref{Rewriting.sequence}{$\rewrites_\mathcal{R}$} \coqdocvar{t})
(\coqdocvar{$\psi$} : \coqdocvariable{t}
\coqref{Rewriting.sequence}{$\rewrites_\mathcal{R}$} \coqdocvar{u}) :
\coqdocvariable{s}
\coqref{Rewriting.sequence}{$\rewrites_\mathcal{R}$}
\coqdocvariable{u} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{Rewriting.appendrec}{\coqdocdefinition{concat\_rec}}
\coqdocvariable{$\psi$} \coqdocvariable{$\varphi$}.\coqdoceol
\end{coqdoccode}
\end{singlespace}


\section{Properties of Terms and TRSs}

We define some predicates on terms and TRSs. Again, we let
$\mathcal{R}$ be a fixed TRS throughout this section.

We work with a somewhat relaxed definition of critical pairs. First,
we do not require the common instance to be a most general
one. Second, the substitution $\sigma$ might not be minimal and might
not introduce only fresh variables
(cf.\ Definition~\ref{def:overlap}). The effect of this relaxation is
that for every critical pair, we have a series of critical pairs by
this \Coq definition. This is precise enough for our present
purposes, however, since it has no effect on questions such as
\emph{`are there critical pairs?'} or \emph{`are all critical pairs
  trivial?'}.
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Definition}
\coqdef{Rewriting.criticalpair}{critical\_pair}{\coqdocdefinition{critical\_pair}}
(\coqdocvar{$\mathcal{R}$} : \coqdocdefinition{trs})
(\coqdocvar{t$_1$} \coqdocvar{t$_2$} :
\coqref{Term.term}{\coqdocinductive{term}}) : \coqdockw{Prop}
:=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{\exists} \coqdocvar{$\rho_1$} :
\coqdocrecord{rule}, \ensuremath{\exists}
\coqdocvar{$\rho_2$} :
\coqdocrecord{rule},
\ensuremath{\exists} \coqdocvar{p} :
\coqdocabbreviation{position},
\ensuremath{\exists} \coqdocvar{$\sigma$},
\ensuremath{\exists} \coqdocvar{$\tau$},\coqdoceol
\coqdocindent{3.00em}
\coqdocvariable{$\rho_1$} \coqdocdefinition{$\in$}
\coqdocvariable{$\mathcal{R}$}
\ensuremath{\land}
\coqdocvariable{$\rho_2$} \coqdocdefinition{$\in$}
\coqdocvar{$\mathcal{R}$} \ensuremath{\land}
(\coqdocvariable{$\rho_1$} = \coqdocvariable{$\rho_2$}
\ensuremath{\rightarrow}
\coqdocvariable{p} \ensuremath{\not=}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nil}{\coqdocconstructor{nil}})
\ensuremath{\land}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{match}
\coqref{Term.subterm}{\coqdocdefinition{subterm}} (\coqref{Rewriting.lhs}{\coqdocprojection{lhs}}
\coqdocvariable{$\rho_1$}) \coqdocvariable{p},
\coqref{Context.dig}{\coqdocdefinition{dig}} (\coqref{Rewriting.lhs}{\coqdocprojection{lhs}}
\coqdocvariable{$\rho_1$})$^{\coqdocvariable{$\sigma$}}$ \coqdocvariable{p}
\coqdockw{with}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{|}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{Some}{\coqdocconstructor{Some}}
\coqdocvar{s},
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{Some}{\coqdocconstructor{Some}}
\coqdocvar{C} \ensuremath{\Rightarrow}
\coqdocdefinition{is\_var} \coqdocvariable{s} =
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{false}{\coqdocconstructor{false}}
\ensuremath{\land}
\coqdocvariable{s}$^{\coqdocvariable{$\sigma$}}$ \coqref{TermEquality.termbis}{$\bis$}
(\coqref{Rewriting.lhs}{\coqdocprojection{lhs}}
\coqdocvariable{$\rho_2$})$^{\coqdocvariable{$\tau$}}$
\ensuremath{\land}\coqdoceol
\coqdocindent{12.00em}
\coqdocvariable{t$_1$} \coqref{TermEquality.termbis}{$\bis$}
\coqdocvariable{C}[(\coqref{Rewriting.rhs}{\coqdocprojection{rhs}}
\coqdocvariable{$\rho_2$})$^{\coqdocvariable{$\tau$}}$]
\ensuremath{\land}
\coqdocvariable{t$_2$} \coqref{TermEquality.termbis}{$\bis$}
(\coqref{Rewriting.rhs}{\coqdocprojection{rhs}}
\coqdocvariable{$\rho_1$})$^{\coqdocvariable{$\sigma$}}$\coqdoceol
\coqdocindent{3.00em}
\ensuremath{|} \coqdocvar{\_}, \coqdocvar{\_}
\ensuremath{\Rightarrow}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Logic}{False}{\coqdocinductive{False}}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{end}.\coqdoceol
\end{coqdoccode}
\end{singlespace}
Now we can in a straightforward manner define the properties of
orthogonality and weak orhogonality.
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Definition}
\coqdef{Rewriting.orthogonal}{orthogonal}{\coqdocdefinition{orthogonal}} (\coqdocvar{$\mathcal{R}$} :
\coqdocdefinition{trs})
: \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqdocdefinition{trs\_left\_linear} % TODO: maybe define trs_left_linear and link to it
\coqdocvariable{$\mathcal{R}$} \ensuremath{\land}
\ensuremath{\forall} \coqdocvar{t$_1$} \coqdocvar{t$_2$},
\ensuremath{\lnot}
\coqref{Rewriting.criticalpair}{\coqdocdefinition{critical\_pair}}
\coqdocvariable{t$_1$} \coqdocvariable{t$_2$}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition}
\coqdef{Rewriting.weaklyorthogonal}{weakly\_orthogonal}{\coqdocdefinition{weakly\_orthogonal}} (\coqdocvar{$\mathcal{R}$} :
\coqdocdefinition{trs})
: \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqdocdefinition{trs\_left\_linear}
\coqdocvariable{$\mathcal{R}$} \ensuremath{\land}
\ensuremath{\forall} \coqdocvar{t$_1$} \coqdocvar{t$_2$},
\coqref{Rewriting.criticalpair}{\coqdocdefinition{critical\_pair}}
\coqdocvariable{t$_1$} \coqdocvariable{t$_2$} \ensuremath{\rightarrow}
\coqdocvariable{t$_1$} \coqref{TermEquality.termbis}{$\bis$} \coqdocvariable{t$_2$}.\coqdoceol
\end{coqdoccode}
\end{singlespace}

Next we define when a term is a normal form and when we have unique
normal forms.
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Definition}
\coqdef{Rewriting.normalform}{normal\_form}{\coqdocdefinition{normal\_form}}
\coqdocvar{t} : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{\lnot} \ensuremath{\exists} \coqdocvar{C} : \coqref{Context.context}{\coqdocinductive{context}},
\ensuremath{\exists} \coqdocvar{$\rho$} : \coqdocrecord{rule},
\ensuremath{\exists} \coqdocvar{$\sigma$} :
\coqref{Substitution.substitution}{\coqdocdefinition{substitution}},
\coqdocvariable{$\rho$}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Lists.List}{In}{\coqdocdefinition{$\in$}}
\coqdocvar{$\mathcal{R}$} \ensuremath{\land}
\coqdocvariable{C}[(\coqref{Rewriting.lhs}{\coqdocprojection{lhs}}
\coqdocvariable{r})\coqdocvariable{$^\sigma$}] \coqref{TermEquality.termbis}{$\bis$}
\coqdocvariable{t}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition}
\coqdef{Rewriting.uniquenormalforms}{unique\_normal\_forms}{\coqdocdefinition{unique\_normal\_forms}}
: \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{\forall} \coqdocvar{s} \coqdocvar{t} \coqdocvar{u}
(\coqdocvar{$\varphi$} : \coqdocvariable{s} \coqref{Rewriting.sequence}{$\rewrites_\mathcal{R}$} \coqdocvariable{t})
(\coqdocvar{$\psi$} : \coqdocvariable{s} \coqref{Rewriting.sequence}{$\rewrites_\mathcal{R}$} \coqdocvariable{u}),\coqdoceol
\coqdocindent{2.00em}
\coqref{Rewriting.wf}{\coqdocdefinition{wf}} \coqdocvariable{$\varphi$}
\ensuremath{\rightarrow}
\coqref{Rewriting.wf}{\coqdocdefinition{wf}} \coqdocvariable{$\psi$}
\ensuremath{\rightarrow}
\coqref{Rewriting.normalform}{\coqdocdefinition{normal\_form}}
\coqdocvariable{t} \ensuremath{\rightarrow}
\coqref{Rewriting.normalform}{\coqdocdefinition{normal\_form}}
\coqdocvariable{u} \ensuremath{\rightarrow}
\coqdocvariable{t} \coqref{TermEquality.termbis}{$\bis$} \coqdocvariable{u}.\coqdoceol
\end{coqdoccode}
\end{singlespace}
Note that the
\coqref{Rewriting.uniquenormalforms}{\coqdocdefinition{unique\_normal\_forms}}
definition is only a translation of the $UN^\rewrites$ property, not
of the more general $UN^\infty$ property (see also
Definition~\ref{def:normalisation}).

% TODO: note in chapter unwo that we proved ~UN^\infty with ~UN^->
