\chapter{A Mechanic Formalization}\label{chap:implementation}

TODO: introduction.


\section{The \Coq Proof Assistant}

TODO: text
TODO: very short intro to coq syntax (include `(...) notation)
TODO: some notes about code listings. coq has implicit arguments. we aim for
brevity.
TODO: label and number listings
TODO: we will take some notational liberties (syntax precedence levels, infix
notation etc)

For example, the type of the \coqdocconstructor{Cons} constructor in listing x
is written with explicitely generalized variables as
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\ensuremath{\forall} (\coqdocvar{s} \coqdocvar{t} :
\coqref{Term.term}{\coqdocinductive{term}}) (\coqdocvar{$\rho$}
: \coqdocvar{s} $\twoheadrightarrow_\mathcal{R}$ \coqdocvar{t})
(\coqdocvar{u} : \coqref{Term.term}{\coqdocinductive{term}})
(\coqdocvar{$\pi$} : \coqdocvariable{t}
$\rightarrow_\mathcal{R}$ \coqdocvar{u}),
\coqdocvariable{s} $\twoheadrightarrow_\mathcal{R}$
\coqdocvariable{u}\coqdoceol
\end{coqdoccode}
\end{singlespace}
and can be simplified with automatically generalized variables as
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\ensuremath{\forall} `(\coqdocvar{$\rho$} : \coqdocvar{s}
$\twoheadrightarrow_\mathcal{R}$ \coqdocvar{t},
\coqdocvar{$\pi$} : \coqdocvariable{t} $\rightarrow_\mathcal{R}$ \coqdocvar{u}),
\coqdocvariable{s} $\twoheadrightarrow_\mathcal{R}$
\coqdocvariable{u}\coqdoceol
\end{coqdoccode}
\end{singlespace}
% TODO: the other way around


\section{Ordinal Numbers}

In the theory of infinitary rewriting, the lengths of rewrite sequences play
a central role. Therefore, any reasonable formalization of infinitary
rewriting ought to have some notion of ordinal numbers.

We define the ordinal numbers using the representation of Brouwer
ordinals (cf.~Definition~\ref{def:ordinals}) in \Coq by
\coqref{Ordinal.ord}{\coqdocinductive{ord}}.
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Inductive} \coqdef{Ordinal.ord}{ord}{\coqdocinductive{ord}} :
\coqdockw{Set} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{Ordinal.Zero}{Zero}{\coqdocconstructor{Zero}}  :
\coqref{Ordinal.ord}{\coqdocinductive{ord}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{Ordinal.Succ}{Succ}{\coqdocconstructor{Succ}}  :
\coqref{Ordinal.ord}{\coqdocinductive{ord}} \ensuremath{\rightarrow}
\coqref{Ordinal.ord}{\coqdocinductive{ord}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{Ordinal.Limit}{Limit}{\coqdocconstructor{Limit}} :
(\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}}
\ensuremath{\rightarrow} \coqref{Ordinal.ord}{\coqdocinductive{ord}})
\ensuremath{\rightarrow}
\coqref{Ordinal.ord}{\coqdocinductive{ord}}.\coqdoceol
\end{coqdoccode}
\end{singlespace}
In fact, all definitions from Section~\ref{sub:brouwer} translate directly to
\Coq code. We can now prove basic properties of $\preceq$, for example that it
is transitive.
% TODO: maybe add another example
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma}
\coqdef{Ordinal.ordletrans}{ord\_le\_trans}{\coqdoclemma{\ensuremath{\preceq_{\text{trans}}}}}
:
\ensuremath{\forall} \coqdocvar{\ensuremath{\alpha}}
\coqdocvar{\ensuremath{\beta}}
\coqdocvar{\ensuremath{\gamma}}, \coqdocvariable{\ensuremath{\alpha}}
\ensuremath{\preceq} \coqdocvariable{\ensuremath{\beta}}
\ensuremath{\rightarrow}
\coqdocvariable{\ensuremath{\beta}} \ensuremath{\preceq}
\coqdocvariable{\ensuremath{\gamma}}
\ensuremath{\rightarrow} \coqdocvariable{\ensuremath{\alpha}}
\ensuremath{\preceq}
\coqdocvariable{\ensuremath{\gamma}}.\coqdoceol
\end{coqdoccode}
\end{singlespace}

Recalling our discussion in Section~\ref{sub:brouwer} of limit ordinals whose
sequences do not actually approximate to a limit ordinal, we consider the
lemma
\coqref{Ordinal.ordlezeroright}{\coqdoclemma{\ensuremath{\preceq_{\text{zero\_right}}}}}
as an example of this issue.
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma}
\coqdef{Ordinal.ordlezeroright}{ord\_le\_zero\_right}{\coqdoclemma{\ensuremath{\preceq_{\text{zero\_right}}}}}
:
\ensuremath{\forall} \coqdocvar{\ensuremath{\alpha}} \coqdocvar{\ensuremath{\beta}},
\coqdocvariable{\ensuremath{\alpha}} \ensuremath{\preceq}
\coqref{Ordinal.Zero}{\coqdocconstructor{Zero}}
\ensuremath{\rightarrow}
\coqdocvariable{\ensuremath{\alpha}} \ensuremath{\preceq}
\coqdocvariable{\ensuremath{\beta}}.\coqdoceol
\end{coqdoccode}
\end{singlespace}
We would like to strengthen this, but cannot, since nothing denies
\coqdocvariable{$\alpha$} from being the Brouwer ordinal $\sqcup \{ 0, 0, 0,
\ldots \}$ (which has the same rank as $0$). We therefore turn to a subset of
the Brouwer ordinals where we restrict limit sequences to be strictly
monotonic. This restriction is encoded in the
\coqref{WfOrdinal.wf}{\coqdocdefinition{wf}} property. The $\Sigma$-type
\coqref{WfOrdinal.wford}{\coqdocdefinition{ord$^\text{wf}$}} defines the
resulting subset.
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{WfOrdinal.wf}{wf}{\coqdocdefinition{wf}}
\coqdocvar{\ensuremath{\alpha}} : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{\ensuremath{\alpha}} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{Ordinal.Zero}{\coqdocconstructor{Zero}}
\ensuremath{\Rightarrow}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Logic}{True}{\coqdocinductive{True}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{Ordinal.Succ}{\coqdocconstructor{Succ}}
\coqdocvar{\ensuremath{\beta}} \ensuremath{\Rightarrow}
\coqref{WfOrdinal.wf}{\coqdocdefinition{wf}} \coqdocvariable{\ensuremath{\beta}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{Ordinal.Limit}{\coqdocconstructor{Limit}} \coqdocvar{f}
\ensuremath{\Rightarrow} \ensuremath{\forall} \coqdocvar{n},
\coqref{WfOrdinal.wf}{\coqdocdefinition{wf}} (\coqdocvariable{f}
\coqdocvariable{n}) \ensuremath{\land} \ensuremath{\forall} \coqdocvar{m},
\coqdocvariable{n} < \coqdocvariable{m} \ensuremath{\rightarrow}
\coqdocvariable{f} \coqdocvariable{n} \ensuremath{\prec}
\coqdocvariable{f} \coqdocvariable{m}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition}
\coqdef{WfOrdinal.wford}{wf\_ord}{\coqdocdefinition{ord$^\text{wf}$}} : \coqdockw{Set}
:=
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Specif}{sig}{\coqdocinductive{sig}}
\coqref{WfOrdinal.wf}{\coqdocdefinition{wf}}.\coqdoceol
\end{coqdoccode}
\end{singlespace}
Now we can prove the stronger result we were looking for.\footnote{Although
  \coqdocvariable{\ensuremath{\alpha}} has type
  \coqref{WfOrdinal.wford}{\coqdocdefinition{ord$^\text{wf}$}} and $\preceq$
  has type \coqref{Ordinal.ord}{\coqdocinductive{ord}} $\rightarrow$
  \coqref{Ordinal.ord}{\coqdocinductive{ord}} $\rightarrow$ \coqdockw{Prop},
  we can state the lemma in this concise way by defining a simple coercion
  from \coqref{WfOrdinal.wford}{\coqdocdefinition{ord$^\text{wf}$}} to
  \coqref{Ordinal.ord}{\coqdocinductive{ord}} (first $\Sigma$-type
  projection).}
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma}
\coqdef{WfOrdinal.wfordlezeroright}{wf\_ord\_le\_zero\_right}{\coqdoclemma{\ensuremath{\preceq^{\text{wf}}_{\text{zero\_right}}}}}
:
\ensuremath{\forall} \coqdocvar{\ensuremath{\alpha}} :
\coqref{WfOrdinal.wford}{\coqdocdefinition{ord$^\text{wf}$}},
\coqdocvariable{\ensuremath{\alpha}} \ensuremath{\preceq}
\coqref{Ordinal.Zero}{\coqdocconstructor{Zero}}
\ensuremath{\rightarrow}
\coqdocvariable{\ensuremath{\alpha}} =
\coqref{Ordinal.Zero}{\coqdocconstructor{Zero}}.\coqdoceol
\end{coqdoccode}
\end{singlespace}


\section{Coinductive Terms}

In \Coq, coinductive datatypes can be defined using the \coqdockw{CoInductive}
command. No induction principles are defined for these types, because they are
not well-founded.\footnote{\Coq automatically derives induction principles for
  inductive definitions.} The objects of a coinductive type may contain an
infinite number of constructors, but can only be built in some restricted way
to ensure productivity of the construction.
% TODO: productivity or effectiveness?
We defer discussion of this restriction to Section~\ref{sub:guardedness}, and
define the type \coqref{Term.term}{\coqdocinductive{term}} of infinite terms
with function symbols in \coqdocvar{F} and variables in \coqdocvar{X}.
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{CoInductive} \coqdef{Term.term}{term}{\coqdocinductive{term}} :
\coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{Term.Var}{Var}{\coqdocconstructor{Var}} : \coqdocvar{X}
\ensuremath{\rightarrow} \coqref{Term.term}{\coqdocinductive{term}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{Term.Fun}{Fun}{\coqdocconstructor{Fun}} :
\ensuremath{\forall} \coqdocvar{f} : \coqdocvar{F},
\coqref{Vector.vector}{\coqdocdefinition{vector}}
\coqref{Term.term}{\coqdocinductive{term}}
(\coqdocprojection{arity} \coqdocvariable{f})
\ensuremath{\rightarrow} \coqref{Term.term}{\coqdocinductive{term}}.\coqdoceol
\end{coqdoccode}
\end{singlespace}
Here, \coqref{Vector.vector}{\coqdocdefinition{vector}} is assumed to
implement dependently typed lists (the type depending on their length).

The standard Leibniz equality defined in \Coq, written $=$, does not suffice
for establishing that two terms are equal, given that the only way to build
infinite objects is by corecursion. Because the amount of memory available is
finite, we can only unfold the corecursive definition finitely many times, and
then still be left with a corecursive definition. Simply comparing such
definitions will not do, since the corecursive construction of any given
infinite object is not unique. To this end, we define two extensional
equalities on \coqref{Term.term}{\coqdocinductive{term}}, following
Definitions~\ref{def:bisimilarity} and \ref{def:equiv}. The coinductive
predicate \coqref{TermEquality.termbis}{$\sim$} defines bisimilarity and
syntactical equality is defined by \coqref{TermEquality.termeq}{$\equiv$}
inductively.
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{CoInductive}
\coqdef{TermEquality.termbis}{term\_bis}{$\sim$} :
\coqref{Term.term}{\coqdocinductive{term}} \ensuremath{\rightarrow}
\coqref{Term.term}{\coqdocinductive{term}} \ensuremath{\rightarrow}
\coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|}
\coqdef{TermEquality.Varbis}{Var\_bis}{\coqdocconstructor{$\sim_\text{Var}$}} :
\ensuremath{\forall} \coqdocvar{x},
\coqref{Term.Var}{\coqdocconstructor{Var}} \coqdocvariable{x}
\coqref{TermEquality.termbis}{$\sim$}
\coqref{Term.Var}{\coqdocconstructor{Var}} \coqdocvariable{x}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|}
\coqdef{TermEquality.Funbis}{Fun\_bis}{\coqdocconstructor{$\sim_\text{Fun}$}} :
\ensuremath{\forall} \coqdocvar{f} \coqdocvar{v} \coqdocvar{w},
(\ensuremath{\forall} \coqdocvar{i},
\coqdocvariable{v} \coqdocvariable{i}
\coqref{TermEquality.termbis}{$\sim$}
\coqdocvariable{w} \coqdocvariable{i})
\ensuremath{\rightarrow}
\coqref{Term.Fun}{\coqdocconstructor{Fun}} \coqdocvariable{f}
\coqdocvariable{v}
\coqref{TermEquality.termbis}{$\sim$}
\coqref{Term.Fun}{\coqdocconstructor{Fun}} \coqdocvariable{f}
\coqdocvariable{w}.\coqdoceol
\end{coqdoccode}
\end{singlespace}
Any proof of two infinite terms being bisimilar is an infinite proof, in the
sense that the proof term is built by corecursion.
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Inductive}
\coqdef{TermEquality.termequpto}{term\_eq\_up\_to}{\equpto{}}
:
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}}
\ensuremath{\rightarrow} \coqref{Term.term}{\coqdocinductive{term}}
\ensuremath{\rightarrow} \coqref{Term.term}{\coqdocinductive{term}}
\ensuremath{\rightarrow} \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|}
\coqdef{TermEquality.teut0}{teut\_0}{\coqdocconstructor{teut$_0$}}   :
\ensuremath{\forall} \coqdocvar{s} \coqdocvar{t},
\coqdocvariable{s} \coqref{TermEquality.termequpto}{\equpto{0}}
\coqdocvariable{t}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|}
\coqdef{TermEquality.teutvar}{teut\_var}{\coqdocconstructor{teut$_\text{Var}$}} :
\ensuremath{\forall} \coqdocvar{d} \coqdocvar{x},
\coqref{Term.Var}{\coqdocconstructor{Var}} \coqdocvariable{x}
\coqref{TermEquality.termequpto}{\equpto{\coqdocvariable{d}}}
\coqref{Term.Var}{\coqdocconstructor{Var}} \coqdocvariable{x}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|}
\coqdef{TermEquality.teutfun}{teut\_fun}{\coqdocconstructor{teut$_\text{Fun}$}} :
\ensuremath{\forall} \coqdocvar{d} \coqdocvar{f} \coqdocvar{v}
\coqdocvar{w},
(\ensuremath{\forall} \coqdocvar{i},
\coqdocvariable{v} \coqdocvariable{i}
\coqref{TermEquality.termequpto}{\equpto{\coqdocvariable{d}}}
\coqdocvariable{w} \coqdocvariable{i}) \ensuremath{\rightarrow}
\coqref{Term.Fun}{\coqdocconstructor{Fun}}
\coqdocvariable{f} \coqdocvariable{v}
\coqref{TermEquality.termequpto}{\equpto{\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{S}{\coqdocconstructor{S}}
    \, \coqdocvariable{d}}}
\coqref{Term.Fun}{\coqdocconstructor{Fun}} \coqdocvariable{f}
\coqdocvariable{w}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition}
\coqdocvar{s}
\coqdef{TermEquality.termeq}{term\_eq}{$\equiv$}
\coqdocvar{t} :=
\ensuremath{\forall} \coqdocvar{d},
\coqdocvariable{s}
\coqref{TermEquality.termequpto}{\equpto{\coqdocvariable{d}}}
\coqdocvariable{t}.\coqdoceol
\end{coqdoccode}
\end{singlespace}

We can prove that \coqref{TermEquality.termbis}{$\sim$} and
\coqref{TermEquality.termeq}{$\equiv$} are the same
relation, and that indeed it is an equality.
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma}
\coqdef{TermEquality.termbistermeq}{term\_bis\_term\_eq}{\coqdoclemma{term\_bis\_term\_eq}}
: \ensuremath{\forall} \coqdocvar{s} \coqdocvar{t},
\coqdocvariable{s}
\coqref{TermEquality.termbis}{$\sim$}
\coqdocvariable{t} \ensuremath{\leftrightarrow}
\coqdocvariable{s}
\coqref{TermEquality.termeq}{$\equiv$}
\coqdocvariable{t}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma}
\coqdef{TermEquality.termbisrefl}{term\_bis\_refl}{\coqdoclemma{$\sim_\text{refl}$}}
: \ensuremath{\forall} \coqdocvar{t},
\coqdocvariable{t}
\coqref{TermEquality.termbis}{$\sim$}
\coqdocvariable{t}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma}
\coqdef{TermEquality.termbissymm}{term\_bis\_symm}{\coqdoclemma{$\sim_\text{symm}$}}
: \ensuremath{\forall} \coqdocvar{s} \coqdocvar{t},
\coqdocvariable{s}
\coqref{TermEquality.termbis}{$\sim$}
\coqdocvariable{t} $\rightarrow$
\coqdocvariable{t}
\coqref{TermEquality.termbis}{$\sim$}
\coqdocvariable{s}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma}
\coqdef{TermEquality.termbistrans}{term\_bis\_trans}{\coqdoclemma{$\sim_\text{trans}$}}
: \ensuremath{\forall} \coqdocvar{s} \coqdocvar{t} \coqdocvar{u},
\coqdocvariable{s}
\coqref{TermEquality.termbis}{$\sim$}
\coqdocvariable{t} $\rightarrow$
\coqdocvariable{t}
\coqref{TermEquality.termbis}{$\sim$}
\coqdocvariable{u} $\rightarrow$
\coqdocvariable{s}
\coqref{TermEquality.termbis}{$\sim$}
\coqdocvariable{u}.\coqdoceol
\end{coqdoccode}
\end{singlespace}

In Section~\ref{sec:seq} we need some notion of convergence for functions of
type
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}}
$\rightarrow$
\coqref{Term.term}{\coqdocinductive{term}}. We implement
Definition~\ref{def:cauchy} in \Coq for sequences of length $\omega$.
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Definition}
\coqdef{Rewriting.converges}{converges}{\coqdocdefinition{converges}}
(\coqdocvar{f} :
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}}
\ensuremath{\rightarrow} \coqref{Term.term}{\coqdocinductive{term}})
(\coqdocvar{t} : \coqref{Term.term}{\coqdocinductive{term}}) :
\coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{\forall} \coqdocvar{d}, \ensuremath{\exists} \coqdocvar{n},
\ensuremath{\forall} \coqdocvar{m},
\coqdocvariable{n} \ensuremath{\le} \coqdocvariable{m}
\ensuremath{\rightarrow}
\coqdocvariable{f} \coqdocvariable{m}
\coqref{TermEquality.termequpto}{\equpto{\coqdocvariable{d}}}
\coqdocvariable{t}.\coqdoceol
\end{coqdoccode}
\end{singlespace}
The definitions of finite term, rewrite rule, TRS and left-linearity
from Section~\ref{sub:trs} translate to \Coq directly. We define
\coqdef{Rewriting.lhs}{lhs}{\coqdocprojection{lhs}} and
\coqdef{Rewriting.rhs}{rhs}{\coqdocprojection{rhs}} to be first and
second projection on rewrite rules.

The type of contexts is inductively defined, where the hole always
occurs at a finite depth.
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Inductive}
\coqdef{Context.context}{context}{\coqdocinductive{context}} :
\coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} $\Box$ :
\coqref{Context.context}{\coqdocinductive{context}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{Context.CFun}{CFun}{\coqdocconstructor{CFun}} :
\ensuremath{\forall} (\coqdocvar{f} : \coqdocvar{F}) (\coqdocvar{i}
\coqdocvar{j} :
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}}),\coqdoceol
\coqdocindent{5.50em}
\coqdocvariable{i} +
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{S}{\coqdocconstructor{S}}
\coqdocvariable{j} =
\coqdocprojection{arity} \coqdocvariable{f}
\ensuremath{\rightarrow}
\coqref{Vector.vector}{\coqdocdefinition{vector}}
\coqref{Term.term}{\coqdocinductive{term}} \coqdocvariable{i}
\ensuremath{\rightarrow}
\coqref{Context.context}{\coqdocinductive{context}}
\ensuremath{\rightarrow}
\coqref{Vector.vector}{\coqdocdefinition{vector}}
\coqref{Term.term}{\coqdocinductive{term}} \coqdocvariable{j}
\ensuremath{\rightarrow}
\coqref{Context.context}{\coqdocinductive{context}}.\coqdoceol
\end{coqdoccode}
\end{singlespace}
Applying a substitution \coqdocvariable{$\sigma$} to a term
\coqdocvariable{t} is defined by corecursion over
\coqdocvariable{t}. We also use the
notation \begin{coqdoccode}\coqdocvariable{t}$^\coqdocvariable{$\sigma$}$\end{coqdoccode}
for \begin{coqdoccode}\coqref{Substitution.substitute}{\coqdocdefinition{substitute}}
  \coqdocvariable{$\sigma$} \coqdocvariable{t}\end{coqdoccode}.
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{CoFixpoint}
\coqdef{Substitution.substitute}{substitute}{\coqdocdefinition{substitute}}
(\coqdocvar{$\sigma$} :
\coqdocdefinition{substitution})
(\coqdocvar{t} :
\coqref{Term.term}{\coqdocinductive{term}}) :
\coqref{Term.term}{\coqdocinductive{term}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{t} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{Term.Var}{\coqdocconstructor{Var}}
\coqdocvar{x}      \ensuremath{\Rightarrow} \coqdocvariable{$\sigma$}
\coqdocvariable{x}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{Term.Fun}{\coqdocconstructor{Fun}}
\coqdocvar{f} \coqdocvar{args} \ensuremath{\Rightarrow}
\coqref{Term.Fun}{\coqdocconstructor{Fun}} \coqdocvariable{f}
(\coqref{Vector.vmap}{\coqdocdefinition{vmap}}
(\coqref{Substitution.substitute}{\coqdocdefinition{substitute}}
\coqdocvariable{$\sigma$}) \coqdocvariable{args})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\end{coqdoccode}
\end{singlespace}
We apply the recursive function
\coqdef{Context.fill}{fill}{\coqdocdefinition{fill}} (not shown here)
to a context \coqdocvariable{c} and a term \coqdocvariable{t}
(written \begin{coqdoccode}\coqdocvariable{c}[\coqdocvariable{t}]\end{coqdoccode})
to replace the hole in \coqdocvariable{c} with \coqdocvariable{t}.

Positions are represented by simple lists of natural numbers. This
means the subterm at some position in some term may not actually
exist. For this reason we employ
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{option}{\coqdocinductive{option}}
types in functions that do a lookup by position (functions in \Coq are
always \emph{total}).
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Fixpoint}
\coqdef{Term.subterm}{subterm}{\coqdocdefinition{subterm}}
(\coqdocvar{t} : \coqref{Term.term}{\coqdocabbreviation{term}})
(\coqdocvar{p} :
\coqdocabbreviation{position})
\{\coqdockw{struct} \coqdocvar{p}\} :
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{option}{\coqdocinductive{option}}
\coqref{Term.term}{\coqdocabbreviation{term}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{p} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nil}{\coqdocconstructor{nil}}
\ensuremath{\Rightarrow}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{Some}{\coqdocconstructor{Some}}
\coqdocvariable{t}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{n} :: \coqdocvar{p} \ensuremath{\Rightarrow}
\coqdockw{match} \coqdocvariable{t} \coqdockw{with}\coqdoceol
\coqdocindent{7.00em}
\ensuremath{|} \coqref{Term.Var}{\coqdocconstructor{Var}}
\coqdocvar{\_}      \ensuremath{\Rightarrow}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{None}{\coqdocconstructor{None}}\coqdoceol
\coqdocindent{7.00em}
\ensuremath{|} \coqref{Term.Fun}{\coqdocconstructor{Fun}}
\coqdocvar{f} \coqdocvar{args} \ensuremath{\Rightarrow}
\coqdockw{match}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Arith.Bool\_nat}{ltgedec}{\coqdocdefinition{lt\_ge\_dec}}
\coqdocvariable{n} (\coqdocprojection{arity}
\coqdocvariable{f}) \coqdockw{with}\coqdoceol
\coqdocindent{15.00em}
\ensuremath{|}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Specif}{left}{\coqdocconstructor{left}}
\coqdocvar{h}  \ensuremath{\Rightarrow}
\coqref{Term.subterm}{\coqdocdefinition{subterm}}
(\coqdocdefinition{vnth} \coqdocvariable{h}
\coqdocvariable{args}) \coqdocvariable{p}\coqdoceol
\coqdocindent{15.00em}
\ensuremath{|}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Specif}{right}{\coqdocconstructor{right}}
\coqdocvar{\_} \ensuremath{\Rightarrow}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{None}{\coqdocconstructor{None}}\coqdoceol
\coqdocindent{15.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{7.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{Context.dig}{dig}{\coqdocdefinition{dig}}
(\coqdocvar{t} : \coqref{Term.term}{\coqdocabbreviation{term}})
(\coqdocvar{p} :
\coqdocabbreviation{position})
\{\coqdockw{struct} \coqdocvar{p}\} :
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{option}{\coqdocinductive{option}}
\coqref{Context.context}{\coqdocinductive{context}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{p} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nil}{\coqdocconstructor{nil}}
\ensuremath{\Rightarrow}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{Some}{\coqdocconstructor{Some}}
$\Box$\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{n} :: \coqdocvar{p} \ensuremath{\Rightarrow}
\coqdockw{match} \coqdocvariable{t} \coqdockw{with}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{|} \coqref{Term.Var}{\coqdocconstructor{Var}}
\coqdocvar{\_}      \ensuremath{\Rightarrow}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{None}{\coqdocconstructor{None}}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{|} \coqref{Term.Fun}{\coqdocconstructor{Fun}}
\coqdocvar{f} \coqdocvar{args} \ensuremath{\Rightarrow}
\coqdockw{match}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Arith.Bool\_nat}{ltgedec}{\coqdocdefinition{lt\_ge\_dec}}
\coqdocvariable{n} (\coqdocprojection{arity}
\coqdocvariable{f}) \coqdockw{with}\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Specif}{left}{\coqdocconstructor{left}}
\coqdocvar{h}  \ensuremath{\Rightarrow} \coqdockw{match}
\coqref{Context.dig}{\coqdocdefinition{dig}}
(\coqdocdefinition{vnth} \coqdocvariable{h}
\coqdocvariable{args}) \coqdocvariable{p} \coqdockw{with}\coqdoceol
\coqdocindent{7.00em}
\ensuremath{|}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{None}{\coqdocconstructor{None}}
\ensuremath{\Rightarrow}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{None}{\coqdocconstructor{None}}\coqdoceol
\coqdocindent{7.00em}
\ensuremath{|}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{Some}{\coqdocconstructor{Some}}
\coqdocvar{c} \ensuremath{\Rightarrow}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{Some}{\coqdocconstructor{Some}}
(\coqref{Context.CFun}{\coqdocconstructor{CFun}} \coqdocvariable{f}
(\coqdoclemma{lt\_plus\_minus\_r}
\coqdocvariable{h})\coqdoceol
\coqdocindent{14.00em}
(\coqdocdefinition{vtake}
(\coqexternalref{http://coq.inria.fr/stdlib/Coq.Arith.Lt}{ltleweak}{\coqdoclemma{lt\_le\_weak}}
\coqdocvariable{n} (\coqdocprojection{arity}
\coqdocvariable{f}) \coqdocvariable{h})
\coqdocvariable{args})\coqdoceol
\coqdocindent{14.00em}
\coqdocvariable{c}\coqdoceol
\coqdocindent{14.00em}
(\coqdocdefinition{vdrop} \coqdocvariable{h}
\coqdocvariable{args}))\coqdoceol
\coqdocindent{7.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Specif}{right}{\coqdocconstructor{right}}
\coqdocvar{\_} \ensuremath{\Rightarrow}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{None}{\coqdocconstructor{None}}\coqdoceol
\coqdocindent{5.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\end{coqdoccode}
\end{singlespace}
Now \begin{coqdoccode}\coqref{Term.subterm}{\coqdocdefinition{subterm}}
  \coqdocvariable{t} \coqdocvariable{p}\end{coqdoccode} gives the
subterm of \coqdocvariable{t} (if it exists)
and \begin{coqdoccode}\coqref{Context.dig}{\coqdocdefinition{dig}}
  \coqdocvariable{t} \coqdocvariable{p}\end{coqdoccode} gives the
context \coqdocvariable{c} (if it exists) that is \coqdocvariable{t}
with \begin{coqdoccode}\coqref{Term.subterm}{\coqdocdefinition{subterm}}
  \coqdocvariable{t} \coqdocvariable{p}\end{coqdoccode} replaced by
$\Box$ at position \coqdocvariable{p}.


\section{Transfinite Rewrite Sequences}\label{sec:seq}

% TODO: find correct \rightarrow symbol (this one is too fat)

Throughout this section, let $\mathcal{R}$ be a fixed TRS. We define
the type of steps using rewrite rules in $\mathcal{R}$, parameterized
by their source and target terms.
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Inductive} \coqdef{Rewriting.step}{step}{$\rightarrow_\mathcal{R}$} :
\coqref{Term.term}{\coqdocinductive{term}} \ensuremath{\rightarrow}
\coqref{Term.term}{\coqdocinductive{term}} \ensuremath{\rightarrow}
\coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{Rewriting.Step}{Step}{\coqdocconstructor{Step}} :
\ensuremath{\forall} (\coqdocvar{s} \coqdocvar{t} :
\coqref{Term.term}{\coqdocinductive{term}}) (\coqdocvar{$\rho$} :
\coqdocrecord{rule}) (\coqdocvar{c} :
\coqref{Context.context}{\coqdocinductive{context}}) (\coqdocvar{$\sigma$} :
\coqdocdefinition{substitution}),\coqdoceol
\coqdocindent{6.50em} \coqdocvariable{$\rho$}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Lists.List}{In}{\coqdocdefinition{$\in$}}
\coqdocvar{$\mathcal{R}$} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{6.50em}
\coqdocvariable{c}[(\coqref{Rewriting.lhs}{\coqdocprojection{lhs}}
\coqdocvariable{$\rho$})\coqdocvariable{$^\sigma$}] \coqref{TermEquality.termbis}{$\sim$} \coqdocvariable{s}
\ensuremath{\rightarrow}\coqdoceol
\coqdocindent{6.50em}
\coqdocvariable{c}[(\coqref{Rewriting.rhs}{\coqdocprojection{rhs}}
\coqdocvariable{$\rho$})\coqdocvariable{$^\sigma$}] \coqref{TermEquality.termbis}{$\sim$} \coqdocvariable{t}
\ensuremath{\rightarrow}\coqdoceol
\coqdocindent{6.50em}
\coqdocvariable{s} \coqref{Rewriting.step}{$\rightarrow_\mathcal{R}$}
\coqdocvariable{t}.\coqdoceol
\end{coqdoccode}
\end{singlespace}
We sketch a way to define rewrite sequences as an inductive type. A rewrite
sequence of length $\alpha$ can be represented by the Brouwer ordinal $\alpha$
where we label every occurrence of the $^+$ constructor with a rewrite
step. To ensure successive steps have the same target and source terms,
respectively, we include the source and target terms of the rewrite sequence
in its type and label accordingly.

At this point, it is not immediately clear what the type of the limit
constructor should be. Following the Brouwer ordinals, we think of a rewrite
sequence as a countably branching tree with every branching node representing
the least upper bound of its branches.
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Inductive}
\coqdef{Rewriting.sequence}{sequence}{$\twoheadrightarrow_\mathcal{R}$} :
\coqref{Term.term}{\coqdocinductive{term}} \ensuremath{\rightarrow}
\coqref{Term.term}{\coqdocinductive{term}} \ensuremath{\rightarrow}
\coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{Rewriting.Nil}{Nil}{\coqdocconstructor{Nil}} :
\ensuremath{\forall} \coqdocvar{t}, \coqdocvariable{t}
\coqref{Rewriting.sequence}{$\twoheadrightarrow_\mathcal{R}$}
\coqdocvariable{t}\coqdoceol \coqdocindent{1.00em}
\ensuremath{|} \coqdef{Rewriting.Cons}{Cons}{\coqdocconstructor{Cons}} :
\ensuremath{\forall} \coqdocvar{s} \coqdocvar{t} \coqdocvar{u}, \coqdocvar{s}
\coqref{Rewriting.sequence}{$\twoheadrightarrow_\mathcal{R}$} \coqdocvar{t}
$\rightarrow$
\coqdocvariable{t} \coqref{Rewriting.step}{$\rightarrow_\mathcal{R}$}
\coqdocvar{u} $\rightarrow$ \coqdocvariable{s}
\coqref{Rewriting.sequence}{$\twoheadrightarrow_\mathcal{R}$}
\coqdocvariable{u}\coqdoceol \coqdocindent{1.00em}
\ensuremath{|} \coqdocconstructor{Lim}   :
\ensuremath{\forall} \coqdocvar{s} \coqdocvar{t},
(\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}}
\ensuremath{\rightarrow} \coqdocvariable{s}
\coqref{Rewriting.sequence}{$\twoheadrightarrow_\mathcal{R}$}
\coqdef{Rewriting.LimPlaceholder}{LimPlaceholder}{\textbf{?}}) $\rightarrow$
\coqdocvariable{s}
\coqref{Rewriting.sequence}{$\twoheadrightarrow_\mathcal{R}$}
\coqdocvariable{t}.\coqdoceol
\end{coqdoccode}
\end{singlespace}

This is not yet a satisfying definition, because we cannot fix a value for
\coqref{Rewriting.LimPlaceholder}{\textbf{?}}. We complete the type for
\coqref{Rewriting.Lim}{\coqdocconstructor{Lim}} as follows. First, we
parameterize it with the target terms of the branches. Second, we add the
condition that these terms must converge to the target term
\coqdocvariable{t}.
\begin{singlespace}
\begin{coqdoccode}
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{Rewriting.Lim}{Lim}{\coqdocconstructor{Lim}} :
\ensuremath{\forall} \coqdocvar{s} \coqdocvar{t}
(\coqdocvar{ts} :
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}}
\ensuremath{\rightarrow} \coqref{Term.term}{\coqdocinductive{term}}),
(\ensuremath{\forall} \coqdocvar{n}, \coqdocvar{s}
\coqref{Rewriting.sequence}{$\twoheadrightarrow_\mathcal{R}$}
\coqdocvar{ts} \coqdocvariable{n}) $\rightarrow$
\coqref{Rewriting.converges}{\coqdocdefinition{converges}} \coqdocvariable{ts}
\coqdocvariable{t} $\rightarrow$
\coqdocvariable{s}
\coqref{Rewriting.sequence}{$\twoheadrightarrow_\mathcal{R}$}
\coqdocvariable{t}\coqdoceol
\end{coqdoccode}
\end{singlespace}
% TODO: maybe first convergence, then branches

Of course, the branches of a \coqref{Rewriting.Lim}{\coqdocconstructor{Lim}}
constructor may still not actually approximate to a rewrite sequence (of
length a limit ordinal). The intuition is that each branch should extend on
its preceeding ones. This would correspond to the
\coqref{WfOrdinal.wf}{\coqdocdefinition{wf}} property we defined on
\coqref{Ordinal.ord}{\coqdocinductive{ord}}, where we take $\prec$ to be a
strict prefix relation on
\coqref{Rewriting.sequence}{$\twoheadrightarrow_\mathcal{R}$}.
We return to this issue in Section~\ref{sub:wf}, but
first consider the definition of an embedding relation on
\coqref{Rewriting.sequence}{$\twoheadrightarrow_\mathcal{R}$}.


\subsection{Embeddings of Rewrite Sequences}

We lift the notions of predecessor and predecessor indices to the domain of
rewrite sequences. The set of predecessor indices is easily defined as
\coqref{Rewriting.predtype}{\coqdocdefinition{pred\_type}}.
%\footnote{We employ some notational overloading by reusing $I(\_)$ and
%  $[\_]\_$ for the corresponding definitions on rewrite sequences.}
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Fixpoint}
\coqdef{Rewriting.predtype}{pred\_type}{\coqdocdefinition{pred\_type}}
\coqdocvar{s} \coqdocvar{t}
(\coqdocvar{$\varphi$} : \coqdocvar{s}
\coqref{Rewriting.sequence}{$\twoheadrightarrow_\mathcal{R}$} \coqdocvar{t}) :
\coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{$\varphi$} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{Rewriting.Nil}{\coqdocconstructor{Nil}} \coqdocvar{\_}
\ensuremath{\Rightarrow}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Logic}{False}{\coqdocinductive{False}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{Rewriting.Cons}{\coqdocconstructor{Cons}}
\coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{$\psi$} \coqdocvar{\_}
\ensuremath{\Rightarrow}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{unit}{\coqdocinductive{unit}}
+ \coqref{Rewriting.predtype}{\coqdocdefinition{pred\_type}}
\coqdocvariable{$\psi$}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{Rewriting.Lim}{\coqdocconstructor{Lim}} \coqdocvar{\_}
\coqdocvar{\_} \coqdocvar{\_} \coqdocvar{f} \coqdocvar{\_}
\ensuremath{\Rightarrow} \{ \coqdocvar{n} :
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}}
\& \coqref{Rewriting.predtype}{\coqdocdefinition{pred\_type}}
(\coqdocvariable{f} \coqdocvariable{n}) \}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\end{coqdoccode}
\end{singlespace}

The predecessor indices defined by
\coqref{Rewriting.predtype}{\coqdocdefinition{pred\_type}} point to a specific
occurrence of the \coqref{Rewriting.Cons}{\coqdocconstructor{Cons}}
constructor in a rewrite sequence. This constructor does not just contain a
rewrite sequence (analoguous to an ordinal in the
\coqref{Ordinal.ord}{\coqdocinductive{ord}} case), but also a rewrite
step. The \coqref{Rewriting.pred}{\coqdocdefinition{pred}} function gives us
both the rewrite sequence and the step. For the type checker to accept the
definition, we use a $\Sigma$-type that contains this pair, parameterized by
the source and target terms of the rewrite step.
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{Rewriting.pred}{pred}{\coqdocdefinition{pred}}
\coqdocvar{s} \coqdocvar{t} (\coqdocvar{$\varphi$} : \coqdocvar{s}
\coqref{Rewriting.sequence}{$\twoheadrightarrow_\mathcal{R}$} \coqdocvar{t})
(\coqdocvar{$\iota$} : \coqref{Rewriting.predtype}{\coqdocdefinition{pred\_type}}
\coqdocvariable{$\varphi$})
:\coqdoceol \coqdocindent{2.00em}
\{ \coqdocvar{ts} :
\coqref{Term.term}{\coqdocabbreviation{term}} \ensuremath{\times}
\coqref{Term.term}{\coqdocabbreviation{term}} \&
(\coqdocvariable{s} \coqref{Rewriting.sequence}{$\twoheadrightarrow_\mathcal{R}$}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{fst}{\coqdocdefinition{fst}}
\coqdocvariable{ts}) \ensuremath{\times}
(\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{fst}{\coqdocdefinition{fst}}
\coqdocvariable{ts} \coqref{Rewriting.step}{$\rightarrow_\mathcal{R}$}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{snd}{\coqdocdefinition{snd}}
\coqdocvariable{ts}) \} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{$\varphi$} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{Rewriting.Nil}{\coqdocconstructor{Nil}} \coqdocvar{\_}
\ensuremath{\Rightarrow}
(\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Logic}{Falserect}{\coqdocdefinition{False\_rect}}
\coqdocvar{\_}) \coqdocvariable{$\iota$} \coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{Rewriting.Cons}{\coqdocconstructor{Cons}} \coqdocvar{\_}
\coqdocvar{u} \coqdocvar{t} \coqdocvar{$\psi$} \coqdocvar{$\pi$}
\ensuremath{\Rightarrow}
\coqdockw{match} \coqdocvariable{$\iota$} \coqdockw{with}\coqdoceol
\coqdocindent{10.00em}
\ensuremath{|}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{inl}{\coqdocconstructor{inl}}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{tt}{\coqdocconstructor{tt}}
\ensuremath{\Rightarrow}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Specif}{existT}{\coqdocconstructor{existT}}
\coqdocvar{\_} (\coqdocvariable{u}, \coqdocvariable{t})
(\coqdocvariable{$\psi$}, \coqdocvariable{$\pi$})\coqdoceol
\coqdocindent{10.00em}
\ensuremath{|}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{inr}{\coqdocconstructor{inr}}
\coqdocvar{$\kappa$}  \ensuremath{\Rightarrow}
\coqref{Rewriting.pred}{\coqdocdefinition{pred}} \coqdocvariable{$\psi$}
\coqdocvariable{$\kappa$}\coqdoceol
\coqdocindent{10.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{Rewriting.Lim}{\coqdocconstructor{Lim}} \coqdocvar{\_}
\coqdocvar{\_} \coqdocvar{\_} \coqdocvar{f} \coqdocvar{\_}
\ensuremath{\Rightarrow}
\coqdockw{match} \coqdocvariable{$\iota$} \coqdockw{with}\coqdoceol
\coqdocindent{10.00em}
\ensuremath{|}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Specif}{existT}{\coqdocconstructor{existT}}
\coqdocvar{n} \coqdocvar{$\kappa$} \ensuremath{\Rightarrow}
\coqref{Rewriting.pred}{\coqdocdefinition{pred}} (\coqdocvariable{f}
\coqdocvariable{n}) \coqdocvariable{$\kappa$}\coqdoceol
\coqdocindent{10.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\end{coqdoccode}
\end{singlespace}
% TODO: we simplified this (mainly type inference helpers)

In an effort to prevent getting lost in a syntacical labyrinth, we define
the following notational shortcuts:

% TODO: keep an eye on placement of the table
% TODO: \coqdoc markup of these notations
{\renewcommand{\arraystretch}{1.1}
\renewcommand{\tabcolsep}{10pt}
\begin{tabular}{ll}
$\varphi[\iota]$ & location of $\varphi$ indexed by $\iota$\\
$\varphi[\iota]^\textsc{seq}$ & predecessor rewrite sequence of $\varphi$ indexed by $\iota$\\
$\varphi[\iota]^\textsc{stp}$ & step of $\varphi$ indexed by $\iota$\\
$\varphi[\iota]^\textsc{l}$ & source term of $\varphi[\iota]^\textsc{stp}$ (also target term
  of $\varphi[\iota]^\textsc{seq}$)\\
$\varphi[\iota]^\textsc{r}$ & target term of $\varphi[\iota]^\textsc{stp}$
\end{tabular}}

As an example, consider the graphical representation of a rewrite
sequence $\varphi$ of length $\omega + 2$ and its predecessor index
$\iota = \coqdocconstructor{inr} \; (\coqdocconstructor{inr} \;
\langle 4, \coqdocconstructor{inl}\rangle)$ in
Figure~\ref{fig:pred}. The initial part of length $\omega$ is
represented by a series of finite rewrite sequences, each extending on
the previous by one step. The sequence of terms $\{ t_1,t_2, t_3,
\ldots \}$ converges to the term $t_\omega$.
Here, $\varphi[\iota]^\textsc{seq}$ is a rewrite sequence from $t_1$ to
$t_3$ and $\varphi[\iota]^\textsc{stp}$ is a step from $t_3$ to
$t_4$.

\begin{figure}
\begin{center}
\begin{tikzpicture}
\input{figures/predecessor.tikz}
\end{tikzpicture}
\end{center}
\caption{Example of a rewrite sequence and predecessor
  index.}\label{fig:pred}
\end{figure}

% TODO: better wording for 'canceled out'?
% TODO: picture of this embedding behaviour?
Having a closer look at the order $\preceq$ on the Brouwer ordinals, we can
see that it really defines embeddings of their tree structures. This is due to
clause~\ref{def:order:succ} of Definition~\ref{def:order}. In this clause,
two occurrences of the $^+$ constructor (one in both ordinals) are cancelled
out against each other, but the positions of these occurences in their
respective ordinals do not necessarily correspond. Since all occurrences of
$^+$ are equal, this has no effect on the resulting relation.

% TODO: should we use the word 'iff'?
What this means for a translation of $\preceq$ to the domain of our
inductively defined rewrite sequences is that, indeed, we get an embedding
relation. We just have to make sure that in the
\coqref{Rewriting.Cons}{\coqdocconstructor{Cons}} case, we cancel out two
equivelent steps against each other.\footnote{Rewrite steps $\pi$ and $o$ are
  defined to be equivalent ($\pi \approx o$) if % TODO: equivalent vs equal
\begin{compactenum}
  \item they use the same rewrite rule $\rho$,
  \item their contexts are bisimilar and
  \item their substitutions agree on all variables in $\rho$.
\end{compactenum}}
We say that $\varphi$ is embedded in $\psi$ (written $\varphi
\sqsubseteq \psi$) if $\psi$ can be obtained from $\varphi$ by inserting
any number of steps in $\varphi$. We distinguish between inserting a step
\begin{inparaenum}[(i)]
  \item before the first step,
  \item after the last step and
  \item in between steps
\end{inparaenum}
in a rewrite sequence. Note that any steps inserted consecutively in between
steps necessarily form a cycle, because of typing constraints.
% TODO: is the wording good here (the three cases)?
% TODO: define cycle
% TODO: explaining image
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Inductive} \coqdef{Rewriting.embed}{embed}{$\sqsubseteq$}
: \ensuremath{\forall} \coqdocvar{s} \coqdocvar{t} \coqdocvar{u}
\coqdocvar{v}, \coqdocvariable{s}
\coqref{Rewriting.sequence}{$\twoheadrightarrow_\mathcal{R}$} \coqdocvariable{t}
$\rightarrow$ \coqdocvariable{u}
\coqref{Rewriting.sequence}{$\twoheadrightarrow_\mathcal{R}$} \coqdocvariable{v}
$\rightarrow$ \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|}
\coqdef{Rewriting.EmbedNil}{Embed\_Nil}{\coqdocconstructor{$\sqsubseteq_\text{Nil}$}}  :
\ensuremath{\forall} \coqdocvar{s} \coqdocvar{u} \coqdocvar{v} (\coqdocvar{$\psi$}
: \coqdocvariable{u} \coqref{Rewriting.sequence}{$\twoheadrightarrow_\mathcal{R}$}
\coqdocvariable{v}),\coqdoceol
\coqdocindent{9.50em}
\coqref{Rewriting.Nil}{\coqdocconstructor{Nil}} \coqdocvariable{s}
\coqref{Rewriting.embed}{$\sqsubseteq$} \coqdocvariable{$\psi$}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|}
\coqdef{Rewriting.EmbedCons}{Embed\_Cons}{\coqdocconstructor{$\sqsubseteq_\text{Cons}$}} :
\ensuremath{\forall} \coqdocvar{s} \coqdocvar{t} \coqdocvar{u} \coqdocvar{v}
(\coqdocvar{$\psi$}
: \coqdocvariable{u} \coqref{Rewriting.sequence}{$\twoheadrightarrow_\mathcal{R}$}
\coqdocvariable{v}) (\coqdocvar{$\iota$} :
\coqref{Rewriting.predtype}{\coqdocdefinition{pred\_type}}
\coqdocvariable{$\psi$})
(\coqdocvar{$\varphi$} : \coqdocvariable{s}
\coqref{Rewriting.sequence}{$\twoheadrightarrow_\mathcal{R}$}
\coqdocvariable{$\psi$}[\coqdocvariable{$\iota$}]$^\textsc{l}$)\coqdoceol
\coqdocindent{5.00em}
(\coqdocvar{$\pi$} :
\coqdocvariable{$\psi$}[\coqdocvariable{$\iota$}]$^\textsc{l}$
\coqref{Rewriting.step}{$\rightarrow_\mathcal{R}$}
\coqdocvariable{t}),\coqdoceol
\coqdocindent{9.50em}
\coqdocvariable{$\varphi$} \coqref{Rewriting.embed}{$\sqsubseteq$}
\coqdocvariable{$\psi$}[\coqdocvariable{$\iota$}]$^\textsc{seq}$
\ensuremath{\rightarrow}\coqdoceol
\coqdocindent{9.50em}
\coqdocvariable{$\pi$} $\approx$
\coqdocvariable{$\psi$}[\coqdocvariable{$\iota$}]$^\textsc{stp}$
\ensuremath{\rightarrow}\coqdoceol
\coqdocindent{9.50em}
\coqref{Rewriting.Cons}{\coqdocconstructor{Cons}}
\coqdocvariable{$\varphi$} \coqdocvariable{$\pi$}
\coqref{Rewriting.embed}{$\sqsubseteq$}
\coqdocvariable{$\psi$}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|}
\coqdef{Rewriting.EmbedLim}{Embed\_Lim}{\coqdocconstructor{$\sqsubseteq_\text{Lim}$}}  :
\ensuremath{\forall} \coqdocvar{s} \coqdocvar{t} \coqdocvar{u} \coqdocvar{v}
(\coqdocvar{ts} :
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}}
\ensuremath{\rightarrow} \coqref{Term.term}{\coqdocinductive{term}})
(\coqdocvar{f} : \ensuremath{\forall} \coqdocvar{n},
\coqdocvariable{s}
\coqref{Rewriting.sequence}{$\twoheadrightarrow_\mathcal{R}$}
\coqdocvariable{ts} \coqdocvariable{n})\coqdoceol
\coqdocindent{5.00em}
(\coqdocvar{c} :
\coqref{Rewriting.converges}{\coqdocdefinition{converges}} \coqdocvariable{ts}
\coqdocvar{t}) (\coqdocvar{$\psi$} : \coqdocvar{u}
\coqref{Rewriting.sequence}{$\twoheadrightarrow_\mathcal{R}$}
\coqdocvar{v}),\coqdoceol
\coqdocindent{9.50em}
(\ensuremath{\forall} \coqdocvar{n}, (\coqdocvariable{f} \coqdocvariable{n})
\coqref{Rewriting.embed}{$\sqsubseteq$} \coqdocvariable{$\psi$})
\ensuremath{\rightarrow}\coqdoceol
\coqdocindent{9.50em}
\coqref{Rewriting.Lim}{\coqdocconstructor{Lim}} \coqdocvariable{f}
\coqdocvariable{c} \coqref{Rewriting.embed}{$\sqsubseteq$}
\coqdocvariable{$\psi$}.\coqdoceol
\end{coqdoccode}
\end{singlespace}
% TODO: (f n) without ()
% TODO: say what implicit/explicit arguments for cons and lim are

Strict embedding relation. It really expands after the last step!
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Definition}
\coqdef{Rewriting.embedstrict}{embed\_strict}{$\sqsubset$}
\coqdocvar{s} \coqdocvar{t} \coqdocvar{u} \coqdocvar{v}
(\coqdocvar{$\varphi$} : \coqdocvariable{s}
\coqref{Rewriting.sequence}{$\twoheadrightarrow_\mathcal{R}$}
\coqdocvariable{t},
\coqdocvar{$\psi$} :
\coqdocvariable{u}
\coqref{Rewriting.sequence}{$\twoheadrightarrow_\mathcal{R}$}
\coqdocvariable{v}) := \ensuremath{\exists} \coqdocvar{$\iota$},
\coqdocvariable{$\varphi$} $\sqsubseteq$
\coqdocvariable{$\psi$}[\coqdocvariable{$\iota$}]$^\textsc{seq}$.\coqdoceol
\end{coqdoccode}
\end{singlespace}


\subsection{Well-formed Rewrite Sequences and Convergence}\label{sub:wf}

On \coqref{Ordinal.ord}{\coqdocinductive{ord}} we defined the
\coqref{WfOrdinal.wf}{\coqdocdefinition{wf}} property to rule out a certain
class of ordinal representations. This issue translates directly to our
inductive representation of rewrite sequences.

$\sqsubset$ turns out to be satisfying for our present purposes.

TODO: think harder about what it means to have an embedding relation instead
of a prefix relation. Vincent said this about it:
\begin{quote}
Overigens bedachten dat het in principe niet heel erg is $\sqsubseteq$ te
definieren voor reducties zoals voor ordinalen. alleen zie je dan het meer een
notie van embedding/deelreductie ipv een notie van prefix geeft, maar ook daar
kun je denkelijk goed mee werken.

\ldots

als je een stuk invoegt in het midden in sigma moet dat noodzakelijkerwijs,
vanwege de constraints op begin-en eindpunten, een reductie cykel zijn. ik zou
verwachten dat dat uiteindelijk een goede notie van ordening (goede reducties)
oplevert (``de cykels doen er niet toe voor convergente rijen, en kun je
weglaten bij compressie''), die natuurlijk niet overeenkomt, ook niet in het
eindige geval met de prefix notie; het is deelwoord, of (op reductie rijtjes
als bomen) deelboom (en niet boom-factor).
\end{quote}

\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{Rewriting.wf}{wf}{\coqdocdefinition{wf}}
\coqdocvar{s} \coqdocvar{t}
(\coqdocvar{$\varphi$} : \coqdocvariable{s}
\coqref{Rewriting.sequence}{$\twoheadrightarrow_\mathcal{R}$}
\coqdocvariable{t}) : \coqdockw{Prop}
:=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{$\varphi$} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{Rewriting.Nil}{\coqdocconstructor{Nil}}
\coqdocvar{\_}          \ensuremath{\Rightarrow}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Logic}{True}{\coqdocinductive{True}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{Rewriting.Cons}{\coqdocconstructor{Cons}}
\coqdocvar{\_} \coqdocvar{\_} \coqdocvar{$\psi$} \coqdocvar{\_}
\coqdocvar{\_} \ensuremath{\Rightarrow}
\coqref{Rewriting.wf}{\coqdocdefinition{wf}}
\coqdocvariable{\coqdocvariable{$\psi$}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{Rewriting.Lim}{\coqdocconstructor{Lim}}
\coqdocvar{\_} \coqdocvar{\_} \coqdocvar{f} \coqdocvar{\_}
\coqdocvar{\_}  \ensuremath{\Rightarrow}
(\ensuremath{\forall} \coqdocvar{n},
\coqref{Rewriting.wf}{\coqdocdefinition{wf}} (\coqdocvariable{f}
\coqdocvariable{n})) \ensuremath{\land}
\ensuremath{\forall} \coqdocvar{n} \coqdocvar{m}, \coqdocvariable{n}
< \coqdocvariable{m} \ensuremath{\rightarrow} \coqdocvariable{f}
\coqdocvariable{n}
\coqref{Rewriting.embedstrict}{$\sqsubset$}
\coqdocvariable{f} \coqdocvariable{m}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\end{coqdoccode}
\end{singlespace}


\section{Properties of Terms and TRSs}

We define some predicates on terms and TRSs. Again, let throughout
this section $\mathcal{R}$ be a fixed TRS.

We work with a somewhat relaxed definition of critical pairs. First,
we do not require the common instance to be a most general
one. Second, the substitution $\sigma$ might not be minimal and might
not introduce only fresh variables
(cf.\ Definition~\ref{def:overlap}). The effect of this variation is
that for every critical pair, we have a series of critical pairs by
this relaxed definition. This is precise enough for our present
purposes, however, since it has no effect on questions such as
\emph{`are there critical pairs?'} or \emph{`are all critical pairs
  trivial?'}.
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Definition}
\coqdef{Rewriting.criticalpair}{critical\_pair}{\coqdocdefinition{critical\_pair}}
(\coqdocvar{$\mathcal{R}$} : \coqdocdefinition{trs})
(\coqdocvar{t$_1$} \coqdocvar{t$_2$} :
\coqref{Term.term}{\coqdocinductive{term}}) : \coqdockw{Prop}
:=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{\exists} \coqdocvar{$\rho_1$} :
\coqdocrecord{rule}, \ensuremath{\exists}
\coqdocvar{$\rho_2$} :
\coqdocrecord{rule},
\ensuremath{\exists} \coqdocvar{p} :
\coqdocabbreviation{position},
\ensuremath{\exists} \coqdocvar{$\sigma$},
\ensuremath{\exists} \coqdocvar{$\tau$},\coqdoceol
\coqdocindent{3.00em}
\coqdocvariable{$\rho_1$} \coqdocdefinition{$\in$}
\coqdocvariable{$\mathcal{R}$}
\ensuremath{\land}
\coqdocvariable{$\rho_2$} \coqdocdefinition{$\in$}
\coqdocvar{$\mathcal{R}$} \ensuremath{\land}
(\coqdocvariable{$\rho_1$} = \coqdocvariable{$\rho_2$}
\ensuremath{\rightarrow}
\coqdocvariable{p} \ensuremath{\not=}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nil}{\coqdocconstructor{nil}})
\ensuremath{\land}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{match}
\coqref{Term.subterm}{\coqdocdefinition{subterm}} (\coqref{Rewriting.lhs}{\coqdocprojection{lhs}}
\coqdocvariable{$\rho_1$}) \coqdocvariable{p},
\coqref{Context.dig}{\coqdocdefinition{dig}} (\coqref{Rewriting.lhs}{\coqdocprojection{lhs}}
\coqdocvariable{$\rho_1$})$^{\coqdocvariable{$\sigma$}}$ \coqdocvariable{p}
\coqdockw{with}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{|}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{Some}{\coqdocconstructor{Some}}
\coqdocvar{s},
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{Some}{\coqdocconstructor{Some}}
\coqdocvar{c} \ensuremath{\Rightarrow}
\coqdocdefinition{is\_var} \coqdocvariable{s} =
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{false}{\coqdocconstructor{false}}
\ensuremath{\land}
\coqdocvariable{s}$^{\coqdocvariable{$\sigma$}}$ \coqref{TermEquality.termbis}{$\sim$}
(\coqref{Rewriting.lhs}{\coqdocprojection{lhs}}
\coqdocvariable{$\rho_2$})$^{\coqdocvariable{$\tau$}}$
\ensuremath{\land}\coqdoceol
\coqdocindent{12.00em}
\coqdocvariable{t$_1$} \coqref{TermEquality.termbis}{$\sim$}
\coqdocvariable{c}[(\coqref{Rewriting.rhs}{\coqdocprojection{rhs}}
\coqdocvariable{$\rho_2$})$^{\coqdocvariable{$\tau$}}$]
\ensuremath{\land}
\coqdocvariable{t$_2$} \coqref{TermEquality.termbis}{$\sim$}
(\coqref{Rewriting.rhs}{\coqdocprojection{rhs}}
\coqdocvariable{$\rho_1$})$^{\coqdocvariable{$\sigma$}}$\coqdoceol
\coqdocindent{3.00em}
\ensuremath{|} \coqdocvar{\_}, \coqdocvar{\_}
\ensuremath{\Rightarrow}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Logic}{False}{\coqdocinductive{False}}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{end}.\coqdoceol
\end{coqdoccode}
\end{singlespace}
Now we can in a straightforward manner define the properties of
orthogonality and weak orhogonality.
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Definition}
\coqdef{Rewriting.orthogonal}{orthogonal}{\coqdocdefinition{orthogonal}} (\coqdocvar{$\mathcal{R}$} :
\coqdocdefinition{trs})
: \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqdocdefinition{trs\_left\_linear} % TODO: maybe define trs_left_linear and link to it
\coqdocvariable{$\mathcal{R}$} \ensuremath{\land}
\ensuremath{\forall} \coqdocvar{t$_1$} \coqdocvar{t$_2$},
\ensuremath{\lnot}
\coqref{Rewriting.criticalpair}{\coqdocdefinition{critical\_pair}}
\coqdocvariable{t$_1$} \coqdocvariable{t$_2$}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition}
\coqdef{Rewriting.weaklyorthogonal}{weakly\_orthogonal}{\coqdocdefinition{weakly\_orthogonal}} (\coqdocvar{$\mathcal{R}$} :
\coqdocdefinition{trs})
: \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqdocdefinition{trs\_left\_linear}
\coqdocvariable{$\mathcal{R}$} \ensuremath{\land}
\ensuremath{\forall} \coqdocvar{t$_1$} \coqdocvar{t$_2$},
\coqref{Rewriting.criticalpair}{\coqdocdefinition{critical\_pair}}
\coqdocvariable{t$_1$} \coqdocvariable{t$_2$} \ensuremath{\rightarrow}
\coqdocvariable{t$_1$} \coqref{TermEquality.termbis}{$\sim$} \coqdocvariable{t$_2$}.\coqdoceol
\end{coqdoccode}
\end{singlespace}

%TODO: some text here?

\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Definition}
\coqdef{Rewriting.normalform}{normal\_form}{\coqdocdefinition{normal\_form}}
\coqdocvar{t} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{\lnot} \ensuremath{\exists} \coqdocvar{c} : \coqref{Context.context}{\coqdocinductive{context}},
\ensuremath{\exists} \coqdocvar{$\rho$} : \coqdocrecord{rule},
\ensuremath{\exists} \coqdocvar{$\sigma$} :
\coqdocdefinition{substitution},
\coqdocvariable{$\rho$}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Lists.List}{In}{\coqdocdefinition{$\in$}}
\coqdocvar{$\mathcal{R}$} \ensuremath{\land}
\coqdocvariable{c}[(\coqref{Rewriting.lhs}{\coqdocprojection{lhs}}
\coqdocvariable{r})\coqdocvariable{$^\sigma$}] \coqref{TermEquality.termbis}{$\sim$}
\coqdocvariable{t}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition}
\coqdef{Rewriting.uniquenormalforms}{unique\_normal\_forms}{\coqdocdefinition{unique\_normal\_forms}}
: \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{\forall} \coqdocvar{s} \coqdocvar{t} \coqdocvar{u}
(\coqdocvar{$\phi$} : \coqdocvariable{s} \coqref{Rewriting.sequence}{$\twoheadrightarrow_\mathcal{R}$} \coqdocvariable{t})
(\coqdocvar{$\psi$} : \coqdocvariable{s} \coqref{Rewriting.sequence}{$\twoheadrightarrow_\mathcal{R}$} \coqdocvariable{u}),\coqdoceol
\coqdocindent{2.00em}
\coqref{Rewriting.wf}{\coqdocdefinition{wf}} \coqdocvariable{$\phi$}
\ensuremath{\rightarrow}
\coqref{Rewriting.wf}{\coqdocdefinition{wf}} \coqdocvariable{$\psi$}
\ensuremath{\rightarrow}
\coqref{Rewriting.normalform}{\coqdocdefinition{normal\_form}}
\coqdocvariable{t} \ensuremath{\rightarrow}
\coqref{Rewriting.normalform}{\coqdocdefinition{normal\_form}}
\coqdocvariable{u} \ensuremath{\rightarrow}
\coqdocvariable{t} \coqref{TermEquality.termbis}{$\sim$} \coqdocvariable{u}.\coqdoceol
\end{coqdoccode}
\end{singlespace}
Note that the
\coqref{Rewriting.uniquenormalforms}{\coqdocdefinition{unique\_normal\_forms}}
definition is only a translation of the $UN^\twoheadrightarrow$
property, not of the more general $UN^\infty$ property (see also
Definition~\ref{def:normalization}).

% TODO: note in chapter unwo that we proved ~UN^\infty with ~UN^->
