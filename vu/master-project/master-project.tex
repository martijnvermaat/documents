\documentclass[11pt,oneside,a4paper,final]{report}
\usepackage[english]{babel}


% Use some subversion information
\usepackage{svn-multi}
\svnid{$Id$}


% Use scalable, PostScript Type 1 versions of the Computer Modern fonts.
\usepackage{type1cm}

% How to encode fonts.
\usepackage[T1]{fontenc}

% Text encoding to take for data input stream. I.e. the text we write in.
\usepackage[latin1]{inputenc}

\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}

% Times
%\usepackage{txfonts}
%\usepackage{times}

% Times
%\usepackage{mathptmx}

% Palatino
%\usepackage{pxfonts}
%\usepackage{palatino}

% Palatino
%\usepackage[osf,sc]{mathpazo}

% TeX Gyre Pagella (like Palatino)
%\usepackage{qpxmath}
%\usepackage{tgpagella}

% TeX Gyre Termes (like Times)
\usepackage{qtxmath}
\usepackage{tgtermes}

% txtt for tt
\renewcommand{\ttdefault}{txtt}

% Computer Modern for tt
%\renewcommand{\ttdefault}{cmtt}

% Helvetica for sans serif
%\renewcommand{\sfdefault}{qhv}
\usepackage[scaled=0.95]{helvet}

% Use semi-bold instead of bold
%\renewcommand{\bfdefault}{sb}


\usepackage{a4}

% Tweak the inner margin to align all text as nice as possible
%\usepackage[inner=3.83cm]{geometry}

%\raggedbottom

% Section numbering in margin
%\usepackage{sectsty}
%\makeatletter\def\@seccntformat#1{\protect\makebox[0pt][r]{\csname
%    the#1\endcsname\hspace{12pt}}}\makeatother

% Dutch style of paragraph formatting, i.e. no indents.
%\setlength{\parskip}{1.3ex plus 0.2ex minus 0.2ex}
\setlength\parskip{\medskipamount}
%\setlength\parskip{\bigskipamount}
\setlength{\parindent}{0pt}

% Linespacing
\usepackage[onehalfspacing]{setspace}
%\onehalfspacing
%\doublespacing


% Natbib for the bibliography, always. sort&compress will make i.e. [1-5,7].
%\usepackage[square,numbers,sort&compress]{natbib}
%\usepackage[authoryear,sort]{natbib}
\usepackage[numbers]{natbib}
\setlength{\bibhang}{0ex}


\usepackage{xspace}

\newcommand{\name}[1]{\textsc{#1}\xspace}
\def\Coq{\name{Coq}}


\usepackage{amsthm}

\theoremstyle{definition}
\newtheorem{definition}{Definition}


\usepackage{paralist}
\setdefaultenum{i.}{a.}{}{}


\usepackage[color]{coqdoc}
\setlength{\coqdocbaseindent}{0.7em}


\hypersetup{
  colorlinks,
  citecolor=black,
  filecolor=black,
  linkcolor=black,
  urlcolor=black,
  pdfauthor={Martijn Vermaat},
  pdftitle={Infinitary Rewriting in Coq},
  pdfsubject={A Mechanic Formalisation of Infinitary Rewriting in the Coq
    Proof Assistant},
  pdfkeywords={brouwer ordinals, infinitary rewriting, verification, coq,
    functional programming},
  draft=false}
%\usepackage[figure]{hypcap}


\title{Infinitary Rewriting in \Coq}

\author{Martijn Vermaat}
\date{MSc. Thesis (\emph{draft r\svnrev})}
% TODO: good title page
% Thesis submitted for the degree of Master of Science by research at the VU
% University Amsterdam
% by Martijn Vermaat
% August 2010


\begin{document}


\maketitle


\begin{abstract}
  Abstract describing the thesis in a few sentences.
\end{abstract}


\chapter*{Preamble}

Bla.


\section*{Acknowledgements}

Joint work with Dimitri Hendriks.

Adam Chlipala for the recursive vector type and other hints on
Coq-club. Matthieu Sozeau for help with the dependent destruction
tactic. Peter Hancock for his notes on Brouwer ordinals. J\"urg Endrullis and
Vincent van Oostrom for discussion of the implementation. Femke van
Raamsdonk. Roel de Vrijer.


\chapter*{Notation Glossary}

This chapter is used during writing, probably won't be in final thesis. Note
that some notations are used more than once, but with roughly comparable
meaning.

{\renewcommand{\arraystretch}{1.1}
\renewcommand{\tabcolsep}{0.4cm}
\begin{tabular}{l l p{6.1cm}}
Thesis & \Coq & Meaning\\
\hline
\multicolumn{3}{l}{\bf Ordinals}\\
$I(\alpha)$ & \texttt{pd\_type(alpha)} & predecessor indices of $\alpha$\\
$\alpha[i]$ & \texttt{alpha[i]} & predecessor of $\alpha$ indexed by $i$\\
$\alpha \preceq \beta$ & \texttt{alpha <= beta} & non-strict order\\
$\alpha \prec \beta$ & \texttt{alpha < beta} & strict order\\
$\alpha \simeq \beta$ & \texttt{alpha == beta} & extensional equality\\
\multicolumn{3}{l}{\bf Terms}\\
$s \equiv t$ & \texttt{s = t} & syntactical and \Coq equality \small{(not really the same thing)}\\
$s \sim t$ & \texttt{s [\textasciitilde] t} & bisimilarity\\
$s \doteq_n t$ & \texttt{term\_eq\_up\_to n s t} & pointwise equality up to depth $n$\\ % \eqcirc_n
$s \doteq t$ & \texttt{s [=] t} & pointwise equality\\ % \eqcirc
\multicolumn{3}{l}{\bf Rewriting Sequences}\\
$\rho \rightarrow \tau$ & \texttt{r [>] q} & $\rho$ rewrites to
$\tau$ in one step\\
$\rho \twoheadrightarrow \tau$ & \texttt{r ->{}> q} & $\rho$ rewrites to
$\tau$\\
$I(\rho)$ & \texttt{pred\_type(r)} & predecessor indices of $\rho$\\
$\rho[i]$ & \texttt{r[i]} & predecessor location of $\rho$ indexed by $i$\\
$\rho[i]^\textsc{seq}$ & \texttt{r[seq i]} & predecessor sequence of $\rho$ indexed by $i$\\
$\rho[i]^\textsc{stp}$ & \texttt{r[stp i]} & predecessor step of $\rho$ indexed by $i$\\
$\rho[i]^\textsc{l}$ & \texttt{r[1 i]} & left predecessor term of $\rho$ indexed by $i$\\
$\rho[i]^\textsc{r}$ & \texttt{r[2 i]} & right predecessor term of $\rho$ indexed by $i$\\
$\rho \sqsubseteq \tau$ & \texttt{r <= q} & $\rho$ is embedded in $\tau$\\
$\rho \sqsubset \tau$ & \texttt{r < q} & $\rho$ is strictly embedded in $\tau$\\
\end{tabular}}


\tableofcontents


\chapter{Introduction}

Infinitary term rewriting, the \Coq proof assistant, etc.


\section*{Outline}

% TODO: this is no longer correct (no finitary rewriting)
In Chapter~\ref{chap:itr} we introduce the theory of infinitary term
rewriting. To this end we first give a quick summary of traditional (finitary)
term rewriting and an introduction to the mathematical concept of ordinal
numbers.

The goal of Chapter~\ref{chap:formalization} is to introduce our formalization
of infinitary term rewriting in the \Coq proof assistant. We first discuss this
proof assistant and then review the main parts of our development.

Our formalization was used to prove that in infinitary rewriting, weak
orthogonality does not imply unique normal forms. This application is
discussed in Chapter~\ref{chap:unwo}.

Finally, in Chapter~\ref{chap:discussion} we discus our results and draw
conclusions.


\chapter{Infinitary Term Rewriting}\label{chap:itr}

Before we can study infinitary rewriting, we must introduce ordinal numbers.


\section{Ordinal Numbers}

% ordinals are origininally by Cantor

Ordinal numbers (ordinals for short) are an extension of the natural numbers
with transfinite objects. Indeed, the finite ordinals are just the natural
numbers. The smallest infinite ordinal is called $\omega$ and following
$\omega$ we have $\omega + 1$, $\omega + 2$, \ldots, $\omega \times 2$. Then
there are the ordinals $\omega \times 2 + 1$, $\omega \times 2 + 2$, \ldots,
$\omega \times 3$. Some other (still relatively small) ordinals are:
\begin{displaymath}
  \omega^2 \qquad
  \omega^\omega \qquad
  \omega^{\omega^2} \qquad
  \omega^{\omega^\omega} \qquad
  \omega^{\omega^{\omega^{\ldots}}} = \epsilon_0 % TODO: \iddots or \adots
\end{displaymath}
Note that this is all just notation, we have not yet defined a representation
for ordinals and what $+$ and $\times$ are.

In set theory, ordinals are usually represented by hereditarily transitive
sets. Zero corresponds to the empty set $\emptyset$, one to the singleton $\{
\emptyset \}$ and so on, and $\omega$ is represented by $\{ \emptyset, \{
\emptyset \}, \{ \emptyset, \{ \emptyset \} \} , \ldots \}$. Now $\in$
constitutes a well-founded total order on the ordinals.

We abbreviate $\alpha \cup \{ \alpha \}$ by $\alpha^+$ (corresponding to the
successor function) and say that $\alpha$ is a successor ordinal if $\alpha =
\beta^+$ for some ordinal $\beta$. If $\alpha$ is not a successor ordinal and
$\alpha \neq \emptyset$, it is called a limit ordinal. So an ordinal can
be either zero, a successor ordinal, or a limit ordinal.

From now on, we make no distinction between an ordinal and its set-theoretic
representation (e.g.\ between $0$ and $\emptyset$). Examples of successor
ordinals are $4$, $\omega + 7$  and $\omega^{\omega \times 2} + 1$. Examples
of limit ordinals are $\omega$ and $\omega \times 3$.

% TODO: we also make no distinction between the ordinal and its brouwer
% ordinal
% TODO: i use + en x all the time, while not explaining their meaning
% TODO: explain we use \lambda for limit ordinals

One can do arithmetics on ordinals much like we do arithmetics on natural
numbers. For example, addition can be defined by recursion on the right
argument:
\begin{align*}
  \alpha + 0       &= \alpha\\
  \alpha + \beta^+ &= (\alpha + \beta)^+\\
  \alpha + \lambda &= \bigcup \{ \alpha + \gamma \; | \; \gamma \in \lambda \}
\end{align*}


\subsection{Brouwer Ordinals}\label{sub:brouwer}

% TODO: should we mention the name tree ordinals?
The Brouwer ordinals (also known as tree ordinals) are a constructive
representation of the countable ordinals as countably branching well-founded
trees. Their inductive definition uses constructors $0$ (zero), $^+$
(successor) and $\sqcup$ (limit).

The $\sqcup$ constructor has type $(\mathbb{N} \rightarrow \Omega) \rightarrow
\Omega$, but for our convenience we write $\sqcup_i \cdots i \cdots$ instead
of $\sqcup (\lambda i . \cdots i \cdots)$. Sometimes we explicitely enumerate
the function, writing for example $\sqcup \{ \alpha_1, \alpha_2, \alpha_3,
\ldots \}$.

\begin{definition}[Ordinals]\label{def:ordinals}
The set of \emph{Brouwer ordinals} (ordinals) $\Omega$ is defined by
induction:
\begin{compactenum}
  \item
    $0 \in \Omega$.
  \item
    If $\alpha \in \Omega$, then $\alpha^+ \in \Omega$.
  \item
    If $\alpha_i \in \Omega$ for all $i \in \mathbb{N}$, then $\sqcup_i
    \alpha_i \in \Omega$.
\end{compactenum}
\end{definition}

Now zero is represented by $0$, a successor ordinal $\alpha +1$ is represented
by $\alpha^+$ and a limit ordinal $\lambda$ is represented by $\sqcup_i
\alpha_i$ if $\lambda$ is the least upper bound of the sequence $\alpha_1,
\alpha_2, \alpha_3, \ldots$. % TODO: strict or unstrict upper bound
Again, we identify ordinals and their representation as Brouwer ordinal.

Some ordinals have no unique representation as Brouwer ordinal. Consider for
example the limit ordinals $\sqcup_i i + 3$ and $\sqcup_i i \times 2$. Both
are representations of $\omega$ and a meaningful order relation would have to
position them at the same rank.

A more intricate issue is what to make of ordinals such as $\sqcup \{ 3, 3, 3,
\ldots \}$. In spirit of the intuition given above it represents $3$ ($4$),
that being the non-strict (strict) upper bound of $3, 3, 3, \ldots$.
% TODO: this makes it undecidable to compare an ordinal to 0 or 3
In practice, we might like to exclude such representations and require that
$\sqcup_i \alpha_i$ always represents a limit ordinal. This can be done by
imposing a strict monotonicity property on the limit sequences, but some order
relation on the Brouwer ordinals is needed for that.

% TODO: much of the following is taken from Hancock, but i think we cannot
% cite that paper. however, we must acknowledge this in some way

Before we can define an extensional order relation on $\Omega$, we define a
structural strict order relation as follows.

\begin{definition}[Predecessor indices]
% TODO: include I(a) for a in emph
The set-valued function $I$ defines the \emph{predecessor indices} $I(\alpha)$
for $\alpha$ by recursion on $\alpha$:
\begin{align*}
  I(0)                 &= \emptyset \\
  I(\alpha^+)          &= I(\alpha)^? \\
  I(\sqcup_i \alpha_i) &= (\Sigma n \in \mathbb{N}) \; I(\alpha_n)
\end{align*}
\end{definition}

% TODO: investigate what happens if we take I(lim f) to be just N

By $A^?$ we mean the option type over $A$, or equivalently the disjoint sum
$1 + A$ of the unit type $1$ and $A$. We use \textsc{none} and \textsc{some
  $a$} (for $a \in A$) as constructors of $A^?$. Note that the set $I(0)$ of
predecessor indices for $0$ is uninhabited.

\begin{definition}[Predecessor]
The function $\_[\_] : (\prod \alpha : \Omega) \; I(\alpha) \rightarrow
\Omega$ defines the \emph{predecessor} $\alpha[i]$ of $\alpha$ indexed by $i$
recursively on $\alpha$:
\begin{align*}
  \alpha^+[\textsc{none}]                 &= \alpha \\
  \alpha^+[\textsc{some $i$}]             &= \alpha[i] \\
  \sqcup_i \alpha_i[\langle n, i \rangle] &= \alpha_n[i]
\end{align*}
\end{definition}

% TODO: explain what I and _[_] mean

This structural predecessor function can be viewed as defining a `subtree'
partial order on $\Omega$. With it we are ready to define an extensional
non-strict order relation on $\Omega$ that classifies ordinals by rank.

% TODO: note <= infix notation
% TODO: or use the set-theoretic definitions from hancock?
\begin{definition}[Order]\label{def:order}
We define the \emph{order} $\preceq$ as a binary relation on $\Omega$ by
induction on the first argument (and write $\alpha \preceq \beta$ for $\langle
\alpha, \beta \rangle \in \; \preceq$):
\begin{compactenum}
  \item
    $0 \preceq \beta$ for every ordinal $\beta \in \Omega$.
  \item
    For all $\alpha, \beta \in \Omega$ and $i \in I(\beta)$, if $\alpha
    \preceq \beta[i]$ then $\alpha^+ \preceq \beta$.
  \item
    For all $\alpha_1, \alpha_2, \alpha_3, \ldots, \beta \in \Omega$, if
    $\alpha_n \preceq \beta$ for all $n \in \mathbb{N}$, then $\sqcup_i
    \alpha_i \preceq \beta$.
\end{compactenum}
\end{definition}

Using this order, we can define two other useful binary relations on
$\Omega$. First, the extensional equality $\alpha \simeq \beta$ by the
conjunction of $\alpha \preceq \beta$ and $\beta \preceq \alpha$. Second, the
extensional strict order $\alpha \prec \beta$ if $\alpha \preceq \beta[i]$ for
some $i \in I(\beta)$.


\section{Term Rewriting}\label{sec:trs}

% TODO: Short motivation for term rewriting, summation of its applications and
% aspects of rewriting that are studied.

We give a short introduction to the basic notions of infinitary term
rewriting. For a more in-depth treatment of the theory of term rewriting,
consult~\cite{terese-03} (TODO: infinitary see chapter 12, others). In this
section, we use definitions and notations from Terese.

% TODO: rewrite this statement (and perhaps we never mention finitary
% rewriting)
From now on, we drop the `infinitary' from infinitary rewriting and
explicitely say so if we mean finitary rewriting.


\subsection{Definition of a TRS}

\begin{definition}[Signature]
A \emph{signature} $\Sigma$ is a non-empty set of \emph{function symbols} $f,
g, \ldots$. Each function symbol $f$ has a fixed natural number $\#_f$, which
we call its \emph{arity}. A function symbol with arity $0$ is also called a
\emph{constant}.
\end{definition}

\begin{definition}[Term]
The set of \emph{terms} $Ter_\Sigma^\infty(X)$ over a signature $\Sigma$ and a
set of variables $X = \{x, y, \ldots\}$ is defined by co-induction:
\begin{compactenum}
  \item
    $x \in Ter_\Sigma^\infty(X)$ for every variable $x \in X$.
  \item
    If $f \in \Sigma$ is a function symbol with arity $n$ and $t_1, \ldots,
    t_n \in Ter_\Sigma^\infty(X)$, then $f(t_1, \ldots, t_n) \in
    Ter_\Sigma^\infty(X)$.
\end{compactenum}
\end{definition}

The terms $t_i$ are called the \emph{arguments} of $f(t_1, \ldots, t_n)$ and
the symbol $f$ the \emph{root}. By $Var(t)$ we denote the set of variables
occuring in $t$, and $t$ is \emph{closed} if $Var(t) = \emptyset$. If no
variable occurs more than once in $t$, we say $t$ is \emph{linear}.

Often, the set of variables $X$ is left implicit and $Ter_\Sigma^\infty(X)$ is
denoted simply by $Ter_\Sigma^\infty$. By the set of \emph{finite terms}
$Ter_\Sigma$ we mean the subset of well-founded terms of $Ter_\Sigma^\infty$.

\begin{definition}[Rewrite rule]
  A \emph{rewrite rule} $\rho$ for a signature $\Sigma$ is a pair $\langle l,
  r \rangle$ of finite terms in $Ter_\Sigma$ (written $\rho : l \rightarrow
  r$). We restrict ourselves to rewrite rules where $l$ is not a variable and
  $Var(r) \subseteq Var(l)$.
\end{definition}

\begin{definition}[TRS]
A \emph{term rewriting system} (TRS) $\mathcal{R}$ is a pair $\langle \Sigma,
R \rangle$ of a signature $\Sigma$ and a set of rewrite rules $R$ on
$\Sigma$.
\end{definition}

In contrast to Terese, we do not define contexts as terms over an extended
signature. Instead, a direct inductive definition is given since this is how
we defined the notion of context in our \Coq development (the main reason being
that we choose not to consider multi-hole contexts).
% TODO: maybe this needs more explaining

\begin{definition}[Context]
The set of (one-hole) \emph{contexts} $Ctx_\Sigma^\infty$ over a signature
$\Sigma$ is defined by induction:
\begin{compactenum}
  \item
    $\Box \in Ctx_\Sigma^\infty$.
  \item
    If $f \in \Sigma$ is a function symbol with arity $n + 1$, $C \in
    Ctx_\Sigma^\infty$, and $t_1, \ldots, t_n \in Ter_\Sigma^\infty$, then for
    any $m \leq n + 1$, $f(t_1, \ldots, t_m, C, t_{m+2}, \ldots, t_{n}) \in
    Ctx_\Sigma^\infty$.
\end{compactenum}
\end{definition}

Thus every context $C$ has exactly one occurence of the symbol $\Box$, called
its \emph{hole}. By the term $C[t]$ we mean the result of replacing the hole
of $C$ by $t$.

\begin{definition}[Substitution]
% TODO: now we only generalize to finite terms
Given a signature $\Sigma$ and a set of variables $X$, a \emph{substitution}
$\sigma$ is a mapping from $X$ to $Ter_\Sigma^\infty(X)$. It can be
generalized to a mapping $\bar{\sigma} : Ter_\Sigma(X) \rightarrow
Ter_\Sigma^\infty(X)$ recursively:
\begin{align*}
  \bar{\sigma}(x) &= \sigma(x)\\
  \bar{\sigma}(f(t_1, \ldots, t_n)) &= f(\bar{\sigma}(t_1), \ldots,
  \bar{\sigma}(t_n))
\end{align*}
\end{definition}

Since $\bar{\sigma}$ is completely defined by $\sigma$ we refer to both as
`the' substitution $\sigma$. The notation $[x_1, \ldots, x_n := s_1, \ldots,
  s_n]$ is used for the substitution $\sigma$ with $\sigma(x_i) = s_i$ for $1
\leq i \leq n$ and $\sigma(y) = y$ for all other $y$. Applying a substitution
$\sigma$ to a term $t$ is usually written $t^\sigma$.
% TODO: use some syntactical equality symbol and define = to be
% convertibility?

If we view a rewriting rule $\rho : l \rightarrow r$ as a \emph{scheme}, an
\emph{instance} of $\rho$ can be obtained by applying a substitution
$\sigma$. The result is the \emph{atomic} rewrite step $l^\sigma
\rightarrow_\rho r^\sigma$. We call $l^\sigma$ a ($\rho$-) \emph{redex} and
$r^\sigma$ its \emph{contractum}.

\begin{definition}[Rewrite step]
A \emph{rewrite step} $C[l^\sigma] \rightarrow_\rho C[r^\sigma]$ according to
$\rho$ consists of a rewrite rule $\rho : l \rightarrow r$, a substitution
$\sigma$ and a context $C$.
\end{definition}

We call $\rightarrow_\rho$ the \emph{one-step rewriting relation} generated by
$\rho$. The one-step rewriting relation $\rightarrow$ of a TRS $\mathcal{R}$
with rewrite rules $R$ is defined as the union of $\{ \rightarrow_\rho | \;
\rho \in R \}$.

TODO: infinite rewriting sequences, convergence definitions.


\subsection{Orthogonality}

TODO: Normal forms, left-linearity, critical pairs, etc.


\chapter{A Mechanic Formalization}\label{chap:formalization}

TODO: introduction.


\section{The \Coq Proof Assistant}

TODO: text

TODO: some notes about code listings. coq has implicit arguments. we aim for
brevity.


\section{Ordinal Numbers}

In the theory of infinitary rewriting, the lengths of rewriting sequences play
a central role. Therefore, any reasonable formalization of infinitary
rewriting ought to have some notion of ordinal numbers.

We define the ordinal numbers using the representation of Brouwer
ordinals (cf.~Definition~\ref{def:ordinals}):
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Inductive} \coqdef{Ordinal.ord}{ord}{\coqdocinductive{ord}} :
\coqdockw{Set} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{Ordinal.Zero}{Zero}{\coqdocconstructor{Zero}}  :
\coqref{Ordinal.ord}{\coqdocinductive{ord}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{Ordinal.Succ}{Succ}{\coqdocconstructor{Succ}}  :
\coqref{Ordinal.ord}{\coqdocinductive{ord}} \ensuremath{\rightarrow}
\coqref{Ordinal.ord}{\coqdocinductive{ord}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{Ordinal.Limit}{Limit}{\coqdocconstructor{Limit}} :
(\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}}
\ensuremath{\rightarrow} \coqref{Ordinal.ord}{\coqdocinductive{ord}})
\ensuremath{\rightarrow}
\coqref{Ordinal.ord}{\coqdocinductive{ord}}.\coqdoceol
\end{coqdoccode}
\end{singlespace}
In fact, all definitions from Section~\ref{sub:brouwer} translate directly to
\Coq code. We can now prove basic properties of \coqdocinductive{$\preceq$},
for example that it is transitive:
% TODO: maybe add another example
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma}
\coqdef{Ordinal.ordletrans}{ord\_le\_trans}{\coqdoclemma{\ensuremath{\preceq_{\text{trans}}}}}
:
\ensuremath{\forall} \coqdocvar{\ensuremath{\alpha}}
\coqdocvar{\ensuremath{\beta}}
\coqdocvar{\ensuremath{\gamma}}, \coqdocvariable{\ensuremath{\alpha}}
\coqdocinductive{\ensuremath{\preceq}} \coqdocvariable{\ensuremath{\beta}}
\ensuremath{\rightarrow}
\coqdocvariable{\ensuremath{\beta}} \coqdocinductive{\ensuremath{\preceq}}
\coqdocvariable{\ensuremath{\gamma}}
\ensuremath{\rightarrow} \coqdocvariable{\ensuremath{\alpha}}
\coqdocinductive{\ensuremath{\preceq}}
\coqdocvariable{\ensuremath{\gamma}}.\coqdoceol
\end{coqdoccode}
\end{singlespace}

Recalling our discussion in Section~\ref{sub:brouwer} of limit ordinals whose
sequences do not actually approximate to a limit ordinal, we consider the
following lemma as an example of this issue:
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma}
\coqdef{Ordinal.ordlezeroright}{ord\_le\_zero\_right}{\coqdoclemma{\ensuremath{\preceq_{\text{zero\_right}}}}}
:
\ensuremath{\forall} \coqdocvar{\ensuremath{\alpha}} \coqdocvar{\ensuremath{\beta}},
\coqdocvariable{\ensuremath{\alpha}} \coqdocinductive{\ensuremath{\preceq}}
\coqref{Ordinal.Zero}{\coqdocconstructor{Zero}}
\ensuremath{\rightarrow}
\coqdocvariable{\ensuremath{\alpha}} \coqdocinductive{\ensuremath{\preceq}}
\coqdocvariable{\ensuremath{\beta}}.\coqdoceol
\end{coqdoccode}
\end{singlespace}
We would like to strengthen this, but cannot, since nothing denies \coqdocvariable{\ensuremath{\alpha}}
from being the Brouwer ordinal $\sqcup \{ 0, 0, 0, \ldots \}$ (which has the
same rank as $0$). We therefore turn to a subset of the Brouwer ordinals where
we restrict limit sequences to be strictly monotonic. This restriction is
encoded in the \coqref{WfOrdinal.wf}{\coqdocdefinition{wf}} property and the
$\Sigma$-type \coqref{WfOrdinal.wford}{\coqdocdefinition{ord$^\text{wf}$}}
defines the resulting subset:
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{WfOrdinal.wf}{wf}{\coqdocdefinition{wf}}
\coqdocvar{\ensuremath{\alpha}} : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{\ensuremath{\alpha}} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{Ordinal.Zero}{\coqdocconstructor{Zero}}
\ensuremath{\Rightarrow}
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Logic}{True}{\coqdocinductive{True}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{Ordinal.Succ}{\coqdocconstructor{Succ}}
\coqdocvar{\ensuremath{\beta}} \ensuremath{\Rightarrow}
\coqref{WfOrdinal.wf}{\coqdocdefinition{wf}} \coqdocvariable{\ensuremath{\beta}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{Ordinal.Limit}{\coqdocconstructor{Limit}} \coqdocvar{f}
\ensuremath{\Rightarrow} \ensuremath{\forall} \coqdocvar{n},
\coqref{WfOrdinal.wf}{\coqdocdefinition{wf}} (\coqdocvariable{f}
\coqdocvariable{n}) \ensuremath{\land} \ensuremath{\forall} \coqdocvar{m},
\coqdocvariable{n} < \coqdocvariable{m} \ensuremath{\rightarrow}
(\coqdocvariable{f} \coqdocvariable{n}) \coqdocdefinition{\ensuremath{\prec}}
(\coqdocvariable{f} \coqdocvariable{m})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition}
\coqdef{WfOrdinal.wford}{wf\_ord}{\coqdocdefinition{ord$^\text{wf}$}} : \coqdockw{Set}
:=
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Specif}{sig}{\coqdocinductive{sig}}
\coqref{WfOrdinal.wf}{\coqdocdefinition{wf}}.\coqdoceol
\end{coqdoccode}
\end{singlespace}

Now we can prove the stronger result we were looking for:\footnote{Although
  \coqdocvariable{\ensuremath{\alpha}} has type
  \coqref{WfOrdinal.wford}{\coqdocdefinition{ord$^\text{wf}$}} and
  \coqdocinductive{$\preceq$} has type
  \coqref{Ordinal.ord}{\coqdocinductive{ord}} $\rightarrow$
  \coqref{Ordinal.ord}{\coqdocinductive{ord}} $\rightarrow$ \coqdockw{Prop},
  we can state the lemma in this concise way by defining a simple coercion
  from \coqref{WfOrdinal.wford}{\coqdocdefinition{ord$^\text{wf}$}} to
  \coqref{Ordinal.ord}{\coqdocinductive{ord}} (first $\Sigma$-type
  projection).}
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma}
\coqdef{WfOrdinal.wfordlezeroright}{wf\_ord\_le\_zero\_right}{\coqdoclemma{\ensuremath{\preceq^{\text{wf}}_{\text{zero\_right}}}}}
:
\ensuremath{\forall} \coqdocvar{\ensuremath{\alpha}} :
\coqref{WfOrdinal.wford}{\coqdocdefinition{ord$^\text{wf}$}},
\coqdocvariable{\ensuremath{\alpha}} \coqdocinductive{\ensuremath{\preceq}}
\coqref{Ordinal.Zero}{\coqdocconstructor{Zero}}
\ensuremath{\rightarrow}
\coqdocvariable{\ensuremath{\alpha}} =
\coqref{Ordinal.Zero}{\coqdocconstructor{Zero}}.\coqdoceol
\end{coqdoccode}
\end{singlespace}


\section{Coinductive Terms}

In \Coq, coinductive datatypes can be defined using the \coqdockw{CoInductive}
command. No induction principles are defined for these types, because they are
not well-founded.\footnote{\Coq automatically derives induction principles for
  inductive definitions.} The objects of a coinductive type may contain an
infinite number of constructors, but can only be built in some restricted way
to ensure productivity of the construction.
% TODO: productivity or effectiveness?
We defer discussion of this restriction to Section~\ref{sub:guardedness}, and
define the type \coqref{Term.term}{\coqdocinductive{term}} of infinite terms
with function symbols in \coqdocvar{F} and variables in \coqdocvar{X} as
follows:
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{CoInductive} \coqdef{Term.term}{term}{\coqdocinductive{term}} :
\coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{Term.Var}{Var}{\coqdocconstructor{Var}} : \coqdocvar{X}
\ensuremath{\rightarrow} \coqref{Term.term}{\coqdocinductive{term}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{Term.Fun}{Fun}{\coqdocconstructor{Fun}} :
\ensuremath{\forall} \coqdocvar{f} : \coqdocvar{F},
\coqdocdefinition{vector}
\coqref{Term.term}{\coqdocinductive{term}}
(\coqdocprojection{arity} \coqdocvariable{f})
\ensuremath{\rightarrow} \coqref{Term.term}{\coqdocinductive{term}}.\coqdoceol
\end{coqdoccode}
\end{singlespace}
Here, \coqdocdefinition{vector} is assumed to implement dependently typed
lists (their type depending on their length).
% TODO: add refs to vector definition in sub:guardedness

The only way to build infinite objects in \Coq is by corecursion. However,
because the amount of memory available is finite, this is done lazilly,
meaning that the corecursive definition is only ever unfolded when explicitely
asked for. Now consider the objective of proving two infinite terms
equal. Simply comparing their definitions will not suffice, since the
corecursive construction of any given infinite object is not
unique.\footnote{Even unfolding the corecursion will not help us here. We can
  only unfold finitely often, and then still be left with the corecursive
  definition.} To this end, we define two extensional equalities on
\coqref{Term.term}{\coqdocinductive{term}}.

The coinductive predicate
\coqref{TermEquality.termbis}{\coqdocinductive{$\sim$}} defines bisimilarity
on terms:
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{CoInductive}
\coqdef{TermEquality.termbis}{term\_bis}{\coqdocinductive{$\sim$}} :
\coqref{Term.term}{\coqdocabbreviation{term}} \ensuremath{\rightarrow}
\coqref{Term.term}{\coqdocabbreviation{term}} \ensuremath{\rightarrow}
\coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|}
\coqdef{TermEquality.Varbis}{Var\_bis}{\coqdocconstructor{$\sim_\text{Var}$}} :
\ensuremath{\forall} \coqdocvar{x},
\coqref{Term.Var}{\coqdocconstructor{Var}} \coqdocvariable{x}
\coqref{TermEquality.termbis}{\coqdocinductive{$\sim$}}
\coqref{Term.Var}{\coqdocconstructor{Var}} \coqdocvariable{x}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|}
\coqdef{TermEquality.Funbis}{Fun\_bis}{\coqdocconstructor{$\sim_\text{Fun}$}} :
\ensuremath{\forall} \coqdocvar{f} \coqdocvar{v} \coqdocvar{w},
(\ensuremath{\forall} \coqdocvar{i},
\coqdocvariable{v} \coqdocvariable{i}
\coqref{TermEquality.termbis}{\coqdocinductive{$\sim$}}
\coqdocvariable{w} \coqdocvariable{i})
\ensuremath{\rightarrow}
\coqref{Term.Fun}{\coqdocconstructor{Fun}} \coqdocvariable{f}
\coqdocvariable{v}
\coqref{TermEquality.termbis}{\coqdocinductive{$\sim$}}
\coqref{Term.Fun}{\coqdocconstructor{Fun}} \coqdocvariable{f}
\coqdocvariable{w}.\coqdoceol
\end{coqdoccode}
\end{singlespace}
Any proof of two infinite terms being bisimilar is an infinite proof, in the
sense that the proof term is built by corecursion.

Another way to define equality on infinite terms is pointwise. First we define
pointwise equality of terms up to a given depth. Then two terms are equal if
this pointwise equality holds up to all depths:
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Inductive}
\coqdef{TermEquality.termequpto}{term\_eq\_up\_to}{\coqdocinductive{term\_eq\_up\_to}}
:
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}}
\ensuremath{\rightarrow} \coqref{Term.term}{\coqdocabbreviation{term}}
\ensuremath{\rightarrow} \coqref{Term.term}{\coqdocabbreviation{term}}
\ensuremath{\rightarrow} \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|}
\coqdef{TermEquality.teut0}{teut\_0}{\coqdocconstructor{teut$_0$}}   :
\ensuremath{\forall} \coqdocvar{t} \coqdocvar{u},
\coqref{TermEquality.termequpto}{\coqdocinductive{term\_eq\_up\_to}}
$0$ \coqdocvariable{t} \coqdocvariable{u}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|}
\coqdef{TermEquality.teutvar}{teut\_var}{\coqdocconstructor{teut$_\text{Var}$}} :
\ensuremath{\forall} \coqdocvar{n} \coqdocvar{x},
\coqref{TermEquality.termequpto}{\coqdocinductive{term\_eq\_up\_to}}
\coqdocvariable{n}
(\coqref{Term.Var}{\coqdocconstructor{Var}} \coqdocvariable{x})
(\coqref{Term.Var}{\coqdocconstructor{Var}} \coqdocvariable{x})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|}
\coqdef{TermEquality.teutfun}{teut\_fun}{\coqdocconstructor{teut$_\text{Fun}$}} :
\ensuremath{\forall} \coqdocvar{n} \coqdocvar{f} \coqdocvar{v}
\coqdocvar{w},\coqdoceol
\coqdocindent{7.50em}
(\ensuremath{\forall} \coqdocvar{i},
\coqref{TermEquality.termequpto}{\coqdocinductive{term\_eq\_up\_to}}
\coqdocvariable{n} (\coqdocvariable{v} \coqdocvariable{i}) (\coqdocvariable{w}
\coqdocvariable{i})) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{7.50em}
\coqref{TermEquality.termequpto}{\coqdocinductive{term\_eq\_up\_to}}
(\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{S}{\coqdocconstructor{S}}
\coqdocvariable{n}) (\coqref{Term.Fun}{\coqdocconstructor{Fun}}
\coqdocvariable{f} \coqdocvariable{v})
(\coqref{Term.Fun}{\coqdocconstructor{Fun}} \coqdocvariable{f}
\coqdocvariable{w}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition}
\coqdocvar{t}
\coqdef{TermEquality.termeq}{term\_eq}{\coqdocdefinition{$\doteq$}}
\coqdocvar{u} :=
\ensuremath{\forall} \coqdocvar{n},
\coqref{TermEquality.termequpto}{\coqdocinductive{term\_eq\_up\_to}}
\coqdocvariable{n} \coqdocvariable{t} \coqdocvariable{u}.\coqdoceol
\end{coqdoccode}
\end{singlespace}

% TODO: leave out the lemma statements?
% TODO: don't color notations like \sim?

We can prove that \coqref{TermEquality.termbis}{\coqdocinductive{$\sim$}} and
\coqref{TermEquality.termeq}{\coqdocdefinition{$\doteq$}} are the same
relation, and that indeed it is an equality:
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma}
\coqdef{TermEquality.termbistermeq}{term\_bis\_term\_eq}{\coqdoclemma{term\_bis\_term\_eq}}
: \ensuremath{\forall} \coqdocvar{t} \coqdocvar{u},
\coqdocvariable{t}
\coqref{TermEquality.termbis}{\coqdocinductive{$\sim$}}
\coqdocvariable{u} \ensuremath{\leftrightarrow}
\coqdocvariable{t}
\coqref{TermEquality.termeq}{\coqdocdefinition{$\doteq$}}
\coqdocvariable{u}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma}
\coqdef{TermEquality.termbisrefl}{term\_bis\_refl}{\coqdoclemma{$\sim_\text{refl}$}}
: \ensuremath{\forall} \coqdocvar{t},
\coqdocvariable{t}
\coqref{TermEquality.termbis}{\coqdocinductive{$\sim$}}
\coqdocvariable{t}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma}
\coqdef{TermEquality.termbissymm}{term\_bis\_symm}{\coqdoclemma{$\sim_\text{symm}$}}
: \ensuremath{\forall} \coqdocvar{t} \coqdocvar{u},
\coqdocvariable{t}
\coqref{TermEquality.termbis}{\coqdocinductive{$\sim$}}
\coqdocvariable{u} $\rightarrow$
\coqdocvariable{u}
\coqref{TermEquality.termbis}{\coqdocinductive{$\sim$}}
\coqdocvariable{t}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma}
\coqdef{TermEquality.termbistrans}{term\_bis\_trans}{\coqdoclemma{$\sim_\text{trans}$}}
: \ensuremath{\forall} \coqdocvar{s} \coqdocvar{t} \coqdocvar{u},
\coqdocvariable{s}
\coqref{TermEquality.termbis}{\coqdocinductive{$\sim$}}
\coqdocvariable{t} $\rightarrow$
\coqdocvariable{t}
\coqref{TermEquality.termbis}{\coqdocinductive{$\sim$}}
\coqdocvariable{u} $\rightarrow$
\coqdocvariable{s}
\coqref{TermEquality.termbis}{\coqdocinductive{$\sim$}}
\coqdocvariable{u}.\coqdoceol
\end{coqdoccode}
\end{singlespace}


\section{Transfinite Rewrite Sequences}


\chapter{UN\texorpdfstring{$^\infty$}{} and Weak Orthogonality}\label{chap:unwo}


\section{Jan Willem's Counterexample}


\section{Description of UNWO.v}


\chapter{Discussion and Conclusion}\label{chap:discussion}


\section{Design Choices}

One-hole contexts vs multi-hole contexts (possible using extended signature).

Casteran's ordinals in Veblen nf vs Mamane's set-theoretic ordinals vs Brouwer
ordinals.

Rewriting sequences as functions from ordinals to steps vs inductive
definition.


\subsection{Guardedness}\label{sub:guardedness}

Objects in a coinductive type may be infinite (i.e.~contain an infinite amount
of constructors). However, in order to guarantee productivity, definitions of
such objects are required by \Coq to be in \emph{guarded} form. A corecursive
definition in guarded form satisfies two (syntactical) conditions. First,
every corecursive call must occur inside at least one constructor (of the same
coinductive type). Second, every corecursive call may only occur inside
abstractions or constructors (of the same coinductive
type).\footnote{To be more precise, the corecursive call is also allowed to
  occur inside \coqdockw{match} constructs and other corecursive definitions.}

TODO: additional productivity remarks?

In the \coqref{Term.term}{\coqdocinductive{term}} definition, we used a vector
type, parameterized by the type of its element and its size. Naturally, one
would implement a vector type in \Coq inductively, as for example has been
done in the standard library:
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Inductive} \coqdef{Bvector.vector}{vector}{\coqdocinductive{vector}}
(\coqdocvar{A} : \coqdockw{Type}) :
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}}
\ensuremath{\rightarrow} \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{Bvector.Vnil}{Vnil}{\coqdocconstructor{Vnil}}  :
\coqref{Bvector.vector}{\coqdocinductive{vector}} \coqdocvariable{A} 0\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{Bvector.Vcons}{Vcons}{\coqdocconstructor{Vcons}} :
\coqdocvariable{A} \ensuremath{\rightarrow} \ensuremath{\forall} \coqdocvar{n},
\coqref{Bvector.vector}{\coqdocinductive{vector}} \coqdocvariable{A}
\coqdocvariable{n} \ensuremath{\rightarrow}
\coqref{Bvector.vector}{\coqdocinductive{vector}} \coqdocvariable{A}
(\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{S}{\coqdocconstructor{S}}
\coqdocvariable{n}).\coqdoceol
\end{coqdoccode}
\end{singlespace}

Now consider the following trivial example of a basic operation on terms by
corecursive traversal:
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{CoFixpoint} \coqdef{Term.id}{id}{\coqdocdefinition{id}}
(\coqdocvar{t} : \coqref{Term.term}{\coqdocinductive{term}}) :
\coqref{Term.term}{\coqdocinductive{term}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{t} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{Term.Var}{\coqdocconstructor{Var}} \coqdocvar{x}
\ensuremath{\Rightarrow} \coqref{Term.Var}{\coqdocconstructor{Var}}
\coqdocvariable{x}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{Term.Fun}{\coqdocconstructor{Fun}} \coqdocvar{f}
\coqdocvar{args} \ensuremath{\Rightarrow}
\coqref{Term.Fun}{\coqdocconstructor{Fun}} \coqdocvariable{f}
(\coqdocdefinition{vmap} \coqref{Term.id}{\coqdocdefinition{id}}
\coqdocvariable{args})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\end{coqdoccode}
\end{singlespace}
This definition is ill-formed, since the corecursive call to
\coqref{Term.id}{\coqdocdefinition{id}} is not guarded.\footnote{The call to
  \coqref{Term.id}{\coqdocdefinition{id}} is hidden inside
  \coqdocdefinition{vmap}, which is defined by recursion on the vector
  \coqdocvariable{args}.}

We define a recursive type of vectors as an alternative to the inductive type:
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Inductive} \coqdef{Vector.Fin}{Fin}{\coqdocinductive{Fin}} :
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}}
\ensuremath{\rightarrow} \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{Vector.First}{First}{\coqdocconstructor{First}} :
\ensuremath{\forall} \coqdocvar{n}, \coqref{Vector.Fin}{\coqdocinductive{Fin}}
(\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{S}{\coqdocconstructor{S}}
\coqdocvariable{n})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{Vector.Next}{Next}{\coqdocconstructor{Next}}  :
\ensuremath{\forall} \coqdocvar{n}, \coqref{Vector.Fin}{\coqdocinductive{Fin}}
\coqdocvariable{n} \ensuremath{\rightarrow}
\coqref{Vector.Fin}{\coqdocinductive{Fin}}
(\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{S}{\coqdocconstructor{S}}
\coqdocvariable{n}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition}
\coqdef{Vector.vector}{vector}{\coqdocdefinition{vector}} (\coqdocvar{A} :
\coqdockw{Type}) (\coqdocvar{n} :
\coqexternalref{http://coq.inria.fr/stdlib/Coq.Init.Datatypes}{nat}{\coqdocinductive{nat}})
:= \coqref{Vector.Fin}{\coqdocinductive{Fin}} \coqdocvariable{n}
\ensuremath{\rightarrow} \coqdocvariable{A}.\coqdoceol
\end{coqdoccode}
\end{singlespace}
% TODO: explain this vector
This makes for a definition of \coqref{Vector.vmap}{\coqdocdefinition{vmap}}
that is just an abstraction, and therefore solves the guardedness problem in
\coqref{Term.id}{\coqdocdefinition{id}}:
\begin{singlespace}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Definition} \coqdef{Vector.vmap}{vmap}{\coqdocdefinition{vmap}}
\coqdocvar{A} \coqdocvar{B} (\coqdocvar{f} :
\coqdocvariable{A} \ensuremath{\rightarrow} \coqdocvariable{B}) \coqdocvar{n}
: \coqref{Vector.vector}{\coqdocdefinition{vector}} \coqdocvariable{A}
\coqdocvariable{n} \ensuremath{\rightarrow}
\coqref{Vector.vector}{\coqdocdefinition{vector}} \coqdocvariable{B}
\coqdocvariable{n} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{fun} \coqdocvar{v} \coqdocvar{i} \ensuremath{\Rightarrow}
\coqdocvariable{f} (\coqdocvariable{v} \coqdocvariable{i}).\coqdoceol
\end{coqdoccode}
\end{singlespace}


\section{Discussion}

Bvector vs Vector: we did not really hit the guardedness restriction, so we
could have used inductive Bvector. But it spells trouble later.


\section{Conclusions}


\pagebreak


\nocite{*}
\bibliographystyle{plain}
\bibliography{master-project}


\end{document}
