Pottier, Static Name Control for FreshML
http://www.citeulike.org/user/huitseeker/article/1397450

Cheney, Toward a general theory of names: binding and scope
http://www.citeulike.org/user/kavabean/article/359771

Cheney, Scrap your nameplate: (functional pearl)
http://www.citeulike.org/user/kavabean/article/359763
Generic programming in Haskell with nominal abstract syntax a la FreshML

Pitts, A fresh approach to representing syntax with static binders in functional programming
http://www.citeulike.org/user/kavabean/article/352567

Hofmann, Semantical Analysis of Higher-Order Abstract Syntax
http://www.citeulike.org/user/huitseeker/article/3014079

Mechanizing the metatheory of Standard ML
http://www.citeulike.org/user/huitseeker/article/1442505

CINNI - A Calculus of Indexed Names and Named Indices
http://www2.computer.org/portal/web/csdl/abs/proceedings/lics/1999/0158/00/01580204abs.htm

PL Grand Challenges
http://plgrand.blogspot.com/
These are notes on the panel on Grand Challenges in Programming Languages,
which was held at POPL 2009. The notes were taken by Benjamin C. Pierce and
dited by Yitzhak Mandelbaum.


Problem: manipulating terms with free and bound variables.

How do we represent binders and bound variables?

Recurring issues with most representations are the need to identify terms up to
alpha conversion of bound variables and mechanical difficulties in substition
(renaming, lifting, freshening).

Classical case, named variables:
* easy to read
* equivalence modulo alpha conversion
* simple substitution is not structural recursive (renaming of bound variables)
* mechanically tedious (capture-avoiding substitution, no syntactical equivalence)

-> investigate:
   * simultaneous substitution (is structural recursive)
   * variable convention (bound variables are distinct)

De Bruijn indices:
* represent bound variables by indices indicating the number of binders to skip
* syntactical equivalence
* substition is structural recursive (lifting is done in the substituted term)
* harder to read
* lifting
* mechanically less tedious

Locally nameless:
* de Bruijn indices for bound variables
* names for free variables
* syntactical equivalence
* no lifting, no renaming
* substitution is not structural recursive (freshening)

We will focus on the above three representations, but there are more.

Nominal:
* names for variables
* equivalence classes for terms
* built on nominal logic
* this is what we actually do on paper

Higher-order abstract syntax:
* meta-variables for variables and meta-functions for functions
* alpha-equivalence and substitution for free
* incompatible with coq and hol logics
* leads to statements quite different from what we do on paper

Let's consider substitution in untyped lambda calculus with named variables.

Substituting N for x in M (M[N/x]) is defined inductively on M:

  y[N/x]       = x if y=x, y otherwise
  (\y.M')[N/x] = \z.(M'[z/y][N/x]) where z not free in N and M'
  (M1 M2)[N/x] = (M1[N/x]) (M2[N/x])

This is difficult enough to read on paper, but what it actually means is
what we would intuitively do. So on paper we can do away with the problem
with some handwaving.

Now enter a formal system (we use the proof assistent coq).

  Parameter name : Set.
  Hypothesis eq_name : forall (x y : name), {x = y} + {x <> y}.

  Inductive term : Set :=
    | Var : name -> term
    | Abs : name -> term -> term
    | App : term -> term -> term.

  Fixpoint subst (t1:term) (n:name) (t2:term) {struct t2} : term :=
    match t2 with
    | Var x =>
        if eq_name x n then t1 else t2
    | Abs x t3 =>
        if eq_name x n then t2 else Abs x (subst t1 n t3)
    | App t3 t4 =>
        App (subst t1 n t3) (subst t1 n t4)
  end.
