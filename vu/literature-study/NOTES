Pottier, Static Name Control for FreshML
http://www.citeulike.org/user/huitseeker/article/1397450

Cheney, Toward a general theory of names: binding and scope
http://www.citeulike.org/user/kavabean/article/359771

Cheney, Scrap your nameplate: (functional pearl)
http://www.citeulike.org/user/kavabean/article/359763
Generic programming in Haskell with nominal abstract syntax a la FreshML

Pitts, A fresh approach to representing syntax with static binders in functional programming
http://www.citeulike.org/user/kavabean/article/352567

Hofmann, Semantical Analysis of Higher-Order Abstract Syntax
http://www.citeulike.org/user/huitseeker/article/3014079

Mechanizing the metatheory of Standard ML
http://www.citeulike.org/user/huitseeker/article/1442505

CINNI - A Calculus of Indexed Names and Named Indices
http://www2.computer.org/portal/web/csdl/abs/proceedings/lics/1999/0158/00/01580204abs.htm

PL Grand Challenges
http://plgrand.blogspot.com/
These are notes on the panel on Grand Challenges in Programming Languages,
which was held at POPL 2009. The notes were taken by Benjamin C. Pierce and
dited by Yitzhak Mandelbaum.

Coq-club: proving the substitution lemma
http://pauillac.inria.fr/pipermail/coq-club/2007/003185.html

POPLmark: Progress Meeting '06 Transcript
http://alliance.seas.upenn.edu/~plclub/cgi-bin/poplmark/index.php?title=ProgressMeeting06Transcript


Problem: manipulating terms with free and bound variables.

How do we represent binders and bound variables?

Recurring issues with most representations are the need to identify terms up to
alpha conversion of bound variables and mechanical difficulties in substition
(renaming, lifting, freshening).

Classical case, named variables:
* easy to read
* equivalence modulo alpha conversion
* simple substitution is not structural recursive (renaming of bound variables)
* mechanically tedious (capture-avoiding substitution, no syntactical equivalence)

-> investigate:
   * simultaneous substitution (is structural recursive)
   * variable convention (bound variables are distinct)

De Bruijn indices:
* represent bound variables by indices indicating the number of binders to skip
* syntactical equivalence
* substition is structural recursive (lifting is done in the substituted term)
* harder to read
* lifting
* mechanically less tedious

Locally nameless:
* de Bruijn indices for bound variables
* names for free variables
* syntactical equivalence
* no lifting, no renaming, but freshening
* substitution is not structural recursive (freshening)

We will focus on the above three representations, but there are more.

Nominal:
* names for variables
* equivalence classes for terms
* built on nominal logic
* this is what we actually do on paper

Higher-order abstract syntax:
* meta-variables for variables and meta-functions for functions
* alpha-equivalence and substitution for free
* incompatible with coq and hol logics
* leads to statements quite different from what we do on paper

Let's consider untyped lambda calculus with named variables.

  Variable:    x
  Abstraction: \x.M
  Application: M N

On paper, alpha-equivalent terms are routinely identified.

Substitution _[_/_] is usually defined along the lines of:

  x[N/x]       = N
  y[N/x]       = y                    if y<>x
  (\y.M)[N/x]  = \y.(M[N/x])          if y<>x and y not free in N
  (M1 M2)[N/x] = (M1[N/x]) (M2[N/x])

How do we implement the side conditions? We could assume Barendregt's
variable convention and they are fullfilled.
A less restricted aproach is using alpha-conversion to rename bound
variables when needed. This brings us to the following generalization:

Substituting N for x in M (M[N/x]) is defined inductively on M:

  y[N/x]       = x if y=x, y otherwise
  (\y.M')[N/x] = \z.(M'[z/y][N/x]) for z not free in N and M'
  (M1 M2)[N/x] = (M1[N/x]) (M2[N/x])

This is difficult enough to read on paper, but what it actually means is
what we would intuitively do. So on paper we can do away with the problem
with some handwaving.

Now enter a formal system (we use the proof assistent coq).

  Inductive term : Set :=
    | Var : name -> term
    | Abs : name -> term -> term
    | App : term -> term -> term.

Presumably, name lives in Set and equality on names is decidable.

The first problem is that of alpha-conversion. Equivalence modulo alpha
is not term equivalence. Whenever we have to decide on equivalence, a lot
of extra work has to be done (e.g. reduce to term equivalence by taking
canonical terms, or recursively compare represented structures, or ...).

The second problem is that of substitution. Following the on-paper
definition of substitution, we could maintain the variable convention and
use the naive implementation:

  Function subst_naive (t:term) (n:name) (t':term) {struct t'} : term :=
    match t' with
    | Var x =>
        if eq_name x n then t else t'
    | Abs x b =>
        if eq_name x n then t' else Abs x (subst_naive t n b)
    | App f a =>
        App (subst_naive t n f) (subst_naive t n a)
  end.

But it seems cumbersome to maintain the variable convention.

As an alternative, let's have a look at the capture-avoiding substitution
where we rename bound variables. We use an auxilary renaming function:

  (* Just naively rename n to n'. *)
  Fixpoint rename (n n':name) (t:term) {struct t} : term :=
    match t with
    | Var x =>
        if eq_name x n then Var n' else t
    | Abs x b =>
        Abs (if eq_name x n then n' else x) (rename n n' b)
    | App f a =>
        App (rename n n' f) (rename n n' a)
  end.

Assume we can generate fresh names and can list free variables of terms.

  (* Incorrect capture-avoiding substitution. *)
  Fixpoint subst (t:term) (n:name) (t':term) {struct t'} : term :=
    match t' with
    | Var x =>
        if eq_name x n then t else t'
    | Abs x b =>
        (* We always rename, this could of course be improved. *)
        let z := fresh_name (n :: (free_vars t) ++ (free_vars b))
        in
        Abs z (subst t n (rename x z b))
    | App f a =>
        App (subst t n f) (subst t n a)
  end.

But of course, this is ill-defined, since subst is not structurally recursive
on t'. We can, however, recurse on another well-founded measure, such as
the size of t'.
Unfortunately, this adds a lot of extra code. We have to define the measure,
and proof that it decreases on the recursive calls. This is the result:

  (* Well-founded measure on terms. *)
  Fixpoint size (t:term) : nat :=
    match t with
    | Var _   => 0
    | Abs x b => S (size b)
    | App f a => 1 + (size f) + (size a)
  end.

  (* Size is invariant under renaming. *)
  Lemma size_rename : forall (n n':name) (t:term), size (rename n n' t) = size t.
  Proof.
  unfold size.
  unfold rename.
  induction t;
    [ (* Var _ *)
      case (eq_name n0 n); intro; trivial
    | (* Abs _ _ *)
      congruence
    | (* App _ _ *)
      congruence].
  Qed.

  (* Capture-avoiding substitution by recursion on size. *)
  Function subst (t:term) (n:name) (t':term) {measure size t'} : term :=
    match t' with
    | Var x =>
        if eq_name x n then t else t'
    | Abs x b =>
        (* We always rename, this could of course be improved. *)
        let z := fresh_name (n :: (free_vars t) ++ (free_vars b))
        in
        Abs z (subst t n (rename x z b))
    | App f a =>
        App (subst t n f) (subst t n a)
  end.
  (* This leaves us with 3 obligations. *)
  Proof.
  intros.
  rewrite size_rename.
  auto.

  intros.
  unfold size.
  inversion f; omega.

  intros.
  unfold size.
  inversion a; omega.
  Defined.

So, presumably this works. But proving things about this substitution
operation will not be fun.

Of course we prefer structural recursion over recursion on some size
measure. Stoughton suggests simultaneous substitution, which is
structurally recursive:

  (* Apply a list of substitutions to a name. *)
  Fixpoint apply_subst (l:list (term*name)) (n:name) {struct l} : term :=
    match l with
    | nil        => Var n
    | (t, x)::l' => if eq_name x n then t else apply_subst l' n
  end.

  (* Capture-avoiding simultaneous substitution by structural recursion. *)
  Fixpoint sim_subst (l:list (term*name)) (t:term) {struct t} : term :=
    match t with
    | Var x =>
        apply_subst l x
    | Abs x b =>
        let z := fresh_name ((free_vars_sub l) ++ (free_vars b))
        in
        Abs z (sim_subst ((Var z, x)::l) b)
    | App f a =>
        App (sim_subst l f) (sim_subst l a)
  end.

Singular substitution is then just a special case:

  (* Define simple substitution in terms of simultaneous substitution. *)
  Definition subst' (t:term) (n:name) (t':term) : term := sim_subst ((t, n) :: nil) t'.

So far, so good. We still have the issue of alpha-conversion and the
substitutions are messy.

Another aproach is using numbers instead of names, de-Bruijn indices:

  Variable:    n
  Abstraction: \M
  Application: M N

This is quite different from named variables, and harder to read. However,
we don't need alpha-conversion, because equality is just syntactical
equality. This is a major plus in automated reasoning.

Let's see what happened to our substitution operation. We could translate it
as:

  n[N/n]       = N
  m[N/n]       = m            if m<>n
  (\M)[N/n]    = \(M[^N/n+1])
  (M1 M2)[N/n] = (M1[N/n]) (M2[N/n])

Where ^N is N with all free indices increased by 1, called lifting. So
we lost the need for renaming, but got lifting in return.
Fortunately, lifting is a technically much easier operation and we don't
need to generate fresh names. Furthermore, this substitution is structurally
recursive.

This could look like this in Coq:

  Inductive term : Set :=
    | Var : nat -> term
    | Abs : term -> term
    | App : term -> term -> term.

  (* Lift indices that are bound by at least l abstractions away. *)
  Fixpoint lift (l:nat) (t:term) {struct t} : term :=
    match t with
    | Var n   => Var (if le_lt_dec l n then (S n) else n)
    | Abs u   => Abs (lift (S l) u)
    | App u v => App (lift l u) (lift l v)
  end.

  (* Capture-avoiding substitution. *)
  Fixpoint subst (t:term) (n:nat) (t':term) {struct t'} : term :=
    match t' with
    | Var m   => if eq_nat_dec n m then t else t'
    | Abs u   => Abs (subst (lift 0 t) (S n) u)
    | App u v => App (subst t n u) (subst t n v)
  end.

We can also combine names and numbers in a locally nameless representation
where bound variables are represented by de-bruijn indices and free
variables are named:

  Free variable:  x
  Bound variable: n
  Abstraction:    \M
  Application:    M N

In Coq:

  Inductive term : Set :=
    | FreeVar  : name -> term
    | BoundVar : nat -> term
    | Abs      : term -> term
    | App      : term -> term -> term.
