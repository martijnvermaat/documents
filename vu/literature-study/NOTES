Pottier, Static Name Control for FreshML
http://www.citeulike.org/user/huitseeker/article/1397450

Cheney, Toward a general theory of names: binding and scope
http://www.citeulike.org/user/kavabean/article/359771

Cheney, Scrap your nameplate: (functional pearl)
http://www.citeulike.org/user/kavabean/article/359763
Generic programming in Haskell with nominal abstract syntax a la FreshML

Pitts, A fresh approach to representing syntax with static binders in functional programming
http://www.citeulike.org/user/kavabean/article/352567

Hofmann, Semantical Analysis of Higher-Order Abstract Syntax
http://www.citeulike.org/user/huitseeker/article/3014079

Mechanizing the metatheory of Standard ML
http://www.citeulike.org/user/huitseeker/article/1442505

CINNI - A Calculus of Indexed Names and Named Indices
http://www2.computer.org/portal/web/csdl/abs/proceedings/lics/1999/0158/00/01580204abs.htm

PL Grand Challenges
http://plgrand.blogspot.com/
These are notes on the panel on Grand Challenges in Programming Languages,
which was held at POPL 2009. The notes were taken by Benjamin C. Pierce and
dited by Yitzhak Mandelbaum.


Problem: manipulating terms with free and bound variables.

How do we represent binders and bound variables?

Recurring issues with most representations are the need to identify terms up to
alpha conversion of bound variables and mechanical difficulties in substition
(renaming, lifting, freshening).

Classical case, named variables:
* easy to read
* equivalence modulo alpha conversion
* simple substitution is not structural recursive (renaming of bound variables)
* mechanically tedious (capture-avoiding substitution, no syntactical equivalence)

-> investigate:
   * simultaneous substitution (is structural recursive)
   * variable convention (bound variables are distinct)

De Bruijn indices:
* represent bound variables by indices indicating the number of binders to skip
* syntactical equivalence
* substition is structural recursive (lifting is done in the substituted term)
* harder to read
* lifting
* mechanically less tedious

Locally nameless:
* de Bruijn indices for bound variables
* names for free variables
* syntactical equivalence
* no lifting, no renaming
* substitution is not structural recursive (freshening)

We will focus on the above three representations, but there are more.

Nominal:
* names for variables
* equivalence classes for terms
* built on nominal logic
* this is what we actually do on paper

Higher-order abstract syntax:
* meta-variables for variables and meta-functions for functions
* alpha-equivalence and substitution for free
* incompatible with coq and hol logics
* leads to statements quite different from what we do on paper

Let's consider untyped lambda calculus with named variables.

On paper, alpha-equivalent terms are routinely identified.

Substituting N for x in M (M[N/x]) is defined inductively on M:

  y[N/x]       = x if y=x, y otherwise
  (\y.M')[N/x] = \z.(M'[z/y][N/x]) for z not free in N and M'
  (M1 M2)[N/x] = (M1[N/x]) (M2[N/x])

This is difficult enough to read on paper, but what it actually means is
what we would intuitively do. So on paper we can do away with the problem
with some handwaving.

Now enter a formal system (we use the proof assistent coq).

  Inductive term : Set :=
    | Var : name -> term
    | Abs : name -> term -> term
    | App : term -> term -> term.

Presumably, name lives in Set and equality on names is decidable.

The first problem is that of alpha-conversion. Equivalence modulo alpha
is not term equivalence. Whenever we have to decide on equivalence, a lot
of extra work has to be done (e.g. reduce to term equivalence by taking
canonical terms, or recursively compare represented structures, or ...).

The second problem is that of substitution. Following the on-paper
definition of substitution, we could naively write (provided we have some
way to get fresh names):

  Fixpoint subst (t:term) (n:name) (t':term) {struct t'} : term :=
    match t' with
    | Var x =>
        if eq_name x n then t else t'
    | Abs x b =>
        let z := fresh_name ((free_vars t) ++ (free_vars b))
        in
        Abs z (subst t n (subst (Var z) x b))
    | App f a =>
        App (subst t n f) (subst t n a)
  end.

But of course, this is ill-defined, since subst is not structural recursive
on t'. We can, however, recurse on another well-founded measure, such as
the size of t'. We get this:

http://www.chargueraud.org/arthur/research/2007/binders/src_color/Metatheory_Var.html
