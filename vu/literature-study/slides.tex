\documentclass[notheorems]{beamer}

\usepackage[english]{babel}

\usepackage{amsmath}
\usepackage{amssymb}

\usepackage[T1]{fontenc}
\usepackage{ae,aecompl}

\usepackage{listings}

\usepackage{beamerthemesplit}

\setbeamertemplate{background canvas}[vertical shading][bottom=red!10,top=blue!10]
\setbeamertemplate{navigation symbols}{}
\setbeamertemplate{headline}{}
\usetheme{Warsaw}
\useinnertheme{rectangles}

\colorlet{darkred}{red!80!black}
\colorlet{darkblue}{blue!80!black}
\colorlet{darkgreen}{green!80!black}

\lstdefinelanguage{Coq}{
  mathescape=true,
  texcl=false,
  keywords={Require, Declare},
  morekeywords={forall, exists, with, match, let, in, if, then, else},
  morekeywords={
    destruct, change, Variable, Inductive, CoInductive, Fixpoint, CoFixpoint, Definition,
    Lemma, Theorem, Proof, Axiom, Local, Save, Grammar, Syntax, Intro, Trivial,
    Qed, Intros, Symmetry, Simpl, Rewrite, Apply, Elim, Assumption, Left,
    Cut, Case, Auto, Unfold, Exact, Right},
  morekeywords={Section, Module, End},
  emph={[1]Type, Set, nat, bool}, emphstyle={[1]\textit},
  comment=[s]{(*}{*)},
  showstringspaces=false,
}%[keywords,comments,strings]%

\lstset{
  numbers=none,
  basicstyle=\footnotesize\ttfamily,
  frame=tb,
  language=Coq,
  captionpos=b,
  xleftmargin=0em,
  xrightmargin=0em,
  aboveskip=1em,
  belowskip=1em
}


\title{Names and Numbers in Binding}

\author{Martijn Vermaat}
\institute{mvermaat@cs.vu.nl\\
http://www.cs.vu.nl/\~{}mvermaat/}
\date{Literature Study\\
March 13, 2009}


\begin{document}


\frame{\titlepage}


\frame{

  \frametitle{Names and Numbers in Binding}

  \tableofcontents

}


\section{Mechanical Reasoning about Languages}


\frame{

  \frametitle{Mechanical Reasoning}

  Shift from on-paper reasoning to mechanical reasoning:

  \begin{itemize}
    \item History of on-paper proofs and ideas
    \item Informal mechanical implementations of ideas
    \item Add a scale increase and we have a gap
  \end{itemize}

  \uncover<2->{
    \begin{block}{Goal}
      Let's make rigorous mechanical reasoning possible.
    \end{block}
  }

}


\frame{

  \frametitle{Reasoning about Languages}

  \begin{block}{Reasoning about languages}
    Often not intrinsically hard, but cumbersome in a mechanical setting.
  \end{block}

  Why?
  \uncover<2->{
    \begin{itemize}
    \item Most languages have a notion of binding
    \item Bindings and bound variables are easy on paper, hard on a computer
    \end{itemize}
  }

}


\frame{

  \frametitle{Mechanical Reasoning about Languages}

  So we want to
  \begin{quote}
    Reason about terms with bindings in tools like Coq, in a way that is close
    to the on-paper way.
  \end{quote}

  \uncover<2->{
    We need a representation for binders and variables.
  }

}


\section{Representing Bindings}


\frame{

  \frametitle{Names and Numbers in Binding}

  \tableofcontents[currentsection]

}


\frame{

  \frametitle{Representing Bindings}

  Classical problems related to binders and variables:

  \begin{itemize}
    \item $\alpha$-conversion
    \item substitution
  \end{itemize}

  \uncover<2->{
    Let's look at some representations.
  }

}


\frame{

  \frametitle{Traditional Representation}

  \begin{block}{Running example}
    Substitution in untyped $\lambda$-calculus
  \end{block}

  \uncover<2->{
    Traditional representation with named variables:
    \begin{align*}
      M ::=             &\; x
      && \text{variable} \\
      \llap{\textbar\:} &\; \lambda x.M
      && \text{abstraction} \\
      \llap{\textbar\:} &\; M \; M
      && \text{application} \\
    \end{align*}

  }

}


\frame{

  \frametitle{Traditional Representation}

  \begin{itemize}

    \item $\alpha$-equivalent terms are routinely identified

    \item Substitution $M[N/x]$:
      \begin{align*}
        x[N/x]              &= N\\
        y[N/x]              &= y                  && \text{$x \neq y$} \\
        (\lambda y.M')[N/x] &= \lambda y.M'[N/x]  && \text{$x \neq y$ and $y$ not free in $N$} \\ % TODO: fix layout
        (M_1 \; M_2)[N/x]   &= M_1[N/x] \; M_2[N/x]
      \end{align*}

    \item Now implement this
      % alpha-conversion is very hard
      % side-conditions are declarative
      % (\x.M)[N/x] not even defined
      % use variable convention, or a more general substitution (next slide)

  \end{itemize}

}


\frame{

  \frametitle{Simple Substitution}

  Use $\alpha$-conversion to rename bound variables and define
  substituting $N$ for $x$ in $M$ inductively$^*$ on M:

  \begin{align*}
    x[N/x]              &= \text{$N$ if $x = y$, $y$ otherwise}\\
    (\lambda y.M')[N/x] &= \lambda z.M'[z/y][N/x]  && \text{$z$ not free in $N, M'$} \\ % TODO: fix layout
    (M_1 \; M_2)[N/x]   &= M_1[N/x] \; M_2[N/x]
  \end{align*}

  % Note that M'[z/y] is not a subterm of M

  \uncover<2->{
    Already difficult enough to read, but just what we would intuitively do.
    So on paper, we can get by with some handwaving.
  }

}


\begin{frame}[fragile]

  \frametitle{Named Variables in Coq}

  Term datatype:
  \begin{lstlisting}
Inductive term : Set :=
  | Var : name -> term
  | Abs : name -> term -> term
  | App : term -> term -> term.
  \end{lstlisting}

\end{frame}


\begin{frame}[fragile]

  \frametitle{Named Variables in Coq}

  Simple substitution:
  \begin{lstlisting}
Fixpoint subst (t:term) (n:name) (t':term)
  {struct t'} : term :=
  match t' with
  | Var x =>
      if eq_name x n then t else t'
  | Abs x b =>
      let z := fresh_name
                 (n :: (free_vars t) ++ (free_vars b))
      in
      Abs z (subst t n (rename x z b))
  | App f a =>
      App (subst t n f) (subst t n a)
end.
  \end{lstlisting}
  \uncover<2->{
    \emph{But this is ill-defined.}
  }

\end{frame}


\begin{frame}[fragile]

  \frametitle{Named Variables in Coq}

  Using term size as a measure:
  \begin{lstlisting}
Fixpoint size (t:term) : nat :=
  match t with
  | Var _   => 0
  | Abs x b => S (size b)
  | App f a => 1 + (size f) + (size a)
end.

Lemma size_rename : forall (n n':name) (t:term),
  size (rename n n' t) = size t.
Proof.
unfold size.
unfold rename.
induction t;
  [ case (eq_name n0 n); intro; trivial  (* Var *)
  | congruence                           (* Abs *)
  | congruence ].                        (* App *)
Qed.
  \end{lstlisting}

\end{frame}




\begin{frame}[fragile]

  \frametitle{Named Variables in Coq}

  Substitution with term size as a recursion measure:
  \begin{lstlisting}
Function subst (t:term) (n:name) (t':term)
  {measure size t'} : term :=
  match t' with
  | Var x =>
      if eq_name x n then t else t'
  | Abs x b =>
      let z := fresh_name
                 (n :: (free_vars t) ++ (free_vars b))
      in
      Abs z (subst t n (rename x z b))
  | App f a =>
      App (subst t n f) (subst t n a)
end.
(* Leaves us with 3 obligations. *)
  \end{lstlisting}

\end{frame}


\begin{frame}[fragile]

  \frametitle{Named Variables in Coq}

  Proving termination of \texttt{subst}:
  \begin{lstlisting}
Proof.
intros.
rewrite size_rename.
auto.

intros.
unfold size.
inversion f; omega.

intros.
unfold size.
inversion a; omega.
Defined.
  \end{lstlisting}
  \uncover<2->{
    We really prefer structural recursion.
  }

\end{frame}


\begin{frame}[fragile]

  \frametitle{Named Variables in Coq}

  Stoughton suggests simultaneous substitution:
  \begin{lstlisting}
Fixpoint sim_subst (l:list (term*name)) (t:term)
  {struct t} : term :=
  match t with
  | Var x =>
      apply_subst l x
  | Abs x b =>
      let z := fresh_name
                  ((free_vars_sub l) ++ (free_vars b))
      in
      Abs z (sim_subst ((Var z, x)::l) b)
  | App f a =>
      App (sim_subst l f) (sim_subst l a)
end.

Definition subst' (t:term) (n:name) (t':term)
  : term := sim_subst ((t, n) :: nil) t'.
  \end{lstlisting}

\end{frame}


\frame{

  \frametitle{de Bruijn Indices}

  Represent variable occurrences by numbers:
  \begin{align*}
    M ::=             &\; n
    && \text{variable} \\
    \llap{\textbar\:} &\; \lambda .M
    && \text{abstraction} \\
    \llap{\textbar\:} &\; M \; M
    && \text{application} \\
  \end{align*}

  \uncover<2->{
    \begin{itemize}
      \item Harder to read
      \item $\alpha$-equivalence is term equivalence
      \item Substitution is structurally recursive
      \item No renaming (but lifting)
      \item Mechanically less tedious
    \end{itemize}
  }

}


\begin{frame}

  \frametitle{de Bruijn Indices}

  Substitution can be defined as:
  \begin{align*}
    n[N/n]             &= N\\
    m[N/n]             &= m                    && \text{$m \neq n$} \\
    (\lambda .M')[N/n] &= \lambda .M'[\uparrow \! N / n\!+\!1]\\
    (M_1 \; M_2)[N/n]  &= M_1[N/n] \; M_2[N/n]
  \end{align*}
  where $\uparrow \! M$ is $M$ with all free variables incremented.

\end{frame}


\begin{frame}[fragile]

  \frametitle{de Bruijn Indices in Coq}

  Term datatype:
  \begin{lstlisting}
Inductive term : Set :=
  | Var : nat -> term
  | Abs : term -> term
  | App : term -> term -> term.
  \end{lstlisting}

\end{frame}


\begin{frame}[fragile]

  \frametitle{de Bruijn Indices in Coq}

  Substitution:
  \begin{lstlisting}
Fixpoint lift (l:nat) (t:term) {struct t} : term :=
  match t with
  | Var n   => Var (if le_lt_dec l n then (S n)
                    else n)
  | Abs u   => Abs (lift (S l) u)
  | App u v => App (lift l u) (lift l v)
end.

Fixpoint subst (t:term) (n:nat) (t':term)
  {struct t'} : term :=
  match t' with
  | Var m   => if eq_nat_dec n m then t else t'
  | Abs u   => Abs (subst (lift 0 t) (S n) u)
  | App u v => App (subst t n u) (subst t n v)
end.
  \end{lstlisting}

\end{frame}


\begin{frame}

  \frametitle{Locally Nameless Representation}

  Combine names and numbers -- names for free variables, de Bruijn indices for bound variables:
  \begin{align*}
    M ::=             &\; x
    && \text{free variable} \\
    \llap{\textbar\:} &\; n
    && \text{bound variable} \\
    \llap{\textbar\:} &\; \lambda .M
    && \text{abstraction} \\
    \llap{\textbar\:} &\; M \; M
    && \text{application} \\
  \end{align*}

  \uncover<2->{
    \begin{itemize}
      \item $\alpha$-equivalence is term equivalence
      \item No renaming, no lifting (but freshening)
      \item Substitution is not structurally recursive
    \end{itemize}
  }


\end{frame}


\begin{frame}[fragile]

  \frametitle{Locally Nameless Representation in Coq}

  Term datatype:
  \begin{lstlisting}
Inductive term : Set :=
  | FreeVar  : name -> term
  | BoundVar : nat -> term
  | Abs      : term -> term
  | App      : term -> term -> term.
  \end{lstlisting}

\end{frame}










\section{Conclusions}


\frame{

  \frametitle{Names and Numbers in Binding}

  \tableofcontents[currentsection]

}


\frame{

  \frametitle{Conclusion}

  \begin{itemize}
    \item One conclusion
    \item Second conclusion
    \item Conclusion of conclusions
  \end{itemize}

}


\begin{frame}

  \frametitle{Questions and Further Reading}

  Questions?\\[4em]

  \begin{block}{Further Reading}
    \begin{itemize}
      \item Plotkin, 1975: {\em Call-by-name, Call-by-value and the lambda-calculus}
      \item Danvy and Filinski, 1992: {\em Representing control: a study of the CPS transformation}
      \item Appel, 1992: {\em Compiling with Continuations}
      \item Compcert: \texttt{http://pauillac.inria.fr/\~{}xleroy/compcert/}
      \item Lambda Tamer: \texttt{http://ltamer.sourceforge.net/}
    \end{itemize}
  \end{block}

\end{frame}


\end{document}
