\documentclass[notheorems]{beamer}

\usepackage[english]{babel}

\usepackage{amsmath}
\usepackage{amssymb}

\usepackage[T1]{fontenc}
\usepackage{ae,aecompl}

\usepackage{beamerthemesplit}

\setbeamertemplate{background canvas}[vertical shading][bottom=red!10,top=blue!10]
\setbeamertemplate{navigation symbols}{}
\setbeamertemplate{headline}{}
\usetheme{Warsaw}
\useinnertheme{rectangles}

\colorlet{darkred}{red!80!black}
\colorlet{darkblue}{blue!80!black}
\colorlet{darkgreen}{green!80!black}


\title{Names and Numbers in Binding}

\author{Martijn Vermaat}
\institute{mvermaat@cs.vu.nl\\
http://www.cs.vu.nl/\~{}mvermaat/}
\date{Literature Study\\
March 13, 2009}


\begin{document}


\frame{\titlepage}


\frame{

  \frametitle{Names and Numbers in Binding}

  \tableofcontents

}


\section{Binding}


\frame{

  \frametitle{Continuation-Passing Style}

  \begin{block}{Direct style}
    Function returns the result of its computation.

    Example: $\lambda x . \, x - 2$
  \end{block}

  \uncover<2->{
    \begin{block}{Continuation passing style}
      Function passes result to a {\em continuation}.

      Example: $\lambda x \, k . \, k \, (x - 2)$
      \uncover<3->{
        \begin{itemize}
        \item Order of evaluation is fixed
        \item Suitable for aggressive optimizations
        \end{itemize}
      }
    \end{block}
  }

}


\frame{

  \frametitle{Transforming to CPS}

  Programs in direct style can be mechanically transformed to equivalent
  prorgrams in CPS:

  \begin{itemize}
    \item Plotkin, 1975
    \item Danvy and Nielsen, 2003
    \item \ldots and many more
  \end{itemize}

}


\frame{

  \frametitle{Plotkin's Original Transformation}

  Plotkin, 1975:
  \begin{align*}
    [\![x]\!]               &= \lambda k. \, k \, x\\
    [\![\lambda x. \, M]\!] &= \lambda k. \, k \, (\lambda x. \, [\![M]\!])\\
    [\![M \, N]\!]          &= \lambda k. \, [\![M]\!] \, (\lambda m. \, [\![N]\!] \, (\lambda n. \, m \, n \, k))
  \end{align*}

  \uncover<2->{
    Generates many administrative redexes:
    \begin{align*}
      [\![(\lambda x. \, x) \, y]\!] &= \lambda k. \, (\lambda k. \, k \, (\lambda x. \, (\lambda k. \, k \, x))) \, (\lambda m. \, (\lambda k. \, k \, y) \, (\lambda n. \, m \, n \, k))\\
                                     &\rightarrow_{\beta} \lambda k. \, (\lambda m. \, (\lambda k. \, k \, y) \, (\lambda n. \, m \, n \, k)) \, (\lambda x. \, (\lambda k. \, k \, x))\\
                                     &\rightarrow_{\beta} \lambda k. \, (\lambda k. \, k \, y) \, (\lambda n. \, (\lambda x. \, (\lambda k. \, k \, x)) \, n \, k)\\
                                     &\rightarrow_{\beta} \lambda k. \, (\lambda n. \, (\lambda x. \, (\lambda k. \, k \, x)) \, n \, k) \, y\\
                                     &\rightarrow_{\beta} \lambda k. \, (\lambda x. \, (\lambda k. \, k \, x)) \, y \, k\\
    \end{align*}
  }

}


\frame{

  \frametitle{Plotkin Optimized}

  Slightly optimized version of Plotkin's original:

  \begin{align*}
    [\![x]\!] \triangleright k               &= k \, x\\
    [\![\lambda x. \, M]\!] \triangleright k &= k \, (\lambda x \, k. \, [\![M]\!] \triangleright k)\\
    [\![M \, N]\!] \triangleright k          &= [\![M]\!] \triangleright \lambda m. \, [\![N]\!] \triangleright \lambda n. \, m \, n \, k
  \end{align*}

  \uncover<2->{
    Generates fewer administrative redexes:
    \begin{align*}
      [\![(\lambda x. \, x) \, y]\!] \triangleright k &= (\lambda m. \, (\lambda n. \, m \, n \, k) \, y) \, (\lambda x \, k. \, k \, x)\\
                                                      &\rightarrow_{\beta} (\lambda n. \, (\lambda x \, k. \, k \, x) \, n \, k) \, y\\
                                                      &\rightarrow_{\beta} (\lambda x \, k. \, k \, x) \, y \, k
    \end{align*}
  }

}


\section{Correct Compilers}


\frame{

  \frametitle{Verifying a CPS Transformation}

  \tableofcontents[currentsection]

}


\frame{

  \frametitle{Program Compilation}

  Traditionally:

  \begin{enumerate}
    \item Source program is proven correct
    \item Source program is compiled to binary code
    \item Binary code is executed
  \end{enumerate}

  \uncover<2->{
    {\bf Observation:} No guarantees on correctness of executed program.
  }

}


\section{Discussion and Related Work}


\frame{

  \frametitle{Verifying a CPS Transformation}

  \tableofcontents[currentsection]

}


\frame{

  \frametitle{Design Choices}

  (Two-sorted) de Bruijn indices:
  \begin{itemize}
    \item Binding and $\alpha$-conversion (POPLmark challenge)
    \item Lifting
  \end{itemize}

  \uncover<2->{
    Big-step operational semantics:
    \begin{itemize}
      \item Administrative redexes
      \item No diverging source programs
    \end{itemize}
  }

  \uncover<3->{
    Coq:
    \begin{itemize}
      \item Code extraction
      \item Preference
    \end{itemize}
  }

}


\frame{

  \frametitle{Related Work}

  Minamide and Okuma, 2003: {\em Verifying CPS Transformations in Isabelle/HOL}
  \begin{itemize}
    \item Named variables, no $\alpha$-conversion or explicit renaming
    \item Small-step operational semantics
  \end{itemize}

  Tian, 2006: {\em Mechanically Verifying Correctness of CPS Compilation}
  \begin{itemize}
    \item Twelf
    \item Higher-order abstract syntax
    \item Combination of big-step and small-step operational semantics
  \end{itemize}

  Chlipala, 2007: {\em A Certified Type-Preserving Compiler from Lambda Calculus to Assembly Language}
  \begin{itemize}
    \item Coq
    \item de Bruijn indices
    \item Denotational semantics
    \item Dependent types with focus on automated proofs
  \end{itemize}

}


\frame{

  \frametitle{Conclusion}

  \begin{itemize}
    \item Verifying transformations such as CPS is tedious, but necessary
    \item $\alpha$-conversion is a big problem in mechanized proofs
    \item Closer look at related work is needed for more conclusions
  \end{itemize}

}


\begin{frame}

  \frametitle{Questions and Further Reading}

  Questions?\\[4em]

  \begin{block}{Further Reading}
    \begin{itemize}
      \item Plotkin, 1975: {\em Call-by-name, Call-by-value and the lambda-calculus}
      \item Danvy and Filinski, 1992: {\em Representing control: a study of the CPS transformation}
      \item Appel, 1992: {\em Compiling with Continuations}
      \item Compcert: \texttt{http://pauillac.inria.fr/\~{}xleroy/compcert/}
      \item Lambda Tamer: \texttt{http://ltamer.sourceforge.net/}
    \end{itemize}
  \end{block}

\end{frame}


\end{document}
