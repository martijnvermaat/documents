\documentclass[a4paper,11pt]{article}
\usepackage[english]{babel}
\usepackage{a4}


% Use some subversion information
\usepackage{svnkw}
\svnid{$Id$}


\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}


% Don't add chapter to figure numbering
\renewcommand\thefigure{\arabic{figure}}


\usepackage{listings}


\lstdefinelanguage{Coq}{
  mathescape=true,
  texcl=false,
  keywords={Require, Declare},
  morekeywords={forall, exists, with, match, let, in, if, then, else},
  morekeywords={
    destruct, change, Variable, Inductive, CoInductive, Fixpoint, CoFixpoint, Definition,
    Lemma, Theorem, Proof, Axiom, Local, Save, Grammar, Syntax, Intro, Trivial,
    Qed, Intros, Symmetry, Simpl, Rewrite, Apply, Elim, Assumption, Left,
    Cut, Case, Auto, Unfold, Exact, Right},
  morekeywords={Section, Module, End},
  %emph={[1]Type, Set, nat, bool}, emphstyle={[1]\textit},
  comment=[s]{(*}{*)},
  showstringspaces=false,
}%[keywords,comments,strings]%


\lstset{
  numbers=none,
  basicstyle=\footnotesize\ttfamily,
  frame=tb,
  language=Coq,
  captionpos=b,
  xleftmargin=0em,
  xrightmargin=0em,
  aboveskip=1em,
  belowskip=1em
}


% Must be last in preamble
\usepackage[
  pdftex,
  colorlinks,
  citecolor=black,
  filecolor=black,
  linkcolor=black,
  urlcolor=black,
  pdfauthor={Martijn Vermaat},
  pdftitle={Mechanized Reasoning about Languages with Binding},
  pdfsubject={TODO},
  pdfkeywords={lambda calculus, binding, types, program verification, poplmark},
  draft=true % TODO: draft false, remove draft note in title page
]{hyperref}
\usepackage[figure]{hypcap}


\title{Mechanized Reasoning about Languages~with~Binding}

\author{
  Martijn Vermaat\\[0.3em]
  \href{mailto:mvermaat@cs.vu.nl}{\texttt{mvermaat@cs.vu.nl}}
}
\date{Literature Study (\emph{draft r\svnrev})}


\begin{document}

\maketitle


\begin{abstract}
  % TODO
  Abstract text.
\end{abstract}


\section{Introduction}\label{sec:introduction}

% TODO: niet zo focussen op twee hokjes, beter gewoon zeggen wat we
% technisch willen
% TODO: misschien tekst over context van het probleem verplaatsen naar
% achteren in een 'discussion' sectie

As is the case in many academic fields, theory and practice in the field
of programming languages are not as close as we would like them to be.
Language designers often take a pragmatic approach, where the focus is
on the observable behaviour of implementations and not much attention
is paid to prove properties of the language in a formal way.
Research on the theory of programming languages has a long tradition and
provides us with a large base of techniques and results, but is mostly
isolated in academic settings.
Applying formal reasoning to current programming language development
has the premise of rigorously defined practical languages with provable
properties, but is unfortunately not commonplace.

Many tools have become available to aid formal reasoning in a mechanical
way, such as proof assistants and theorem provers.
Researchers can use these tools to obtain machine-checked and reusable
proofs while language designers can use them to formally define languages,
clearing the way for formal reasoning.
There are several issues holding back large-scale application of such
tools, both technical and non-technical. In this literature study, we will
focus on one specific technical aspect.

A major difficulty in formal reasoning about languages are bindings and
bound variables.
Traditionally, named variables are used in the representation of terms
and reasoning is done modulo $\alpha$-equivalence.
While this approach yields easy to read and sufficiently precise
reasoning on paper,
mechanical reasoning with named variables is hard:
identification of $\alpha$-equivalent terms has to be made precise and
substitution requires renaming of bound variables in order to prevent
accidental binding of free variables.

Several approaches exist to remedy these problems.
Some of them try to make it easier to work with named variables, while
others propose alternate representations for bindings and variables.
We will study some of these approaches in the context of mechanical
reasoning, focussing on concrete representations for terms using names
and numbers for variables.
The approaches are illustrated with applications using the Coq proof
assistant.


\section{Representing Bindings}\label{sec:representing}

The most common problems associated with bindings are $\alpha$-equivalence
and $\alpha$-conversion.
They are actually notions related to the traditional representation where
names are used for variables, and may or may not be relevant issues with
other representations.
Some representations however, have dual notions, for example lifting of
so-called de Bruijn indices is dual to $\alpha$-conversion.

We use untyped pure $\lambda$-calculus to introduce three concrete
representations for terms using names and numbers for variables.


\subsection{Named Variables}

Untyped $\lambda$-calculus has function application and abstraction over
variables. Using named variables, its terms can be represented with the
grammar
\begin{align*}
  M ::=             &\; x
  && \text{variable} \\
  \llap{\textbar\:} &\; \lambda x. \; M
  && \text{abstraction} \\
  \llap{\textbar\:} &\; M \; M
  && \text{application}
\end{align*}
where $x$ ranges over a countably infinite set of variables.
An abstraction introduces a name, occurences of which are said to be
bound by it in its scope. The scope of an abstraction $\lambda x.M$ is
the body $M$ minus any subterm of $M$ that is an abstraction over the
same name $x$.

\subsubsection*{$\alpha$-equivalence and $\alpha$-conversion}

$\alpha$-conversion is the process of renaming bound variables, such
that abstractions bind exactly the variables they did originally.
Two terms are $\alpha$-equivalent if they are the same modulo
$\alpha$-conversion.
For example, the following are $\alpha$-equivalent pairs of terms:
\begin{align*}
  \lambda x&. \; x & (\lambda z&. \; z \; x) \; z & \lambda x&. \; \lambda y. \; x \; (y \; z)\\
  \lambda z&. \; z & (\lambda y&. \; y \; x) \; z & \lambda y&. \; \lambda x. \; y \; (x \; z)
\end{align*}
When reasoning about terms, it is often needed to identify $\alpha$-equivalent
terms. This can result in a lot of extra work if the reasoning is done in a
tool such as a proof assistant.

Manipulation of terms can result in accidental binding of variables that
where previously not bound or bound by another abstraction.
Consider substituting $x$ for $y$ in $\lambda x. \; y \; x$.
The free variable $x$ becomes bound by the abstraction over $x$ and looses
its possible contextual meaning.
This is a phenomenon that should be avoided.
A possible solution is applying $\alpha$-conversion to rename the bound
variable $x$ before doing the substitution.
Substituting $x$ for $y$ in $\lambda z. \; y \; z$ does not bind $x$.

\subsubsection*{Substitution}

Let us consider substitution some more.
Substituting $N$ for $x$ in $M$ is usually defined as
\begin{align*}
  x[N/x]                 &= N\\
  y[N/x]                 &= y                      && \text{$x \neq y$} \\
  (\lambda y.\; M')[N/x] &= \lambda y. \; M'[N/x]  && \text{$x \neq y$ and $y$ not free in $N$} \\ % TODO: fix layout
  (M_1 \; M_2)[N/x]      &= M_1[N/x] \; M_2[N/x]
\end{align*}
which is not directly implementable as an operation in this form, because
of the declarative side condition in the case of abstraction.

Of course, $\alpha$-conversion can be used to eliminate the undefined
case, yielding
\begin{align*}
  x[N/x]              &= \text{$N$ if $x = y$, $y$ otherwise}\\
  (\lambda y.M')[N/x] &= \lambda z.M'[z/y][N/x]  && \text{$z$ not free in $N, M'$} \\ % TODO: fix layout
  (M_1 \; M_2)[N/x]   &= M_1[N/x] \; M_2[N/x] \text{ .}
\end{align*}

(this is not structurally recursive)

Some Coq code.


\subsection{de Bruijn Indices}

\begin{align*}
  M ::=             &\; n
  && \text{variable} \\
  \llap{\textbar\:} &\; \lambda .M
  && \text{abstraction} \\
  \llap{\textbar\:} &\; M \; M
  && \text{application} \\
\end{align*}


\subsection{Locally Nameless Representation}

\begin{align*}
  M ::=             &\; x
  && \text{free variable} \\
  \llap{\textbar\:} &\; n
  && \text{bound variable} \\
  \llap{\textbar\:} &\; \lambda .M
    && \text{abstraction} \\
  \llap{\textbar\:} &\; M \; M
  && \text{application} \\
\end{align*}

I am not a number, I am a free variable.


\section{Applications}

\subsection{The POPLMark Challenge}

POPLmark 1a in Coq by Stump \cite{Stump-05}.
POPLmark in Coq by Vouillon \cite{Vouillon-05}.
McBride and McKinna \cite{McBride-McKinna-04}, implemented for POPLmark in Coq by Leroy \cite{Leroy-07}.

\subsection{Engineering Formal Metatheory}


\section{Discussion}\label{sec:discussion}

\subsection{Others Representations}

Nominal, higher order abstract syntax \cite{Capretta-Felty-06}, nested datatypes (Hirschowitz and Maggesi).

\subsection{Comparison}

\subsection{Conclusion and Related Work}


\nocite{*}
\bibliographystyle{amsplain}
\bibliography{literature-study}


\end{document}
