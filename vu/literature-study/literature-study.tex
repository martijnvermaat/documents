\documentclass[a4paper,11pt]{article}
\usepackage[english]{babel}
\usepackage{a4}


% Use some subversion information
\usepackage{svnkw}
\svnid{$Id$}


\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}


% Don't add chapter to figure numbering
\renewcommand\thefigure{\arabic{figure}}


\usepackage{listings}


\lstdefinelanguage{Coq}{
  mathescape=true,
  texcl=false,
  keywords={Require, Declare},
  morekeywords={forall, exists, with, match, let, in, if, then, else},
  morekeywords={
    destruct, change, Variable, Inductive, CoInductive, Fixpoint, CoFixpoint, Definition,
    Lemma, Theorem, Proof, Axiom, Local, Save, Grammar, Syntax, Intro, Trivial,
    Qed, Intros, Symmetry, Simpl, Rewrite, Apply, Elim, Assumption, Left,
    Cut, Case, Auto, Unfold, Exact, Right},
  morekeywords={Section, Module, End},
  %emph={[1]Type, Set, nat, bool}, emphstyle={[1]\textit},
  comment=[s]{(*}{*)},
  showstringspaces=false,
}%[keywords,comments,strings]%


\lstset{
  numbers=none,
  basicstyle=\footnotesize\ttfamily,
  frame=tb,
  language=Coq,
  captionpos=b,
  xleftmargin=0em,
  xrightmargin=0em,
  aboveskip=1em,
  belowskip=1em
}


% Must be last in preamble
\usepackage[
  pdftex,
  colorlinks,
  citecolor=black,
  filecolor=black,
  linkcolor=black,
  urlcolor=black,
  pdfauthor={Martijn Vermaat},
  pdftitle={Mechanized Reasoning about Languages with Binding},
  pdfsubject={TODO},
  pdfkeywords={lambda calculus, binding, types, program verification, poplmark},
  draft=true % TODO: draft false, remove draft note in title page
]{hyperref}
\usepackage[figure]{hypcap}


\title{Mechanized Reasoning about Languages~with~Binding}

\author{
  Martijn Vermaat\\[0.3em]
  \href{mailto:mvermaat@cs.vu.nl}{\texttt{mvermaat@cs.vu.nl}}
}
\date{Literature Study (\emph{draft r\svnrev})}


\begin{document}

\maketitle


\begin{abstract}
  % TODO
  Abstract text.
\end{abstract}


\section{Introduction}\label{sec:introduction}

% TODO: niet zo focussen op twee hokjes, beter gewoon zeggen wat we
% technisch willen
% TODO: misschien tekst over context van het probleem verplaatsen naar
% achteren in een 'discussion' sectie

As is the case in many academic fields, theory and practice in the field
of programming languages are not as close as we would like them to be.
Language designers often take a pragmatic approach, where the focus is
on the observable behaviour of implementations and not much attention
is paid to prove properties of the language in a formal way.
Research on the theory of programming languages has a long tradition and
provides us with a large base of techniques and results, but is mostly
isolated in academic settings.
Applying formal reasoning to current programming language development
has the premise of rigorously defined practical languages with provable
properties, but is unfortunately not commonplace.

Many tools have become available to aid formal reasoning in a mechanical
way, such as proof assistants and theorem provers.
Researchers can use these tools to obtain machine-checked and reusable
proofs while language designers can use them to formally define languages,
clearing the way for formal reasoning.
There are several issues holding back large-scale application of such
tools, both technical and non-technical. In this literature study, we will
focus on one specific technical aspect.

A major difficulty in formal reasoning about languages are bindings and
bound variables.
Traditionally, named variables are used in the representation of terms
and reasoning is done modulo $\alpha$-equivalence.
While this approach yields easy to read and sufficiently precise
reasoning on paper,
mechanical reasoning with named variables is hard:
identification of $\alpha$-equivalent terms has to be made precise and
substitution requires renaming of bound variables in order to prevent
accidental binding of free variables.

Several approaches exist to remedy these problems.
Some of them try to make it easier to work with named variables, while
others propose alternate representations for bindings and variables.
We will study some of these approaches in the context of mechanical
reasoning, focussing on concrete representations for terms using names
and numbers for variables.
The approaches are illustrated with applications using the Coq proof
assistant.


\section{Representing Bindings}\label{sec:representing}

The most common problems associated with bindings are $\alpha$-equivalence
and $\alpha$-conversion.
They are actually notions related to the traditional representation where
names are used for variables, and may or may not be relevant issues with
other representations.
Some representations however, have dual notions, for example lifting of
so-called de Bruijn indices is dual to $\alpha$-conversion.

We use untyped pure $\lambda$-calculus to introduce three concrete
representations for terms using names and numbers for variables.


\subsection{Named Variables}

Untyped $\lambda$-calculus has function application and abstraction over
variables. Using named variables, its terms can be represented with the
grammar
\begin{align*}
  M ::=             &\; x
  && \text{variable} \\
  \llap{\textbar\:} &\; \lambda x. \; M
  && \text{abstraction} \\
  \llap{\textbar\:} &\; M \; M
  && \text{application}
\end{align*}
where $x$ ranges over a countably infinite set of variables.
An abstraction introduces a name, occurences of which are said to be
bound by it in its scope. The scope of an abstraction $\lambda x.M$ is
the body $M$ minus any subterm of $M$ that is an abstraction over the
same name $x$.

\subsubsection*{$\alpha$-equivalence and $\alpha$-conversion}

$\alpha$-conversion is the process of renaming bound variables, such
that abstractions bind exactly the variables they did originally.
Two terms are $\alpha$-equivalent if they are the same modulo
$\alpha$-conversion.
For example, the following are $\alpha$-equivalent pairs of terms:
\begin{align*}
  \lambda x&. \; x & (\lambda z&. \; z \; x) \; z & \lambda x&. \; \lambda y. \; x \; (y \; z)\\
  \lambda z&. \; z & (\lambda y&. \; y \; x) \; z & \lambda y&. \; \lambda x. \; y \; (x \; z)
\end{align*}
When reasoning about terms, it is often needed to identify $\alpha$-equivalent
terms. This can result in a lot of extra work if the reasoning is done in a
tool such as a proof assistant.

Manipulation of terms can result in accidental binding of variables that
where previously not bound or bound by another abstraction.
Consider substituting $x$ for $y$ in $\lambda x. \; y \; x$.
The free variable $x$ becomes bound by the abstraction over $x$ and looses
its possible contextual meaning.
This is a phenomenon that should be avoided.
A possible solution is applying $\alpha$-conversion to rename the bound
variable $x$ before doing the substitution.
Substituting $x$ for $y$ in $\lambda z. \; y \; z$ does not bind $x$.

\subsubsection*{Substitution}

Let us consider substitution some more.
Substituting $N$ for $x$ in $M$ is usually defined as
\begin{align*}
  x[N/x]                 &= N\\
  y[N/x]                 &= y                      && \text{$x \neq y$} \\
  (\lambda y.\; M')[N/x] &= \lambda y. \; M'[N/x]  && \text{$x \neq y$ and $y$ not free in $N$} \\ % TODO: fix layout
  (M_1 \; M_2)[N/x]      &= M_1[N/x] \; M_2[N/x]
\end{align*}
which is not directly implementable as an operation in this form, because
of the declarative side condition in the case of abstraction.
Of course, $\alpha$-conversion can be used to eliminate the undefined
case, yielding
\begin{align*}
  x[N/x]              &= \text{$N$ if $x = y$, $y$ otherwise}\\
  (\lambda y.M')[N/x] &= \lambda z.M'[z/y][N/x]  && \text{$z$ not free in $N, M'$} \\ % TODO: fix layout
  (M_1 \; M_2)[N/x]   &= M_1[N/x] \; M_2[N/x] \text{ .}
\end{align*}
Note that this is not a structurally recursive definition, since
$M'[z/y]$ is not a subterm of $\lambda y.M'$.
Structural recursion is prefered over recursion on some other measure
(e.g. term size), especially in a tool like Coq where structural
induction principles are automatically generated for inductive
definitions and structurally recursive functions don't need explicit
termination proofs.

\subsubsection*{Named Variables in Coq}

Using named variables, $\lambda$-calculus terms can be represented in the
Coq proof assistant with the following datatype, assuming some type for
names on which equality is decidable.
\begin{lstlisting}
Parameter name : Set.
Parameter eq_name : forall (x y : name), {x = y} + {x <> y}.

Inductive term : Set :=
  | Var : name -> term
  | Abs : name -> term -> term
  | App : term -> term -> term.
\end{lstlisting}
We also assume a way to generate fresh names with \lstinline{fresh_name},
that returns a name not in a given a list of names.

As a first try in translating the substitution operation to Coq, the
definition below of \lstinline{subst_x} will fail because the definition
is not structurally recursive on \lstinline{t'} as noted above.
\begin{lstlisting}
Fixpoint rename (n n':name) (t:term) {struct t} : term :=
  match t with
  | Var x =>
      if eq_name x n then Var n' else t
  | Abs x b =>
      Abs (if eq_name x n then n' else x) (rename n n' b)
  | App f a =>
      App (rename n n' f) (rename n n' a)
end.

(* Ill-formed capture-avoiding substitution *)
Fixpoint subst_x (t:term) (n:name) (t':term)
  {struct t'} : term :=
  match t' with
  | Var x =>
      if eq_name x n then t else t'
  | Abs x b =>
      (* We always rename, this could of course be improved *)
      let z := fresh_name (n :: (free_vars t) ++ (free_vars b))
      in
      Abs z (subst_x t n (rename x z b))
  | App f a =>
      App (subst_x t n f) (subst_x t n a)
end.
\end{lstlisting}

A solution is to use the term size as a recursion measure.
\begin{lstlisting}
Fixpoint size (t:term) : nat :=
  match t with
  | Var _   => 0
  | Abs x b => S (size b)
  | App f a => 1 + (size f) + (size a)
end.

Lemma size_rename : forall (n n':name) (t:term),
  size (rename n n' t) = size t.
Proof.
  unfold size.
  unfold rename.
  induction t;
    [ case (eq_name n0 n); intro; trivial  (* Var *)
    | congruence                           (* Abs *)
    | congruence ].                        (* App *)
Qed.

(* Capture-avoiding substitution by recursion on size. *)
Function subst (t:term) (n:name) (t':term)
  {measure size t'} : term :=
  match t' with
  | Var x =>
      if eq_name x n then t else t'
  | Abs x b =>
      let z := fresh_name (n :: (free_vars t) ++ (free_vars b))
      in
      Abs z (subst t n (rename x z b))
  | App f a =>
      App (subst t n f) (subst t n a)
end.
Proof.
  intros. rewrite size_rename. auto.
  intros. unfold size. inversion f; omega.
  intros. unfold size. inversion a; omega.
Defined.
\end{lstlisting}
This definition of \lstinline{subst} requires us to provide three short
proofs for Coq to be assured of termination.

In search of a structural recursive substitution operation, Stoughton
suggests the simultaneous substitution $M \sigma$
\begin{align*}
  x \sigma              &= \sigma x\\
  (\lambda x.M') \sigma &= \lambda y.(M' \; \sigma[y/x])  && \text{$y$ not free in $M', \sigma$}\\
  (M_1 \; M_2) \sigma   &= M_1 \sigma \; M_2 \sigma
\end{align*}
where
\begin{equation*}
  \sigma[N/y] \; x =
  \begin{cases}
    N        & \text{if $x = y$ ,}\\
    \sigma x & \text{otherwise .}
  \end{cases}
\end{equation*}
Substituting $N$ for $x$ in $M$ is now $M \; \iota [N/x]$ with $\iota$
the identity substitution.
This structurally recursive operation is easily implemented in Coq.
\begin{lstlisting}
(* Apply a list of substitutions to a name. *)
Fixpoint apply_subst (l:list (term*name)) (n:name)
  {struct l} : term :=
  match l with
  | nil        => Var n
  | (t, x)::l' => if eq_name x n then t else apply_subst l' n
end.

(* Capture-avoiding simultaneous substitution. *)
Fixpoint sim_subst (l:list (term*name)) (t:term)
  {struct t} : term :=
  match t with
  | Var x =>
      apply_subst l x
  | Abs x b =>
      let z := fresh_name ((free_vars_sub l) ++ (free_vars b))
      in
      Abs z (sim_subst ((Var z, x)::l) b)
  | App f a =>
      App (sim_subst l f) (sim_subst l a)
end.

(* Simple substitution in terms of simultaneous substitution. *)
Definition subst' (t:term) (n:name) (t':term) : term :=
  sim_subst ((t, n) :: nil) t'.
\end{lstlisting}

\subsubsection*{Concluding}

The above examples illustrate that $\alpha$-conversion to prevent
accidental binding of variables is not a trivial issue in an automated
setting.
The assumption of being able to generate fresh names might be troublesome
and the traditional way of defining substitution is not structurally
recursive.

Perhaps an even greater problem is that of $\alpha$-equivalence.
% TODO: some more text


\subsection{de Bruijn Indices}

As an alternative representation for $\lambda$-calculus terms, de Bruijn
proposed a representation using natural numbers instead of names.
A variable is represented by the number of binders between itself and its
abstraction (called a de Bruijn index), yielding the following grammar.
\begin{align*}
  M ::=             &\; n
  && \text{variable} \\
  \llap{\textbar\:} &\; \lambda . \; M
  && \text{abstraction} \\
  \llap{\textbar\:} &\; M \; M
  && \text{application}
\end{align*}
where $n$ ranges over the natural numbers.
The following are some example terms in the traditional representation
(above) and in the representation with de Bruijn indices (below).
\begin{align*}
  \lambda x&. \; x & (\lambda z&. \; z \; x) \; z & \lambda x&. \; \lambda y. \; x \; (y \; z)\\
  \lambda &. \; 0  & (\lambda &. \; 0 \; 1) \; 2  & \lambda &. \; \lambda . \; 1 \; (0 \; 2)
\end{align*}

\subsubsection*{Lifting}

Abstractions no longer introduce names, eliminating the need for
$\alpha$-conversion of bound variables.
However, manipulation of terms may still accidentally capture
variables when a de Bruijn index is moved over an abstraction.
In that case the index should be updated in order to still refer to the
original binding site.
This operation is called lifting. We denote the simple lifting operation
of incrementing all free variables in $M$ by $\uparrow \! M$.

% TODO: example

\subsubsection*{Substitution}

Substitution.

\subsubsection*{de Bruijn Indices in Coq}


\subsection{Locally Nameless Representation}

\begin{align*}
  M ::=             &\; x
  && \text{free variable} \\
  \llap{\textbar\:} &\; n
  && \text{bound variable} \\
  \llap{\textbar\:} &\; \lambda .M
    && \text{abstraction} \\
  \llap{\textbar\:} &\; M \; M
  && \text{application} \\
\end{align*}

I am not a number, I am a free variable.


\section{Applications}

\subsection{The POPLMark Challenge}

POPLmark 1a in Coq by Stump \cite{Stump-05}.
POPLmark in Coq by Vouillon \cite{Vouillon-05}.
McBride and McKinna \cite{McBride-McKinna-04}, implemented for POPLmark in Coq by Leroy \cite{Leroy-07}.

\subsection{Engineering Formal Metatheory}


\section{Discussion}\label{sec:discussion}

\subsection{Others Representations}

Nominal, higher order abstract syntax \cite{Capretta-Felty-06}, nested datatypes (Hirschowitz and Maggesi).

\subsection{Comparison}

\subsection{Conclusion and Related Work}


\nocite{*}
\bibliographystyle{amsplain}
\bibliography{literature-study}


\end{document}
