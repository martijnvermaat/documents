\documentclass[a4paper,11pt]{article}
\usepackage[english]{babel}
\usepackage{a4}


% TODO:
% opmaak code blokken (misschien floating numbered listings)
% citations
% variable convention
% make it clear that there are more ways to program things in coq
% check if naming is consistent (term, variable, index, etc names)


% Use some subversion information
\usepackage{svnkw}
\svnid{$Id$}


\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}


\usepackage{listings}

\lstdefinelanguage{Coq}{
  mathescape=true,
  texcl=false,
  keywords={Require, Declare},
  morekeywords={forall, exists, with, match, let, in, if, then, else},
  morekeywords={
    destruct, change, Variable, Inductive, CoInductive, Fixpoint, CoFixpoint, Definition,
    Lemma, Theorem, Proof, Axiom, Local, Save, Grammar, Syntax, Intro, Trivial,
    Qed, Intros, Symmetry, Simpl, Rewrite, Apply, Elim, Assumption, Left,
    Cut, Case, Auto, Unfold, Exact, Right},
  morekeywords={Section, Module, End},
  %emph={[1]Type, Set, nat, bool}, emphstyle={[1]\textit},
  comment=[s]{(*}{*)},
  showstringspaces=false,
}%[keywords,comments,strings]%

\lstset{
  numbers=none,
  basicstyle=\footnotesize\ttfamily,
  frame=tb,
  language=Coq,
  captionpos=b,
  xleftmargin=0em,
  xrightmargin=0em,
  aboveskip=1em,
  belowskip=1em
}

% Add subsection to listing numbering
%\renewcommand\thelstlisting{\thesubsection .\arabic{lstlisting}}


% Must be last in preamble
\usepackage[
  pdftex,
  colorlinks,
  citecolor=black,
  filecolor=black,
  linkcolor=black,
  urlcolor=black,
  pdfauthor={Martijn Vermaat},
  pdftitle={Mechanized Reasoning about Languages with Binding},
  pdfsubject={TODO},
  pdfkeywords={lambda calculus, binding, types, program verification, poplmark},
  draft=true % TODO: draft false, remove draft note in title page
]{hyperref}
\usepackage[figure]{hypcap}


\title{Mechanized Reasoning about Languages~with~Binding}

\author{
  Martijn Vermaat\\[0.3em]
  \href{mailto:mvermaat@cs.vu.nl}{\texttt{mvermaat@cs.vu.nl}}
}
\date{Literature Study (\emph{draft r\svnrev})}


\begin{document}

\maketitle


\begin{abstract}
  % TODO: abstract
  Abstract text.
\end{abstract}


\section{Introduction}\label{sec:introduction}

% TODO: niet zo focussen op twee hokjes, beter gewoon zeggen wat we
% technisch willen
% TODO: misschien tekst over context van het probleem verplaatsen naar
% achteren in een 'discussion' sectie

As is the case in many academic fields, theory and practice in the field
of programming languages are not as close as we would like them to be.
Language designers often take a pragmatic approach, where the focus is
on the observable behaviour of implementations and not much attention
is paid to prove properties of the language in a formal way.
Research on the theory of programming languages has a long tradition and
provides us with a large base of techniques and results, but is mostly
isolated in academic settings.
Applying formal reasoning to current programming language development
has the premise of rigorously defined practical languages with provable
properties, but is unfortunately not commonplace.

Many tools have become available to aid formal reasoning in a mechanical
way, such as proof assistants and theorem provers.
Researchers can use these tools to obtain machine-checked and reusable
proofs while language designers can use them to formally define languages,
clearing the way for formal reasoning.
There are several issues holding back large-scale application of such
tools, both technical and non-technical. In this literature study, we will
focus on one specific technical aspect.

A major difficulty in formal reasoning about languages are bindings and
bound variables.
Traditionally, named variables are used in the representation of terms
and reasoning is done modulo $\alpha$-equivalence.
While this approach yields easy to read and sufficiently precise
reasoning on paper,
mechanical reasoning with named variables is hard:
identification of $\alpha$-equivalent terms has to be made precise and
substitution requires renaming of bound variables in order to prevent
accidental binding of free variables.

Several approaches exist to remedy these problems.
Some of them try to make it easier to work with named variables, while
others propose alternate representations for bindings and variables.
We will study some of these approaches in the context of mechanical
reasoning, focussing on concrete representations for terms using names
and numbers for variables.
The approaches are illustrated with applications using the Coq proof
assistant.


\section{Representing Bindings}\label{sec:representing}

The most common problems associated with bindings are $\alpha$-equivalence
and $\alpha$-conversion.
They are actually notions related to the traditional representation where
names are used for variables, and may or may not be relevant issues with
other representations.
Some representations however, have dual notions, for example lifting of
so-called de Bruijn indices is dual to $\alpha$-conversion.

We use untyped pure $\lambda$-calculus \cite{Barendregt-84} to introduce
three concrete representations for terms using names and numbers for
variables.


\subsection{Named Variables}

Untyped $\lambda$-calculus has function application and abstraction over
variables. Using named variables, its terms can be represented with the
grammar
\begin{align*}
  M ::=             &\; x
  && \text{variable} \\
  \llap{\textbar\:} &\; \lambda x. \; M
  && \text{abstraction} \\
  \llap{\textbar\:} &\; M \; M
  && \text{application}
\end{align*}
where $x$ ranges over a countably infinite set of names.
An abstraction introduces a name, occurences of which are said to be
bound by it in its scope. The scope of an abstraction $\lambda x.M$ is
the body $M$ minus any subterm of $M$ that is an abstraction over the
same name $x$.

\subsubsection*{$\alpha$-equivalence and $\alpha$-conversion}

$\alpha$-conversion is the process of renaming bound variables, such
that abstractions bind exactly the variables they did originally.
Two terms are $\alpha$-equivalent if they are the same modulo
$\alpha$-conversion.
For example, the following are $\alpha$-equivalent pairs of terms:
\begin{align*}
  \lambda x&. \; x & (\lambda z&. \; z \; x) \; z & \lambda x&. \; \lambda y. \; x \; (y \; z)\\
  \lambda z&. \; z & (\lambda y&. \; y \; x) \; z & \lambda y&. \; \lambda x. \; y \; (x \; z)
\end{align*}
When reasoning about terms, it is often needed to identify $\alpha$-equivalent
terms.
This can result in a lot of extra work if the reasoning has to be rigorous,
as is the case in a tool like a proof assistant.

Manipulation of terms can result in accidental binding of variables that
where previously not bound or bound by another abstraction.
Consider substituting $x$ for $y$ in $\lambda x. \; y \; x$.
The free variable $x$ becomes bound by the abstraction over $x$ and looses
its possible contextual meaning.
This is a phenomenon that should be avoided.
A possible solution is applying $\alpha$-conversion to rename the bound
variable $x$ to a fresh name, say $z$, before doing the substitution.
Substituting $x$ for $y$ in $\lambda z. \; y \; z$ does not bind $x$.

Barendregt's variable convention is a way to avoid accidental binding of
variables by maintaining the invariant that in any context, all bound
variables in a term are chosen to be different from the free variables.
It is however not straightforward to implement this invariant directly in
mechanical developments and its effects are thus often mimicked by other
technicalities (e.g. explicit renaming or disjoint sets for bound and
free variables).

\subsubsection*{Substitution}

Let us consider substitution some more.
Substituting $N$ for $x$ in $M$ is usually defined as
\begin{align*}
  x[N/x]                 &= N\\
  y[N/x]                 &= y                      && \text{$x \neq y$} \\
  (\lambda y.\; M')[N/x] &= \lambda y. \; M'[N/x]  && \text{$x \neq y$ and $y$ not free in $N$} \\ % TODO: fix layout
  (M_1 \; M_2)[N/x]      &= M_1[N/x] \; M_2[N/x]
\end{align*}
which is not directly implementable as an operation without using the
variable convention, because of the declarative side condition in the
case of abstraction.
Of course, $\alpha$-conversion can be used to eliminate the undefined
case, yielding
\begin{align*}
  x[N/x]              &= N\\
  y[N/x]              &= y                       && \text{$x \neq y$} \\
  (\lambda y.M')[N/x] &= \lambda z.M'[z/y][N/x]  && \text{$z$ not free in $N, M'$} \\ % TODO: fix layout
  (M_1 \; M_2)[N/x]   &= M_1[N/x] \; M_2[N/x]
\end{align*}
Note that this is not a structurally recursive definition, since
$M'[z/y]$ is not necessarily a subterm of $\lambda y.M'$.
Structural recursion is prefered over recursion on some other measure
(e.g. term size), especially in a tool like Coq where structural
induction principles are automatically generated for inductive
definitions and structurally recursive functions don't need explicit
termination proofs.

\subsubsection*{Named Variables in Coq}

Using named variables, $\lambda$-calculus terms can be represented in the
Coq proof assistant with the following datatype, assuming
some type for names on which equality is decidable.
\begin{lstlisting}[frame=,xleftmargin=1em,xrightmargin=1em]
Parameter name : Set.
Parameter eq_name : forall (x y : name), {x = y} + {x <> y}.

Inductive term : Set :=
  | Var : name -> term
  | Abs : name -> term -> term
  | App : term -> term -> term.
\end{lstlisting}
We also assume a way to generate fresh names with \lstinline{fresh_name},
which returns a name that is not in a given a list of names.

As a first try in translating the substitution operation to Coq, the
definition in listing~\ref{lst:names-subst-x} will fail because it
is not structurally recursive on \lstinline{t'} as noted above.
\begin{lstlisting}[float,caption={{\small \em (Named variables)} Renaming},label=lst:names-rename]
Fixpoint rename (n n':name) (t:term) {struct t} : term :=
  match t with
  | Var x =>
      if eq_name x n then Var n' else t
  | Abs x b =>
      Abs (if eq_name x n then n' else x) (rename n n' b)
  | App f a =>
      App (rename n n' f) (rename n n' a)
end.
\end{lstlisting}
\begin{lstlisting}[float,caption={{\small \em (Named variables)} Ill-formed capture-avoiding substitution},label=lst:names-subst-x]
Fixpoint subst_x (t:term) (n:name) (t':term)
  {struct t'} : term :=
  match t' with
  | Var x =>
      if eq_name x n then t else t'
  | Abs x b =>
      let z := fresh_name (n :: (free_vars t) ++ (free_vars b))
      in
      Abs z (subst_x t n (rename x z b))
  | App f a =>
      App (subst_x t n f) (subst_x t n a)
end.
\end{lstlisting}
A solution is to use the term size as a recursion measure as in
listing~\ref{lst:names-subst}.
\begin{lstlisting}[float,caption={{\small \em (Named variables)} Capture-avoiding substitution, recursion on size},label=lst:names-subst]
Fixpoint size (t:term) : nat :=
  match t with
  | Var _   => 0
  | Abs x b => S (size b)
  | App f a => 1 + (size f) + (size a)
end.

Lemma size_rename : forall (n n':name) (t:term),
  size (rename n n' t) = size t.
Proof.
  unfold size.
  unfold rename.
  induction t;
    [ case (eq_name n0 n); intro; trivial  (* Var *)
    | congruence                           (* Abs *)
    | congruence ].                        (* App *)
Qed.

Function subst (t:term) (n:name) (t':term)
  {measure size t'} : term :=
  match t' with
  | Var x =>
      if eq_name x n then t else t'
  | Abs x b =>
      let z := fresh_name (n :: (free_vars t) ++ (free_vars b))
      in
      Abs z (subst t n (rename x z b))
  | App f a =>
      App (subst t n f) (subst t n a)
end.
Proof.
  intros. rewrite size_rename. auto.
  intros. unfold size. inversion f; omega.
  intros. unfold size. inversion a; omega.
Defined.
\end{lstlisting}
This definition of \lstinline{subst} requires us to additionally provide
three short proofs for Coq to be assured of termination.

\subsubsection*{Simultaneous Substitution}

In search of a structural recursive substitution operation, Stoughton
\cite{Stoughton-88} suggests the simultaneous substitution $M \sigma$
\begin{align*}
  x \sigma              &= \sigma x\\
  (\lambda x.M') \sigma &= \lambda y.(M' \; \sigma[y/x])  && \text{$y$ not free in $M', \sigma$}\\
  (M_1 \; M_2) \sigma   &= M_1 \sigma \; M_2 \sigma
\end{align*}
where
\begin{equation*}
  \sigma[N/y] \; x =
  \begin{cases}
    N        & \text{if $x = y$,}\\
    \sigma x & \text{otherwise}
  \end{cases}
\end{equation*}
Substituting $N$ for $x$ in $M$ is now $M \; \iota [N/x]$ with $\iota$
the identity substitution.
This structurally recursive operation is easily implemented in Coq, as
is shown in listing~\ref{lst:names-simsubst}, and simple substitution
can be written as
\begin{lstlisting}[float,caption={{\small \em (Named variables)} Capture-avoiding simultaneous substitution},label=lst:names-simsubst]
Fixpoint apply_subst (l:list (term*name)) (n:name)
  {struct l} : term :=
  match l with
  | nil        => Var n
  | (t, x)::l' => if eq_name x n then t else apply_subst l' n
end.

Fixpoint sim_subst (l:list (term*name)) (t:term)
  {struct t} : term :=
  match t with
  | Var x =>
      apply_subst l x
  | Abs x b =>
      let z := fresh_name ((free_vars_sub l) ++ (free_vars b))
      in
      Abs z (sim_subst ((Var z, x)::l) b)
  | App f a =>
      App (sim_subst l f) (sim_subst l a)
end.
\end{lstlisting}
\begin{lstlisting}[frame=,xleftmargin=1em,xrightmargin=1em]
Definition subst' (t:term) (n:name) (t':term) : term :=
  sim_subst ((t, n) :: nil) t'.
\end{lstlisting}

\subsubsection*{Concluding} % TODO: andere subsubsectie titel

The above examples illustrate that $\alpha$-conversion to prevent
accidental binding of variables is not a trivial issue in an automated
setting.
The assumption of being able to generate fresh names might be troublesome
and standard operations such as simple substitution are not structurally
recursive.

Perhaps an even greater problem is that of $\alpha$-equivalence, depending
on the task at hand.
Terms can be treated as their $\alpha$-equivalence class, properties of
terms with bound variables can sometimes be parameterized by their names,
or terms can be translated to some canonically named variant, to name just
a few techniques to overcome this problem.
Most of these require a lot of tedious work that distracts from the actual
task at hand.

An obvious advantage of using a representation with named variables is
that it is the same as the usual on-paper notation.
It can therefore be read by anyone familiar with traditional work and there
is no need to justify the relation between the original object language and
the way it is represented.


\subsection{de Bruijn Indices}

As an alternative representation for $\lambda$-calculus terms, de Bruijn
\cite{deBruijn-72} proposes a representation using natural numbers instead
of names.
A variable is represented by the number of binders between itself and its
abstraction (called a de Bruijn index), yielding the grammar
\begin{align*}
  M ::=             &\; n
  && \text{variable} \\
  \llap{\textbar\:} &\; \lambda . \; M
  && \text{abstraction} \\
  \llap{\textbar\:} &\; M \; M
  && \text{application}
\end{align*}
where $n$ ranges over the natural numbers.
The following are some example terms in the traditional representation
(above) and in the representation with de Bruijn indices (below):
\begin{align*}
  \lambda x&. \; x & (\lambda z&. \; z \; x) \; z & \lambda x&. \; \lambda y. \; x \; (y \; z)\\
  \lambda &. \; 0  & (\lambda &. \; 0 \; 1) \; 2  & \lambda &. \; \lambda . \; 1 \; (0 \; 2)
\end{align*}
A major advantage of de Bruijn indices in machine-assisted reasoning
is that $\alpha$-equivalence is just term equivalence.

\subsubsection*{Lifting}

Abstractions no longer introduce names, eliminating the need for
$\alpha$-conversion of bound variables.
However, manipulation of terms may still accidentally capture
variables when a de Bruijn index is moved over an abstraction.
In that case the index should be updated in order to still refer to the
original binding site.
This operation is called lifting. We denote the simple lifting operation
of incrementing all free variables in $M$ by $\uparrow \! M$.

% TODO: example

\subsubsection*{Substitution}

An example of an operation where lifting is used, is substitution.
Substituting $N$ for free de Bruijn index $n$ can be defined
\begin{align*}
  n[N/n]             &= N\\
  m[N/n]             &= m                    && \text{$m \neq n$} \\
  (\lambda .M')[N/n] &= \lambda .M'[\uparrow \! N / n\!+\!1]\\
  (M_1 \; M_2)[N/n]  &= M_1[N/n] \; M_2[N/n]
\end{align*}
which is structurally recursive.
Note that the lifting of $N$ in the case of abstraction is needed because
$N$ is moved into the abstraction $\lambda.M'$.
For the same reason, recursively substituting $\uparrow \! N$ in the body
$M'$ has to be done for indices $n+1$ instead of $n$.

\subsubsection*{de Bruijn Indices in Coq}

The following is a datatype definition in Coq for $\lambda$-calculus
terms using de Bruijn indices:
\begin{lstlisting}[frame=,xleftmargin=1em,xrightmargin=1em]
Inductive term : Set :=
  | Var : nat -> term
  | Abs : term -> term
  | App : term -> term -> term.
\end{lstlisting}
Substitution (listing~\ref{lst:bruijn-subst}) is easily implemented
using the lifting operation from listing~\ref{lst:bruijn-lift}.
\begin{lstlisting}[float,caption={{\small \em (de Bruijn indices)} Lifting},label=lst:bruijn-lift]
Fixpoint lift (l:nat) (t:term) {struct t} : term :=
  match t with
  | Var n   => Var (if le_lt_dec l n then (S n) else n)
  | Abs u   => Abs (lift (S l) u)
  | App u v => App (lift l u) (lift l v)
end.
\end{lstlisting}
\begin{lstlisting}[float,caption={{\small \em (de Bruijn indices)} Substitution},label=lst:bruijn-subst]
Fixpoint subst (t:term) (n:nat) (t':term) {struct t'} : term :=
  match t' with
  | Var m   => if eq_nat_dec n m then t else t'
  | Abs u   => Abs (subst (lift 0 t) (S n) u)
  | App u v => App (subst t n u) (subst t n v)
end.
\end{lstlisting}
More complex operations on terms may involve quite some
manipulation of indices.
Although these manipulations are easier to carry out than
$\alpha$-conversion in the named variables representation, they
are still cumbersome and obfuscate proof scripts.

\subsubsection*{Concluding} % TODO: andere titel

The most obvious advantage of a representation with de Bruijn
indices is that $\alpha$-equivalence is just term equivalence.
This does away with the problems usually associated with
$\alpha$-equivalence, a major win in automated reasoning.
Additionally, lifting is easier than $\alpha$-conversion (but
still tedious)  and there is no need to generate fresh names.

The representation diverges quite far from the traditional
representation using named variables.
Therefore, it is arguably harder to read and the relation
between the object language and formal developments using de
Bruijn indices might need some argumentation.


\subsection{Locally Nameless Representation}

A way to avoid accidental capturing of variables and thus the need for
$\alpha$-conversion is to make sure free and bound variables are drawn
from disjoint sets.
This strategy is implemented by the locally nameless representation,
where free variables are represented by names and bound variables are
represented by de Bruijn indices, effectively obeying Barendregt's
variable convention.
The resulting grammar is
\begin{align*}
  M ::=             &\; x
  && \text{free variable} \\
  \llap{\textbar\:} &\; n
  && \text{bound variable} \\
  \llap{\textbar\:} &\; \lambda . \; M
    && \text{abstraction} \\
  \llap{\textbar\:} &\; M \; M
  && \text{application}
\end{align*}
where $x$ ranges over a countably infinite set of names, and $n$ over
the natural numbers.

I am not a number, I am a free variable.

\subsubsection*{Freshening}

\subsubsection*{Substitution}

Substituting a term for a name:
\begin{align*}
  x[N/x]             &= N\\
  y[N/x]             &= y                 && \text{$x \neq y$} \\
  n[N/x]             &= n\\
  (\lambda .M')[N/x] &= \lambda .M'[N/x]\\
  (M_1 \; M_2)[N/x]  &= M_1[N/x] \; M_2[N/x]
\end{align*}

Substituting a term for a de Bruijn index is used to implement the
freshening operation:
\begin{align*}
  x[N/n]             &= x\\
  n[N/n]             &= N\\
  m[N/n]             &= m                    && \text{$m \neq n$} \\
  (\lambda .M')[N/n] &= \lambda .M'[N / n\!+\!1]\\
  (M_1 \; M_2)[N/n]  &= M_1[N/n] \; M_2[N/n]
\end{align*}

\subsubsection*{Locally Nameless Representation in Coq}

\begin{lstlisting}
Parameter name : Set.
Parameter eq_name : forall (x y : name), {x = y} + {x <> y}.

Inductive term : Set :=
  | FreeVar  : name -> term
  | BoundVar : nat -> term
  | Abs      : term -> term
  | App      : term -> term -> term.

Fixpoint subst_free (t:term) (x:name) (t':term)
  {struct t'} : term :=
  match t' with
  | FreeVar y  => if eq_name x y then t else t'
  | BoundVar n => t'
  | Abs b      => Abs (subst_free t x b)
  | App f a    => App (subst_free t x f) (subst_free t x a)
end.

Fixpoint subst_bound (t:term) (n:nat) (t':term)
  {struct t'} : term :=
  match t' with
  | FreeVar x  => t'
  | BoundVar m => if eq_nat_dec m n then t else t'
  | Abs b      => Abs (subst_bound t (S n) b)
  | App f a    => App (subst_bound t n f) (subst_bound t n a)
end.
\end{lstlisting}


\section{Applications}

\subsection{The POPLMark Challenge}

POPLmark 1a in Coq by Stump \cite{Stump-05}.
POPLmark in Coq by Vouillon \cite{Vouillon-05}.
McBride and McKinna \cite{McBride-McKinna-04}, implemented for POPLmark in Coq by Leroy \cite{Leroy-07}.

\subsection{Engineering Formal Metatheory}


\section{Discussion}\label{sec:discussion}

\subsection{Others Representations}

Nominal, higher order abstract syntax \cite{Capretta-Felty-06}, nested datatypes (Hirschowitz and Maggesi).

\subsection{Comparison}

\subsection{Conclusion and Related Work}


\nocite{*}
\bibliographystyle{amsplain}
\bibliography{literature-study}


\end{document}
